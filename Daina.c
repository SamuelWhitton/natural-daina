/*
  * Compilation Output Generated by Daina Compiler
  */

//The following output was generated by the parser:
/*
PARSER LOG: created parser
PARSER LOG: started parsing root tree
PARSER LOG: finished parsing root tree
*/

//The following output was generated by the analyser:
/*
Analysis: class order found...
Analysis: pruning classes not in main dependancy tree...
Analysis: analysing class - DainaCompiler...
Analysis: analysing entry point class...
*/

//The following describes the interface of the compiled class constructs:
/*


DainaCompiler : []
	:: newDainaCompiler [ -> [DainaCompiler]]
	++ runDainaCompiler [ -> ]

*/

//Zither Compiler Was Here
//Time to begin my work :), love me!!!!
     //BEGIN ZITHER
        //---------------------------------------------------------------
/*C*/   #include <stdlib.h>
/*C*/   #include <stdio.h>
/*C*/   #include <assert.h>
/*C*/   #include <string.h>
/*C*/   typedef struct _DynamicObject {long references;void* deallocator;} DynamicObject;
/*C*/   typedef struct _DynamicLambda {long references;void* deallocator;void* method;long dynamicFrameLength;} DynamicLambda;
/*C*/   void MainMethod();
/*C*/   int main(int argc, const char* argv[]) { int is32MachineBitOrGreater = (sizeof(void*) >= 4); assert(is32MachineBitOrGreater); assert(sizeof(long) >= 4); assert(sizeof(double) == sizeof(void*)); assert(sizeof(size_t) <= sizeof(void*)); MainMethod();}
/*C*/   #define RetainDynamicObject(_dynamicObjectInQuestion) ((DynamicObject *)((_dynamicObjectInQuestion)))->references++;
/*C*/   #define ReleaseDynamicObject(_dynamicObjectInQuestion) if ((--((DynamicObject *)((_dynamicObjectInQuestion)))->references) == 0) {((void*(*)(void*))(((DynamicObject *)((_dynamicObjectInQuestion)))->deallocator))(_dynamicObjectInQuestion);  free(_dynamicObjectInQuestion);}
/*C*/   void* deallocateDynamicLambda(void* object) {
/*C*/    long dynamicFrameLength = ((DynamicLambda *)(object))->dynamicFrameLength;
/*C*/    int i;for (i=0;i<dynamicFrameLength;++i) {ReleaseDynamicObject(*((void**)(object+sizeof(DynamicLambda)+i*sizeof(void*))));}
/*C*/    return NULL;
/*C*/   }
/*C*/   void* allocateDynamicLambda(long dynamicFrameLength, long totalFrameLength, void* staticMethodPointer) {
/*C*/    void* newAllocatedLambdaObject = malloc(sizeof(DynamicLambda)+sizeof(void*)*totalFrameLength);
/*C*/   
/*C*/    ((DynamicLambda *)(newAllocatedLambdaObject))->references=1;
/*C*/    ((DynamicLambda *)(newAllocatedLambdaObject))->deallocator=&deallocateDynamicLambda;
/*C*/    ((DynamicLambda *)(newAllocatedLambdaObject))->method=staticMethodPointer;
/*C*/    ((DynamicLambda *)(newAllocatedLambdaObject))->dynamicFrameLength=dynamicFrameLength;
/*C*/    return newAllocatedLambdaObject;
/*C*/   }
        //---------------------------------------------------------------
        //BEGIN TEMPLATE template_DainaCompiler
/*C*/   struct Z_template_DainaCompiler {
/*C*/    long references;void* deallocator;
        //END TEMPLATE
/*C*/   };
/*C*/   void* dealloc_Z_template_DainaCompiler(void* object) {
/*C*/    return NULL;
/*C*/   }
/*C*/   void* alloc_Z_template_DainaCompiler() {
/*C*/    void* newAllocatedObject = malloc(sizeof(struct Z_template_DainaCompiler));
/*C*/   
/*C*/    ((DynamicObject *)(newAllocatedObject))->references=1;
/*C*/    ((DynamicObject *)(newAllocatedObject))->deallocator=&dealloc_Z_template_DainaCompiler;
/*C*/    return newAllocatedObject;
/*C*/   }
        //DECLARE METHOD classmethod_DainaCompiler_newDainaCompiler()
/*C*/   void* Z_classmethod_DainaCompiler_newDainaCompiler(void* frame);
        //DECLARE METHOD classmethod_DainaCompiler_runDainaCompiler()
/*C*/   void* Z_classmethod_DainaCompiler_runDainaCompiler(void* frame);
        //START METHOD allocator_DainaCompiler()
/*C*/      void* Z_allocator_DainaCompiler(void* frame) {{
           //CREATE DYNAMIC_OBJECT newObject WITH TEMPLATE template_DainaCompiler
/*C*/      void* Z_newObject = alloc_Z_template_DainaCompiler();
           //RETURN newObject
/*C*/      return Z_newObject;
        //FINISH METHOD
/*C*/   }return NULL;}
        //START METHOD classmethod_DainaCompiler_newDainaCompiler()
/*C*/      void* Z_classmethod_DainaCompiler_newDainaCompiler(void* frame) {{
           //PULL OBJECTS FRAME{STATIC(),DYNAMIC(self)}
/*C*/      void* Z_self = *(((void* *)(frame+sizeof(void*)*0)));
           //RETAIN self
/*C*/      RetainDynamicObject(Z_self);
           //RETURN self
/*C*/      return Z_self;
        //FINISH METHOD
/*C*/   }return NULL;}
        //START METHOD classmethod_DainaCompiler_runDainaCompiler()
/*C*/      void* Z_classmethod_DainaCompiler_runDainaCompiler(void* frame) {{
           //PULL OBJECTS FRAME{STATIC(),DYNAMIC(self)}
/*C*/      void* Z_self = *(((void* *)(frame+sizeof(void*)*0)));
        //FINISH METHOD
/*C*/   }return NULL;}
        //---------------------------------------------------------------
        //START MAIN
/*C*/   void MainMethod() {
           //PULL OBJECTS FRAME{STATIC(),DYNAMIC()}
           //CREATE STATIC_OBJECT temporary_5 WITH METHOD allocator_DainaCompiler
/*C*/      void* Z_temporary_5 = &Z_allocator_DainaCompiler;
           //CREATE DYNAMIC_OBJECT temporary_4 WITH METHOD[STATIC_OBJECT] temporary_5 FRAME{STATIC(),DYNAMIC()}
/*C*/      void* Z_temporary_4 = allocateDynamicLambda(0,0,Z_temporary_5);
           //CREATE OBJECT temporary_3 = INVOKE temporary_4()
/*C*/      void* Z_temporary_3 = ((void*(*)(void*))(((DynamicLambda *)(Z_temporary_4))->method))(Z_temporary_4+sizeof(DynamicLambda));
           //RELEASE temporary_4
/*C*/      ReleaseDynamicObject(Z_temporary_4);
           //CREATE STATIC_OBJECT temporary_6 WITH METHOD classmethod_DainaCompiler_newDainaCompiler
/*C*/      void* Z_temporary_6 = &Z_classmethod_DainaCompiler_newDainaCompiler;
           //CREATE DYNAMIC_OBJECT temporary_2 WITH METHOD[STATIC_OBJECT] temporary_6 FRAME{STATIC(),DYNAMIC(temporary_3)}
/*C*/      void* Z_temporary_2 = allocateDynamicLambda(1,1,Z_temporary_6);
/*C*/      RetainDynamicObject(Z_temporary_3);
/*C*/      *(((void* *)(Z_temporary_2+sizeof(DynamicLambda)+sizeof(void*)*0))) = Z_temporary_3;
           //RELEASE temporary_3
/*C*/      ReleaseDynamicObject(Z_temporary_3);
           //CREATE OBJECT temporary_1 = INVOKE temporary_2()
/*C*/      void* Z_temporary_1 = ((void*(*)(void*))(((DynamicLambda *)(Z_temporary_2))->method))(Z_temporary_2+sizeof(DynamicLambda));
           //RELEASE temporary_2
/*C*/      ReleaseDynamicObject(Z_temporary_2);
           //CREATE STATIC_OBJECT local_dainaCompiler WITH EMPTY_VALUE
/*C*/      void* Z_local_dainaCompiler = ((void *)(0));
           //ASSIGN local_dainaCompiler = temporary_1
/*C*/      Z_local_dainaCompiler = Z_temporary_1;
           //CREATE STATIC_OBJECT temporary_9 WITH METHOD classmethod_DainaCompiler_runDainaCompiler
/*C*/      void* Z_temporary_9 = &Z_classmethod_DainaCompiler_runDainaCompiler;
           //CREATE DYNAMIC_OBJECT temporary_8 WITH METHOD[STATIC_OBJECT] temporary_9 FRAME{STATIC(),DYNAMIC(local_dainaCompiler)}
/*C*/      void* Z_temporary_8 = allocateDynamicLambda(1,1,Z_temporary_9);
/*C*/      RetainDynamicObject(Z_local_dainaCompiler);
/*C*/      *(((void* *)(Z_temporary_8+sizeof(DynamicLambda)+sizeof(void*)*0))) = Z_local_dainaCompiler;
           //CREATE OBJECT temporary_7 = INVOKE temporary_8()
/*C*/      void* Z_temporary_7 = ((void*(*)(void*))(((DynamicLambda *)(Z_temporary_8))->method))(Z_temporary_8+sizeof(DynamicLambda));
           //RELEASE temporary_8
/*C*/      ReleaseDynamicObject(Z_temporary_8);
           //RELEASE local_dainaCompiler
/*C*/      ReleaseDynamicObject(Z_local_dainaCompiler);
/*C*/   }
        //FINISH MAIN
        //---------------------------------------------------------------
     //END ZITHER




[] (SystemIO, String, Byte, Data, List, Integer, Natural, Sequence, Boolean, Loops, Variable, Mapping, Maybe) {
   *{

      [Maybe<[String]>] y1 = \[Maybe<[String]>]:nothing;
      [Maybe<[String]>] y2 = \[Maybe<[String]>]:as \[String]:as ##Hello Worl!##;
      
      \[SystemIO]:log \y1:isOrElse (*([String] s)->s) (*->nothingStr);
      \[SystemIO]:log \y2:isOrElse (*([String] s)->s) (*->nothingStr);





   } !{[String] nothingStr = \[String]:as ##<NOTHING>##}
}

[SystemIO] (String) {
      <<dlang ##
            import std.stdio;
         ##

   :: stdout *([Data] data) {

   }

   :: stdin *([Natural] bytesToRead) -> [Data] {
@chunks(stdin, 4096)
   } -> \[Data]:copy \[Sequence<[Byte]>]:empty

   :: log *([String] s) {
      <<dlang ##
            writeln((cast(WRAP!(string))((cast(CLASSTYPE_String)LOBJECT_s).IMETHOD_internalString(null, []))).it);
         ##;
   }
}


[Data :[Sequence<[Byte]>]] (Byte, Sequence, Loops, Natural)
{
   ~ copy *([Sequence<[Byte]>] bytes) {
      [Natural] length = \bytes:length;
      :length = *>length;
      :atIndex = *->\[Maybe<[&E]>]:nothing;
      \[Loops]:iterate bytes *([Natural] index, [Byte] byte) {
<<dlang ##
            //asdf
         ##;
      }
   }

   |++ length [->[Natural]]
   |++ atIndex [[Natural]->[Maybe<[&E]>]]
}

[Byte]
{

}

[Loops] (Sequence, Natural, Variable, Boolean)
{
   :: iterate *([Sequence<['E]>] sequence, [[Natural]['E]->] getNext) {
      [Variable<[Natural]>] currentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      \[:?]:while (*->\(\currentIndex:get):isLessThan \sequence:length) (*{
         \getNext index element;
         \currentIndex:set \index:adding (\[Natural]:as ##1##);
      } !{
            [?] index = \currentIndex:get;
            [?] element = \sequence:asIndex index;
         })
   }

   :: while *([->[Boolean]] condition, [->] action) {
      \[:?]:until *([->] stop) {
         \(\condition):ifOrElse action stop
      }
   }

   :: until *([[->]->] actionWithStop) {
      <<dlang ##
         bool continue = true;
      ##;
      <<dlang
      ##
         if (continue) {
      ##;
      \actionWithStop *{
         <<dlang ##
            continue = false;
         ##
      };
      <<dlang
      ##
         }
      ##;
   }
}

[Sequence<E>] (Maybe, Natural)
{
   @++ iterate [[[&E]->]->]
   ++ length [->[Natural]]
   ++ atIndex [[Natural]->[Maybe<[&E]>]]

   @++ appending *([Sequence<[&E]>] other) -> [Sequence<[&E]>] {
   @   [Sequence<[&E]>] this = ^
   @} -> [:[Sequence<[&E]>]]{ |++ iterate *([[&E]->] getNext) {\this:iterate getNext; \other:iterate getNext} }

   :: empty *-> [:[Sequence<[&E]>]] { 
         |++ length *->\[Natural]:as ##0##
         |++ atIndex *->\[Maybe<[&E]>]:nothing
      }

   @:: single *([&E] e) -> [:[Sequence<[&E]>]]{ |++ iterate *([[&E]->] getNext) {\getNext e} }
}


@@
Integer
Byte
Boolean
Variable
Maybe
Sequence
Natural
@@


[Maybe<E>] 
{
   ~ nothing *{
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \else
   }

   ~ as *([&E] it) {
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \is it
   }

   ++ isOrElse [[[&E]->['O]][->['O]]->['O]]
}

@@
[Integer] BigInt
{
   <<dlang ##
            import std.conv;
            import std.stdio;
            int value;
         ##

   ~ as *([%INTEGER] literal) {
      <<dlang ##
            this.value = to!int((cast(LITERAL_STRING)LOBJECT_literal).it);
         ##;
   }

   ~ zero *{
      \:~as ##0##;
   }
   ~ one *{
      \:~as ##1##;
   }

   :: add *([Integer] i1, [Integer] i2) -> [Integer]  {
         [Integer] result = \[Integer]:zero;
         <<dlang ##
            (cast(CLASSIMPL_Integer)LOBJECT_result).value = (cast(CLASSIMPL_Integer)LOBJECT_i1).value + (cast(CLASSIMPL_Integer)LOBJECT_i2).value;
         ##;
      }->result

   ++ debugPrint *{
      <<dlang ##
            writeln(this.value);
         ##;
   }
}@@

@[SelectMaybe]
@@

[MaybeEnum<O>] {
   ++ nothing [->[&O]]
   ++ just [['E]->[&O]]
}
@@


[String] (Data) 
{
   <<dlang ##
            WRAP!(string) value;
         ##

   ~ as *([%STRING] literal) {
      <<dlang ##
            this.value = cast(WRAP!(string))LOBJECT_literal;
         ##;
   }

   @++ ascii *->[Data]

   - internalString *{
      <<dlang ##
            return this.value;
         ##;
   }
}




@@


[Object] {
   ++ asdf *{}
}



@@





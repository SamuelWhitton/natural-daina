

[] (SystemIO, String, Byte, Data, List, Integer, Natural, Sequence, Boolean, Loops, Variable, Mapping, Maybe, SourcePosition, Error) {
   *{

      @[Maybe<[String]>] y1 = \[Maybe<[String]>]:nothing;
      @[Maybe<[String]>] y2 = \[Maybe<[String]>]:as \[String]:as ##Hello Worl!##;
      
      @\[SystemIO]:log \y1:isOrElse (*([String] s)->s) (*->nothingStr);
      @\[SystemIO]:log \y2:isOrElse (*([String] s)->s) (*->nothingStr);


      @@[Sequence<[Number]>] 5Times = [:[Sequence<[Number]>]] {
         |++ length *->\[Natural]:as ##5##
         |++ atIndex *(n)->\[Maybe<[?]>]:as n
      };
      \[Loops]:iterate 5Times *{
         \[SystemIO]:stdout \(\[String]:as ##Hello World!!\n##):ascii;
         \[SystemIO]:stdout \(\[String]:asASCII \[SystemIO]:stdin):ascii;
      };@@
      [SourcePosition] asdf = \[SourcePosition]:initialPositionIn (\[String]:as ##sadf/asdf/filenametest.h##) (\[String]:as ##This is a line....##);
      [SourcePosition] asdf2 = \asdf:startOfNextLine (\[String]:as ##This is a line2....##);
      [SourcePosition] asdf3 = \asdf2:startOfNextLine (\[String]:as ##This is a line3....##);
      [SourcePosition] asdf4 = \asdf3:nextColumn;


      \[SystemIO]:stdout \(\(\[Error]:expectingSecondHashForDataSegmentAnchor asdf4):description):ascii;
      \[SystemIO]:stdout \(\[String]:as ##\n##):ascii;

      \[Loops]:iterate ([:[Sequence<[Natural]>]] {
         |++ length *->\[Natural]:as ##10##
         |++ atIndex *([Natural] n)->\[Maybe<[?]>]:as \n:adding \[Natural]:as ##300000238974289438900234##
      }) *([Natural] index, [Natural]value){
         \[SystemIO]:stdout \(\[String]:stringFormatOf value):ascii;
         \[SystemIO]:stdout \(\[String]:as ##\n##):ascii;
      };
      
      


   } @!{[String] nothingStr = \[String]:as ##<NOTHING>##}
}

[SystemIO] (String) {
      <<dlang ##
            import std.stdio;
            import std.bigint;
         ##

   :: stdout *([Data] data) {
      [] _ = <<dlang ##
            write(cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it));
         ##;
   }

   :: stdin *-> [Data] {
      [Data] readedData = \[Data]:copy \[Sequence<[Byte]>]:empty;
      [] _ = << dlang ##
         //BigInt bytesToRead = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_bytesToRead).IMETHOD_internalInteger(null, []))).it;
         string rawLine = readln();
         if (rawLine == null) {
            rawLine = "";
         }
         ubyte[] line = cast(ubyte[])(rawLine);
         (cast(CLASSIMPL_Data)LOBJECT_readedData).value = new WRAP!(ubyte[])(line);
      ##;
@chunks(stdin, 4096)
@
@foreach (ubyte[] buffer; chunks(stdin, 4096))
 @   {
  @      ... use buffer ...
  @  }
@
   } -> readedData


}


[Data :[Sequence<[Byte]>]] (Byte, Sequence, Loops, Natural)
{
   <<dlang ##
         WRAP!(ubyte[]) value;
      ##

   ~ copy *([Sequence<[Byte]>] bytes) {
      [Natural] length = \bytes:length;
      :length = *->length;
      :atIndex = *->\[Maybe<[&E]>]:nothing;
      \[Loops]:iterate bytes *([Natural] index, [Byte] byte) {
         [] _ = <<dlang ##
            
         ##;
      }
   }

   ~ concatenating *([Sequence<[Data]>] datas) {
      [] _ = <<dlang ##
         ubyte[] concatedData;
      ##;
      \[Loops]:iterate datas *([]_, [Data] data) {
         [] _ = <<dlang ##
            ubyte[] thisData = (cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it;
            concatedData ~= thisData;
         ##;
      };
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])(concatedData);
      ##;
   }

   |++ length [->[Natural]]
   |++ atIndex [[Natural]->[Maybe<[&E]>]]


   - internalData *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }
}

[Byte]
{

}

[String] (Data, Sequence, List) 
   [Data] ascii
{
   <<dlang ##
         import std.bigint;
         import std.format;
      ##

   ~ as *([%STRING] literal) {
      .ascii = \[Data]:copy \[Sequence<[Byte]>]:empty;
      [] _ = <<dlang ##
         ubyte[] literalBytes = cast(ubyte[])((cast(WRAP!(string))LOBJECT_literal).it);
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(literalBytes);
      ##;
   }

   ~ asASCII *([Data] ascii) {
      .ascii = ascii
   }

   ~ concatenating *([Sequence<[String]>] strings) {
      [Sequence<[Data]>] asciis = [:[Sequence<[Data]>]] { 
         |++ length *->\strings:length
         |++ atIndex *([Natural] i)->\(\strings:atIndex i):isOrElse (*([String] s)->\[Maybe<[?]>]:as \s:ascii) [Maybe<[?]>]:nothing
      };
      \:~asASCII \[Data]:concatenating asciis
   }

   ~ stringFormatOf *([Integer] integer) {
      .ascii = \[Data]:copy \[Sequence<[Byte]>]:empty;
      [] _ = << dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         ubyte[] bytes = cast(ubyte[])(format("%d", integer));
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(bytes);
      ##;
   }

   ++ appending *([String] other) -> [String] {
      [String] this = ^;
      [Sequence<[String]>] both = [:[Sequence<[String]>]] { 
         |++ length *->\[Natural]:as ##2##
         |++ atIndex *([Natural] index)->[Maybe<[String]>]{
            [Boolean] indexIs0 = \index:isEqualTo (\[Natural]:as ##0##);
         }->\[Maybe<[String]>]:as \indexIs0:ifOrElse (*->this) (*->other)
      }
   } -> \[String]:concatenating both

   ++ ascii *->.ascii
}

[Loops] (Sequence, Natural, Variable, Boolean)
{
   :: iterate *([Sequence<['E]>] sequence, [[Natural]['E]->] getNext) {
      [Variable<[Natural]>] currentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      \[?:]:while ((*->((\index:isLessThan \sequence:length)!{[Natural] index = \currentIndex:get}))) *{
         {
            \element:isOrElse *(e){
               \getNext index e;
            } *{};
            @\getNext index element;
            \currentIndex:set \index:adding (\[Natural]:as ##1##);
         }!{
            [Natural] index = \currentIndex:get;
            [Maybe<['E]>] element = \sequence:atIndex index;
         }
      }
   }

   :: while *([->[Boolean]] condition, [->] action) {
      \[?:]:until *([->] stop) {
         \(\condition):ifOrElse action stop
      }
   }

   :: until *([[['E]->]->['E]] actionWithStop) -> ['E] { @add
      ['E] result = <<dlang ##
         bool continueActions = true;
         OBJECT LOBJECT_result = null;
         while (continueActions) {
      ##;
      \actionWithStop *(["E] resultFromAction) {
         [] _ = <<dlang ##
            continueActions = false;
            LOBJECT_result = LOBJECT_resultFromAction;
         ##
      };
      [] _ = <<dlang
      ##
         }
      ##;
   } -> result
}

[Variable<E>]
   [&E] variableObject
{
   ~ as *([&E] initialInstantiation) {
      .variableObject = initialInstantiation;
   }

   ++ get *->.variableObject

   ++ set *([&E] newInstantiation) {
      [] _ = << dlang ##
         IOBJECT_variableObject = LOBJECT_newInstantiation;
      ##;
   }
}


[Sequence<E>] (Maybe, Natural)
{
   ++ length [->[Natural]]
   ++ atIndex [[Natural]->[Maybe<[&E]>]]

   :: empty *-> [:[Sequence<[&E]>]] { 
         |++ length *->\[Natural]:as ##0##
         |++ atIndex *->\[Maybe<[&E]>]:nothing
      }

}


[Natural :[Integer]] (Integer)
{
   <<dlang ##
         import std.format;
         import std.conv;
         import std.bigint;
      ##
   

   ~ as *([%NATURAL] literal) {
      [Integer] integerRepresentation = <<dlang ##
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[LOBJECT_literal]);
      ##;
      \$~>integerRepresentation;
   }

   ~ clampTo0 *([Integer] integer) {
      [Integer] integerRepresentation = <<dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         if (integer < BigInt("0")) {
            integer = BigInt("0");
         }
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", integer))]);
      ##;
      \$~>integerRepresentation;
   }

   ~ magnitudeOf *([Integer] integer) {
      [Integer] integerRepresentation = <<dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         if (integer < BigInt("0")) {
            integer = integer*BigInt("-1");
         }
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", integer))]);
      ##;
      \$~>integerRepresentation;
   }

   ++ adding *([Natural] toAdd) -> [Natural] {
      [Natural] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toAddBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toAdd).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt + toAddBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
}


[Maybe<E>] 
{
   ~ nothing *{
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \else
   }

   ~ as *([&E] it) {
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \is it
   }

   ++ isOrElse [[[&E]->['O]][->['O]]->['O]]
}

[Boolean] 
{
   ~ false *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \else
   }

   ~ true *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \if
   }

   ++ ifOrElse [[->['O]][->['O]]->['O]]
}


[Integer] (Boolean)
{
   <<dlang ##
            import std.conv;
            import std.bigint;
            import std.format;
            WRAP!(BigInt) value;
         ##

   ~ as *([%INTEGER] literal) {
      [] _ = <<dlang ##
         this.value = new WRAP!(BigInt)(BigInt((cast(WRAP!(string))LOBJECT_literal).it));
      ##;
   }

   ++ isLessThan *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isLessThan = << dlang ## 
         bool isLessThan = this.value.it < (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isLessThan = isLessThan ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isLessThan

   ++ isEqualTo *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = this.value.it == (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ subtracting *([Integer] toSubtract) -> [Integer] {
      [Integer] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toSubtractBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toSubtract).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt - toSubtractBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
   

   - internalInteger *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }

}


[ListNode<E>] () -> (List)
{
   ~ withValue *([&E] value) {
      :value = *-> value;
      :next = *-> \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      :previous = *-> \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
   }

   ++ value [->[&E]]
   ++ next [->[Variable<[Maybe<[ListNode<[&E]>]>]>]]
   ++ previous [->[Variable<[Maybe<[ListNode<[&E]>]>]>]]
}

[List<E> : [Sequence<[&E]>]] (ListNode, Boolean, Maybe, Variable, Sequence, Natural, Loops)
   [Variable<[Maybe<[ListNode<[&E]>]>]>] first
   [Variable<[Maybe<[ListNode<[&E]>]>]>] last
   [Variable<[Natural]>] length
{
   ~ empty *{
      .first = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      .last = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      .length = \[Variable<[?]>]:as \[Natural]:as ##0##;
   }

   @ copy [Sequence<[&E]>]

   ++ length *->\.length:get

   ++ atIndex *([Natural] index) -> [Maybe<[&E]>] {
      [Variable<[Natural]>] varCurrentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      [Variable<[Maybe<[ListNode<[&E]>]>]>] varCurrentNode = \[Variable<[?]>]:as \.first:get;
      [Maybe<[&E]>] atIndex = \[Loops]:until *([[Maybe<[&E]>]->] choose) {
         [Natural] currentIndex = \varCurrentIndex:get;
         [Maybe<[ListNode<[&E]>]>] currentNode = \varCurrentNode:get;
         @[] _ = <<dlang ## import std.stdio; writeln("asdf6");##;
         \varCurrentNode:set \currentNode:isOrElse (*([ListNode<[&E]>] n)-> [Maybe<[ListNode<[&E]>]>] {
            @[] _ = <<dlang ## import std.stdio; writeln("asdf5");##;
               [Boolean] sameIndex = (\currentIndex:isEqualTo index);
               \sameIndex:ifOrElse *{
                  \choose \[Maybe<[&E]>]:as \n:value;
               } *{};
            } ->\n:next) 
         (*->[Maybe<[ListNode<[&E]>]>]{\choose \[Maybe<[&E]>]:nothing}->\[Maybe<[ListNode<[&E]>]>]:nothing);
         \varCurrentIndex:set \currentIndex:adding \[Natural]:as ##1##;
      }
   } -> atIndex

   ++ removeFirst *-> [Maybe<[&E]>] {
      [Maybe<[ListNode<[&E]>]>] first = \.first:get;
   } -> \first:isOrElse (*([ListNode<[&E]>] node) -> [Maybe<[&E]>] {
         \.first:set \node:next;
         [Natural] length = \.length:get;
         \.length:set \[Natural]:clampTo0 \length:subtracting \[Natural]:as ##1##;
      } -> \[Maybe<[?]>]:as \node:value) (*->\[Maybe<[&E]>]:nothing)
   
   ++ prepend *([&E] value) {
      [Natural] length = \.length:get;
      \.length:set \length:adding \[Natural]:as ##1##;
      [ListNode<[&E]>] newNode = \[ListNode<[&E]>]:withValue value;
      [Maybe<[ListNode<[&E]>]>] first = \.first:get;
      \first:isOrElse *([ListNode<[&E]>] firstNode) {
         [Variable<[Maybe<[ListNode<[&E]>]>]>] firstNodePrevious = \firstNode:previous;
         [Variable<[Maybe<[ListNode<[&E]>]>]>] newNodeNext = \newNode:next;
         \newNodeNext:set .first;
         \firstNodePrevious:set \[Maybe<[?]>]:as newNode;
      } *{
         \.last:set \[Maybe<[?]>]:as newNode;
      };
      \.first:set \[Maybe<[?]>]:as newNode;
   }

   ++ removeLast *-> [Maybe<[&E]>] {
      [Maybe<[ListNode<[&E]>]>] last = \.last:get;
   } -> \last:isOrElse (*([ListNode<[&E]>] node) -> [Maybe<[&E]>] {
         \.last:set \node:previous;
         [Natural] length = \.length:get;
         \.length:set \[Natural]:clampTo0 \length:subtracting \[Natural]:as ##1##;
      } -> \[Maybe<[?]>]:as \node:value) (*->\[Maybe<[&E]>]:nothing)

   ++ append *([&E] value) {
      [Natural] length = \.length:get;
      \.length:set \length:adding \[Natural]:as ##1##;
      [ListNode<[&E]>] newNode = \[ListNode<[&E]>]:withValue value;
      [Maybe<[ListNode<[&E]>]>] last = \.last:get;
      \last:isOrElse *([ListNode<[&E]>] lastNode) {
         [Variable<[Maybe<[ListNode<[&E]>]>]>] newNodePrevious = \newNode:previous;
         [Variable<[Maybe<[ListNode<[&E]>]>]>] lastNodeNext = \lastNode:next;
         \newNodePrevious:set .last;
         \lastNodeNext:set \[Maybe<[?]>]:as newNode;
      } *{
         \.first:set \[Maybe<[?]>]:as newNode;
      };
      \.last:set \[Maybe<[?]>]:as newNode;
   }
}



@@
Analysis: analysing class - InternalValue...
Analysis: analysing class - InternalPointer...
Analysis: analysing class - Object...
Analysis: analysing class - Variable...
Analysis: analysing class - InternalNonReleasingReference...
Analysis: analysing class - WeakReference...
Analysis: analysing class - Boolean...
Analysis: analysing class - Container...
Analysis: analysing class - TrainCarriage...
Analysis: analysing class - ControlFlowRecursiveConstructor...
Analysis: analysing class - ControlFlowRecursiveTransformer...
Analysis: analysing class - SingleMapping...
Analysis: analysing class - BinaryTree...
Analysis: analysing class - Byte...
Analysis: analysing class - Conjecture...
Analysis: analysing class - LambdaAToB...
Analysis: analysing class - Wrapper...
Analysis: analysing class - CoreFlow...
Analysis: analysing class - Train...
Analysis: analysing class - ControlFlow2...
Analysis: analysing class - Maybe...
Analysis: analysing class - List...
Analysis: analysing class - Sequence...
Analysis: analysing class - Sequences2...
Analysis: analysing class - Data...
Analysis: analysing class - SetObject...
Analysis: analysing class - Integer...
Analysis: analysing class - Natural...
Analysis: analysing class - ControlFlow...
Analysis: analysing class - String...
Analysis: analysing class - Token...
Analysis: analysing class - Loops...
**Analysis: analysing class - SourcePosition...
**Analysis: analysing class - Error...
Analysis: analysing class - MappingBucket...
Analysis: analysing class - Mapping...
*Analysis: analysing class - CommandReader...
Analysis: analysing class - Character...
Analysis: analysing class - O...
Analysis: analysing class - M...
Analysis: analysing class - SocketPort...
Analysis: analysing class - InternalSocketHeader...
Analysis: analysing class - DataStream...
Analysis: analysing class - AutomaticallyClosingSocketLink...
Analysis: analysing class - OutputStream...
Analysis: analysing class - SocketLinkOutputStream...
Analysis: analysing class - InputStream...
Analysis: analysing class - SocketLinkInputStream...
Analysis: analysing class - SocketConnection...
Analysis: analysing class - SocketBinding...
Analysis: analysing class - AutomaticallyClosingInputFileDataStream...
Analysis: analysing class - AutomaticallyClosingOutputFileDataStream...
Analysis: analysing class - IPAddress...
Analysis: analysing class - SystemInputOutput...
Analysis: analysing class - Configuration...
Analysis: analysing class - Debug...
Analysis: analysing class - Parser...
Analysis: analysing class - Commands...
Analysis: analysing class - DainaGeneralIdentifier...
Analysis: analysing class - DainaGenericDeclarationList...
Analysis: analysing class - DainaDependancyStructure...
Analysis: analysing class - DainaClassIdentifier...
Analysis: analysing class - DainaType...
Analysis: analysing class - DainaObjectDeclaration...
Analysis: analysing class - DainaClassMethod...
Analysis: analysing class - DainaCompilerInjection...
Analysis: analysing class - DainaExpression...
Analysis: analysing class - DainaClass...
Analysis: analysing class - DLangSynthesizer...
Analysis: analysing class - Daina...


@@


@ DAINA COMPILER -------

[SourcePosition] (
         Natural,
         String,
         Variable,
         Object,
         Loops
      )
   [String] sourceName
   [Natural] line
   [Natural] column
   [String] lineContent
{
   ~ initialPositionIn *([String] sourceName, [String] lineContent) {
      \:~lineAndColumnIn (\[Natural]:as ##0##) (\[Natural]:as ##0##) sourceName lineContent;
   }

   ~ -+- lineAndColumnIn *([Natural] line, [Natural] column, [String] sourceName, [String] lineContent) {
      .sourceName = sourceName;
      .column = column;
      .line = line;
      .lineContent = lineContent;
   }

   ++ description *-> [String] {
      [String] colon = \[String]:as ##:##;
      [String] pos = \[String]:as ## pos ##;
      [String] line = \[String]:stringFormatOf (\.line:adding (\[Natural]:as ##1##));
      [String] column = \[String]:stringFormatOf (\.column:adding (\[Natural]:as ##1##));
      [String] tabulation = \[String]:as ##\n    ##;
      [Variable<[String]>] linePositionArrow = \[Variable<[String]>]:as (\[String]:as ####);
      \[Loops]:iterate ([:[Sequence<[Natural]>]] { 
         |++ length *->.column
         |++ atIndex *(i)->\[Maybe<[?]>]:as i
      }) *{
         [String] curr = \linePositionArrow:get;
         \linePositionArrow:set (\curr:appending (\[String]:as ## ##));
      };
      [String] curr = \linePositionArrow:get;
      \linePositionArrow:set (\curr:appending (\[String]:as ##^##));
   } -> (\.sourceName:appending (\colon:appending (\line:appending (\pos:appending (\column:appending (\tabulation:appending (\.lineContent:appending (\tabulation:appending (\linePositionArrow:get)))))))))

   ++ nextColumn *-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Natural]:as ##1##)) (.sourceName) (.lineContent)

   ++ startOfNextLine *([String] lineContent)-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Natural]:as ##1##)) (\[Natural]:as ##0##) (.sourceName) lineContent
}



[Error] (Object, String, SourcePosition, List, Variable)
   [String] errorString
{
   ++ description *-> [String] {
      [String] errorPrefix = \[String]:as ##ERROR; ##;
   } -> (\errorPrefix:appending .errorString)

   ~ -+- as *([String] errorString) {
      .errorString = errorString;
   }

   ~ -+- errorWithContext *([String] errorString, [List<[SourcePosition]>] context) {
      [Variable<[String]>] errorWithContext = \[Variable<[String]>]:as errorString;
      \[Loops]:iterate context *([] _, [SourcePosition] sourcePosition) {
         [String] addedContext = (\prefix:appending (\sourcePosition:description)) !{
               [String] prefix = \[String]:as ## - ##;
            };
         \errorWithContext:set (\prefix:appending addedContext) !{
               [String] prefix = \errorWithContext:get;
            };
      };
      .errorString = \errorWithContext:get;
   }

   :: sourceFileNotAccessible *([String] fileName) -> [Error] {
      [String] prefix = \[String]:as ##Source file not accessible: ##;
   } -> (\[Error]:as (\prefix:appending fileName))

   :: unrecognisedToken *([String] token, [SourcePosition] position) -> [Error] {
      [String] prefix = \[String]:as ##Unrecognised token: ##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext (\prefix:appending token) context)

   :: invalidVisibilityIndicator *([SourcePosition] position) -> [Error] {
      [String] error = \[String]:as ##Invalid visibility indicator##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext error context)

    :: expectingSecondHashForDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second hash for data segment anchor##) context)

   :: expectingSecondDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second data segment anchor##) context)

   :: expectingClassAtTopLevel *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class at top level##) context)

   :: expectingBodyOfClass *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting body of class##) context)

   :: expectingEntryPointMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting entry point method##) context)

   :: expectingClosingBracketForClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class body##) context)

   :: expectingClassName *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class name##) context)

   :: expectingParentType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type##) context)

   :: expectingClosingSquareBracketAfterClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after class header##) context)

   :: expectingGenericIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting generic identifier##) context)

   :: expectingClosingBracketForGenericDeclarationList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for generic declaration list##) context)

   :: expectingDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting dependancy##) context)

   :: expectingReverseDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy##) context)

   :: expectingClosingBracketForDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy list##) context)

   :: expectingReverseDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy list##) context)

   :: expectingType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting type##) context)

   :: expectingOneOrMoreTypesForClassGenericInstantiation *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting one or more types for class generic instantiation##) context)

   :: expectingClosingBracketForClassGenericInstantiations *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class generic instantiations##) context)

   :: expectingClosingBracketForType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for type##) context)

   :: expectingClosingBracketForDependancyWithDerivatives *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy with derivatives##) context)

   :: expectingIdentifierForObjectDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for object declaration##) context)

   :: expectingVisibilityIndicatorForInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting visibility indicator for instance method##) context)

   :: expectingIdentifierForClassMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for class method##) context)

   :: expectingClassMethodExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class method expression##) context)

   :: expectingIdentifierForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for compiler injection##) context)

   :: expectingDataSegmentForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting data segment for compiler injection##) context)

   :: expectingPrologueStatement *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting prologue statement##) context)

   :: expectingMethodInput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method input##) context)

   :: expectingClosingBracketForMethodInputs *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for method inputs##) context)

   :: expectingMethodBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method body##) context)

   :: expectingMethodOutput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method output##) context)

   :: expectingClosingBracketForStatementGroup *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for statement group##) context)

   :: expectingParentTypeForAnonymousClassObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type for anonymous class object##) context)

   :: expectingClosingSquareBracketAfterAnonymousClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after anonymous class header##) context)

   :: expectingAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting anonymous class body##) context)

   :: expectingClosingBracketForAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for anonymous class body##) context)

   :: unexpectedTokenAfterType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token after type##) context)

   :: expectingInstanceMethodIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance method identifier##) context)

   :: expectingExpressionToBeCast *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to be cast##) context)

   :: expectingClosingBracketForCastExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for cast expression##) context)

   :: expectingIdentifierForTypeMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for type method##) context)

   :: expectingEqualsToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting equals to assign local declaration##) context)

   :: expectingExpressionToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign local declaration##) context)

   :: expectingExpressionToAssignInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance method##) context)

   :: expectingExpressionToAssignInstanceObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance object##) context)

   :: expectingInstanceObjectIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance object identifier##) context)

   :: unexpectedTokenBeforeTilde *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token before tilde##) context)

   :: expectingMethodToInvoke *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method to invoke##) context)

   :: expectingProxyObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting proxy object##) context)

   :: expectingCompilerInjectionIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection identifier##) context)

   :: expectingCompilerInjectionDataSegment *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection data segment##) context)

   :: expectingExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression##) context)

   :: expectingClosingBracketForExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for expression##) context)

   :: expectingConstructorIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting constructor identifier##) context)


}











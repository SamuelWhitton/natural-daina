

[] (SystemIO, String, Byte, Data, List, Integer, Natural, Sequence, Boolean, Loops, Variable, Mapping, Maybe) {
   *{

      @[Maybe<[String]>] y1 = \[Maybe<[String]>]:nothing;
      @[Maybe<[String]>] y2 = \[Maybe<[String]>]:as \[String]:as ##Hello Worl!##;
      
      @\[SystemIO]:log \y1:isOrElse (*([String] s)->s) (*->nothingStr);
      @\[SystemIO]:log \y2:isOrElse (*([String] s)->s) (*->nothingStr);


      [Sequence<[Number]>] 5Times = [:[Sequence<[Number]>]] {
         |++ length *->\[Natural]:as ##5##
         |++ atIndex *(n)->\[Maybe<[?]>]:as n
      };
      \[Loops]:iterate 5Times *{
         \[SystemIO]:stdout \(\[String]:as ##Hello World!!\n##):ascii;
      };
      


   } @!{[String] nothingStr = \[String]:as ##<NOTHING>##}
}

[SystemIO] (String) {
      <<dlang ##
            import std.stdio;
         ##

   :: stdout *([Data] data) {
      [] _ = <<dlang ##
            write(cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it));
         ##;
   }

   :: stdin *([Natural] bytesToRead) -> [Data] {
@chunks(stdin, 4096)
@
@foreach (ubyte[] buffer; chunks(stdin, 4096))
 @   {
  @      ... use buffer ...
  @  }
@
   } -> \[Data]:copy \[Sequence<[Byte]>]:empty


}


[Data :[Sequence<[Byte]>]] (Byte, Sequence, Loops, Natural)
{
   <<dlang ##
         WRAP!(ubyte[]) value;
      ##

   ~ copy *([Sequence<[Byte]>] bytes) {
      [Natural] length = \bytes:length;
      :length = *>length;
      :atIndex = *->\[Maybe<[&E]>]:nothing;
      \[Loops]:iterate bytes *([Natural] index, [Byte] byte) {
         [] _ = <<dlang ##
            
         ##;
      }
   }

   |++ length [->[Natural]]
   |++ atIndex [[Natural]->[Maybe<[&E]>]]


   - internalData *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }
}

[Byte]
{

}

[String] (Data) 
   [Data] ascii
{
   ~ as *([%STRING] literal) {
      .ascii = \[Data]:copy \[Sequence<[Byte]>]:empty;
      [] _ = <<dlang ##
         ubyte[] literalBytes = cast(ubyte[])((cast(WRAP!(string))LOBJECT_literal).it);
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(literalBytes);
      ##;
   }

   ++ ascii *->.ascii
}

[Loops] (Sequence, Natural, Variable, Boolean)
{
   :: iterate *([Sequence<['E]>] sequence, [[Natural]['E]->] getNext) {
      [Variable<[Natural]>] currentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      \[?:]:while ((*->((\index:isLessThan \sequence:length)!{[Natural] index = \currentIndex:get}))) *{
         {
            \getNext index element;
            \currentIndex:set \index:adding (\[Natural]:as ##1##);
         }!{
            [Natural] index = \currentIndex:get;
            [?] element = \sequence:atIndex index;
         }
      }
   }

   :: while *([->[Boolean]] condition, [->] action) {
      \[?:]:until *([->] stop) {
         \(\condition):ifOrElse action stop
      }
   }

   :: until *([[['E]->]->['E]] actionWithStop) { @add
      [] _ = <<dlang ##
         bool continueActions = true;
         while (continueActions) {
      ##;
      \actionWithStop *{
         [] _ = <<dlang ##
            continueActions = false;
         ##
      };
      [] _ = <<dlang
      ##
         }
      ##;
   }
}

[Variable<E>]
   [&E] variableObject
{

   ~ as *([&E] initialInstantiation) {
      .variableObject = initialInstantiation;
   }

   ++ get *->.variableObject

   ++ set *([&E] newInstantiation) {
      .variableObject = newInstantiation;
   }
}


[Sequence<E>] (Maybe, Natural)
{
   ++ length [->[Natural]]
   ++ atIndex [[Natural]->[Maybe<[&E]>]]

   :: empty *-> [:[Sequence<[&E]>]] { 
         |++ length *->\[Natural]:as ##0##
         |++ atIndex *->\[Maybe<[&E]>]:nothing
      }

}


[Natural :[Integer]] (Integer)
{
   <<dlang ##
         import std.format;
         import std.conv;
         import std.bigint;
      ##
   

   ~ as *([%NATURAL] literal) {
      [Integer] integerRepresentation = <<dlang ##
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[LOBJECT_literal]);
      ##;
      \$~>integerRepresentation;
   }

   ++ adding *([Natural] toAdd) -> [Natural] {
      [Natural] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toAddBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toAdd).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt + toAddBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
}


[Maybe<E>] 
{
   ~ nothing *{
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \else
   }

   ~ as *([&E] it) {
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \is it
   }

   ++ isOrElse [[[&E]->['O]][->['O]]->['O]]
}

[Boolean] 
{
   ~ false *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \else
   }

   ~ true *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \if
   }

   ++ ifOrElse [[->['O]][->['O]]->['O]]
}


[Integer] (Boolean)
{
   <<dlang ##
            import std.conv;
            import std.bigint;
            WRAP!(BigInt) value;
         ##

   ~ as *([%INTEGER] literal) {
      [] _ = <<dlang ##
         this.value = new WRAP!(BigInt)(BigInt((cast(WRAP!(string))LOBJECT_literal).it));
      ##;
   }

   ++ isLessThan *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isLessThan = << dlang ## 
         bool isLessThan = this.value.it < (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isLessThan = isLessThan ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isLessThan

   

   - internalInteger *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }

}














[Debug] (OutputStream, String, SystemInputOutput){
   :: log *([String] s){
      [[Data]->] out = [StandardIO]:stdout;
      \out \s:ascii;
   }
}


[InternalNonReleasingReference<E>] (Object) -> (WeakReference)
   [&E] referenceToObject
{

   ~ nonReleasingReferenceTo *([&E] referenceToObject) {
      .referenceToObject = referenceToObject;
   }

   ++ referencedObject *->.referenceToObject
}

[WeakReference<E>] (Object, InternalNonReleasingReference)
   [InternalNonReleasingReference<[&E]>] nonReleasingReference
{

   ~ weakReferenceTo *([&E] objectToHaveWeakReferenceTo) {
      .nonReleasingReference = \[InternalNonReleasingReference<[&E]>]:nonReleasingReferenceTo objectToHaveWeakReferenceTo;
   }

   ++ referencedObject *->\.nonReleasingReference:referencedObject
}


[Wrapper<F> : [Container<[&F]>]] (Object, Container, Boolean)
   [&F] wrappedObject
{
   ~ wrapperWithObject *([&F] objectToWrap) {
      \$~newEmptyContainer;
      .wrappedObject = objectToWrap;
   }

   |++ isEmpty *->[Boolean]{}->\[Boolean]:false

   |++ store *([&F] objectToStoreInContainer) {
      .wrappedObject = objectToStoreInContainer;
   }

   |++ retrive *([[&F]->] objectTaker) {
      \objectTaker .wrappedObject;
   }

   ++ unwrap *->.wrappedObject
}







[TrainCarriage<E> : [Container<[&E]>]] (Container, Boolean, Object, WeakReference) -> (Train, List)
   [Container<[TrainCarriage<[&E]>]>] backCoupling
   [Container<[WeakReference<[TrainCarriage<[&E]>]>]>] frontCoupling
{
   ~ newEmptyCarriage *{
      \$~newEmptyContainer;

      .backCoupling = \[Container<[TrainCarriage<[&E]>]>]:newEmptyContainer;
      .frontCoupling = \[Container<[WeakReference<[TrainCarriage<[&E]>]>]>]:newEmptyContainer;
   }

   ++ connectBackCouplerToCarriage *([TrainCarriage<[&E]>] carriage) {
      \.backCoupling:store carriage;
   }

   ++ connectFrontCouplerToCarriage *([TrainCarriage<[&E]>] carriage) {
      \.frontCoupling:store (\[WeakReference<[TrainCarriage<[&E]>]>]:weakReferenceTo carriage);
   }

   @@++ carriageByEmptyingCarriage * -> [TrainCarriage<[&E]>] {
      [TrainCarriage<[&E]>] newCarriage = \[TrainCarriage<[&E]>]:newEmptyCarriage;
      \:retriveCarriageCoupledToBack *([TrainCarriage<[&E]>] coupledCarriage) {
         \newCarriage:connectBackCouplerToCarriage coupledCarriage;
      };
      \:retriveCarriageCoupledToFront *([TrainCarriage<[&E]>] coupledCarriage) {
         \newCarriage:connectFrontCouplerToCarriage coupledCarriage;
      };
   } -> newCarriage@@

   ++ isNotConnectedToAnyCarriage * -> (\[Boolean]:and (\.backCoupling:isEmpty) \.frontCoupling:isEmpty)
   
   ++ frontCouplingIsConnectedToACarriage * -> (\[Boolean]:not (\.frontCoupling:isEmpty)) 
   ++ backCouplingIsConnectedToACarriage * -> (\[Boolean]:not (\.backCoupling:isEmpty)) 

   ++ retriveCargoWithReceiver *([[&E]->] cargoReceiver) {
      \:retrive cargoReceiver;
   }

   ++ performActionIfCarriageIsFull *([->] actionToDoIfWeHaveCargo) {
      [Boolean] carriageIsEmpty = \:isEmpty;
      \carriageIsEmpty:ifOrElse *{} actionToDoIfWeHaveCargo;
   }

   ++ retriveCarriageCoupledToFront *([[TrainCarriage<[&E]>]->] carriageRetriver) {
      \.frontCoupling:retrive *([WeakReference<[TrainCarriage<[&E]>]>] weakReferenceToCarriage) {
         \carriageRetriver (\weakReferenceToCarriage:referencedObject);
      };
   }

   ++ retriveCarriageCoupledToBack *([[TrainCarriage<[&E]>]->] carriageRetriver) {
      \.backCoupling:retrive carriageRetriver;
   }

   ++ disconnectBackCoupler *{.backCoupling = \[Container<[TrainCarriage<[&E]>]>]:newEmptyContainer;}
   ++ disconnectFrontCoupler *{.frontCoupling = \[Container<[WeakReference<[TrainCarriage<[&E]>]>]>]:newEmptyContainer;}

}






[Train<E>] (Object, TrainCarriage, Container, Boolean, Wrapper, CoreFlow, Conjecture, Loops)
   [TrainCarriage<[&E]>] backCarriage
   [TrainCarriage<[&E]>] frontCarriage
{
   ~ newEmptyTrain *{
      .backCarriage = \[TrainCarriage<[&E]>]:newEmptyCarriage;
      .frontCarriage = .backCarriage;
   }

   ++ isEmpty * -> [Boolean] {
      [Conjecture] trainIsEmpty = \[Conjecture]:assume;
         [->] realiseThatCargoWasFound = *{\trainIsEmpty:declareFalse;};
      \.frontCarriage:performActionIfCarriageIsFull *{\realiseThatCargoWasFound;};
         
   } 
    -> \trainIsEmpty:isTrue


   ++ emptyTrain *{
      .frontCarriage = \[TrainCarriage<[&E]>]:newEmptyCarriage;
      .backCarriage = .frontCarriage;
   }

   - emptyTrainIfThereIsOnlyOneCarriageLeft *{
      [Boolean] shouldEmptyTheTrain = \.frontCarriage:isNotConnectedToAnyCarriage;
      \shouldEmptyTheTrain:ifOrElse (:emptyTrain) *{};
   }


   ++ popFromFront *([[&E]->] cargoReceiver) {
         \.frontCarriage:retriveCargoWithReceiver cargoReceiver;
      \:emptyTrainIfThereIsOnlyOneCarriageLeft;
      \dropFrontCarriageIfItIsNotTheLastCarriage;
   
   }  !{
         [->] dropFrontCarriageIfItIsNotTheLastCarriage = *{
            \.frontCarriage:retriveCarriageCoupledToBack *([TrainCarriage<[&E]>] carriageCoupledToBack) {
               .frontCarriage = carriageCoupledToBack;
               \.frontCarriage:disconnectFrontCoupler;
            };
         };
      }


   ++ popFromBack *([[&E]->] cargoReceiver) {
         \.backCarriage:retriveCargoWithReceiver cargoReceiver;
      \:emptyTrainIfThereIsOnlyOneCarriageLeft;
      \dropBackCarriageIfItIsNotTheLastCarriage;
      

   }  !{
         [->] dropBackCarriageIfItIsNotTheLastCarriage = *{
            \.backCarriage:retriveCarriageCoupledToFront *([TrainCarriage<[&E]>] carriageCoupledToFront) {
               .backCarriage = carriageCoupledToFront;
               \.backCarriage:disconnectBackCoupler;
            };
         };
      }



   ++ pushToFront *([&E] cargo) {
      \getFrontCarriageReadyForNewCargo;
      \.frontCarriage:store cargo;
      
   }  !{
         [->] getFrontCarriageReadyForNewCargo = *{
            \.frontCarriage:performActionIfCarriageIsFull *{
               [TrainCarriage<[&E]>] newFrontCarriage = \[TrainCarriage<[&E]>]:newEmptyCarriage;
               \:coupleCarriagesWithFrontAndBackCarriage newFrontCarriage .frontCarriage;
               .frontCarriage = newFrontCarriage;
            };
         };
      }


   ++ pushToBack *([&E] cargo) {
      \getBackCarriageReadyForNewCargo;
      \.backCarriage:store cargo;
   
   }  !{
         [->] getBackCarriageReadyForNewCargo = *{
            \.backCarriage:performActionIfCarriageIsFull *{
               [TrainCarriage<[&E]>] newBackCarriage = \[TrainCarriage<[&E]>]:newEmptyCarriage;
               \:coupleCarriagesWithFrontAndBackCarriage .backCarriage newBackCarriage;
               .backCarriage = newBackCarriage;
            };
         };
      }


   - coupleCarriagesWithFrontAndBackCarriage *([TrainCarriage<[&E]>] frontCarriage, [TrainCarriage<[&E]>] backCarriage) {
      \frontCarriage:connectBackCouplerToCarriage backCarriage;
      \backCarriage:connectFrontCouplerToCarriage frontCarriage;
   }

   - iterateThroughCarriages *([[TrainCarriage<[&E]>]->] carriageReceiver) {
      \[Loops]:until *([->] stop) {
         \carriageReceiver currentCarriageWeAreLookingAt;
         [Boolean] moreCarrigesToLookInside = \checkIfThereAreMoreCarriagesToLookInside;
         \moreCarrigesToLookInside:ifOrElse moveToNextCarriage stop;
         
      }  !{
            [TrainCarriage<[&E]>] currentCarriageWeAreLookingAt = \getCurrentCarriageWeAreLookingAt;
            [->] moveToNextCarriage = *{
               \currentCarriageWeAreLookingAt:retriveCarriageCoupledToBack *([TrainCarriage<[&E]>] carriageCoupledToBack) {
                  \wrappedCurrentCarriage:store carriageCoupledToBack;
               };
            };
         };
   }  !{
         [Wrapper<[TrainCarriage<[&E]>]>] wrappedCurrentCarriage = \[Wrapper<[TrainCarriage<[&E]>]>]:wrapperWithObject .frontCarriage;
         [->[TrainCarriage<[&E]>]] getCurrentCarriageWeAreLookingAt = wrappedCurrentCarriage:unwrap;
         [->[Boolean]] checkIfThereAreMoreCarriagesToLookInside = *-> [Boolean] {
            [TrainCarriage<[&E]>] currentCarriageWeAreLookingAt = \getCurrentCarriageWeAreLookingAt;
         } -> \currentCarriageWeAreLookingAt:backCouplingIsConnectedToACarriage;
      }


   ++ iterateThroughObjectsOnTrain *([[&E]->] cargoReceiver) {
      \:iterateThroughCarriages *([TrainCarriage<[&E]>] carriage) {
         \carriage:retriveCargoWithReceiver cargoReceiver;
      };
   }
   
   ++ deleteObjectsOnTrainWhenPrediateIsTrue *([[&E]->[Boolean]] determineIfWeShouldRemoveCargoFromTrain) {
      \:iterateThroughCarriages *([TrainCarriage<[&E]>] carriage) {
         \carriage:retriveCargoWithReceiver *([&E] cargo) {
            [Boolean] weShouldDeleteThisCargo = \determineIfWeShouldRemoveCargoFromTrain cargo;
            \weShouldDeleteThisCargo:ifOrElse *{
               \removeCargoFromTrainWithCarriage carriage;
            } *{};
            
         }; 
      };

   }  !{
         [[TrainCarriage<[&E]>]->] removeCargoFromTrainWithCarriage = *([TrainCarriage<[&E]>] carriageToRemoveCargo) {{
            \:emptyTrainIfThereIsOnlyOneCarriageLeft;
            [Boolean] trainIsCompletelyEmptyNow = \:isEmpty;
            \trainIsCompletelyEmptyNow:ifOrElse *{} pullCarriageAwayFromTrainAndReconnectTrain;

         }  !{
               [->] pullCarriageAwayFromTrainAndReconnectTrain = *{
                  [Boolean] carriageIsConnectedAtFront = \carriageToRemoveCargo:frontCouplingIsConnectedToACarriage;
                  [Boolean] carriageIsConnectedAtBack = \carriageToRemoveCargo:backCouplingIsConnectedToACarriage;
                  [Boolean] carriageIsInTheMiddleOfTheTrain = \[Boolean]:and carriageIsConnectedAtFront carriageIsConnectedAtBack;
                  \carriageIsInTheMiddleOfTheTrain:ifOrElse removeCarriageFromMiddleOfTrain *{
                     \carriageIsConnectedAtFront:ifOrElse removeCarriageFromBackOfTrain removeCarriageFromFrontOfTrain;
                  };
   
               }  !{
                     [TrainCarriage<[&E]>] theCarriageInQuestion = carriageToRemoveCargo;
                     [->] removeCarriageFromMiddleOfTrain = *{
                        \theCarriageInQuestion:retriveCarriageCoupledToFront *([TrainCarriage<[&E]>] frontCoupledCarriage) {
                           \theCarriageInQuestion:retriveCarriageCoupledToBack *([TrainCarriage<[&E]>] backCoupledCarriage) {
                              \:coupleCarriagesWithFrontAndBackCarriage frontCoupledCarriage backCoupledCarriage;
                           };
                        };
                     };

                     [->] removeCarriageFromBackOfTrain = *{ \:popFromBack *([]poppedObject){}; };
                     [->] removeCarriageFromFrontOfTrain = *{ \:popFromFront *([]poppedObject){}; };
                  };
            };}
      }


   ++ transformObjectsOnTrain *([[&E]->[&E]] cargoTransformer) {
      \:iterateThroughCarriages *([TrainCarriage<[&E]>] carriage) {
         \carriage:retriveCargoWithReceiver *([&E] cargoNotYetTransformed) {
            [&E] transformedCargo = \cargoTransformer cargoNotYetTransformed;
            \carriage:store transformedCargo;
         };
      };
   }

   ++ newTrainBySelectingObjectsWhenPrediateIsTrue *([[&E]->[Boolean]] determineIfCargoShouldBeOnNewTrain) -> [Train<[&E]>] {
      [Train<[&E]>] newTrain = \[Train<[&E]>]:newEmptyTrain;
      \:iterateThroughObjectsOnTrain *([&E] cargo) {
         [Boolean] cargoShouldBeOnNewTrain = \determineIfCargoShouldBeOnNewTrain cargo;
         \cargoShouldBeOnNewTrain:ifOrElse *{\newTrain:pushToBack cargo;} *{};
      };
   } -> newTrain



   ++ fuseTrainObjectsWithFushionRuleAndDefaultOnEmptyTrain *([[&E] [&E]->[&E]] fuseTwoObjects, [&E] defaultForEmptyTrain) -> [&E] {
      [Container<[&E]>] containerOfCurrentFusedObject = \[Container<[&E]>]:newEmptyContainer;

         \:iterateThroughObjectsOnTrain *([&E] objectOnTrain) {
            [->] insertObjectOnTrainIntoContainer = *{\containerOfCurrentFusedObject:store objectOnTrain;};

            [->] fuseObjectOnTrainWithObjectInContainer = *{
               \containerOfCurrentFusedObject:retrive *([&E] objectInContainer) {
                  \containerOfCurrentFusedObject:store (\fuseTwoObjects objectInContainer objectOnTrain);
               };
            };


         [Boolean] theContainerHasNoObject = \containerOfCurrentFusedObject:isEmpty;
         \theContainerHasNoObject:ifOrElse insertObjectOnTrainIntoContainer fuseObjectOnTrainWithObjectInContainer; 

      };

      [Wrapper<[&E]>] wrappedFusedObject = \[Wrapper<[&E]>]:wrapperWithObject defaultForEmptyTrain;
      \containerOfCurrentFusedObject:retrive *([&E] fusedObject) {\wrappedFusedObject:store fusedObject}

   } -> (\wrappedFusedObject:unwrap)
}








[Conjecture] (Boolean, Object)
   [Boolean] knownToBeTrue
   [Boolean] knownToBeFalse
{
   ~ propose *{
      .knownToBeTrue = \[Boolean]:false;
      .knownToBeFalse = \[Boolean]:false;
   }

   ~ assume *{
      .knownToBeFalse = \[Boolean]:false;
      .knownToBeTrue = \[Boolean]:true;
   }

   ~ reject *{
      .knownToBeTrue = \[Boolean]:false;
      .knownToBeFalse = \[Boolean]:true;
   }

   ~ declareAs *([Boolean] booleanForThisConjectureToBeDeclaredAs) {
      .knownToBeFalse = \[Boolean]:not booleanForThisConjectureToBeDeclaredAs;
      .knownToBeTrue = booleanForThisConjectureToBeDeclaredAs;
   }

   ++ declareTrue *{
      .knownToBeTrue = \[Boolean]:true;
      .knownToBeFalse = \[Boolean]:false;
   }
   ++ declareFalse *{
      .knownToBeFalse = \[Boolean]:true;
      .knownToBeTrue = \[Boolean]:false;
   }

   @++ isDecided *-> \[Boolean]:or .knownToBeTrue .knownToBeFalse

   ++ isTrue *-> .knownToBeTrue
   ++ isFalse *-> .knownToBeFalse

   ++ notFalse *-> \[Boolean]:not .knownToBeFalse
   ++ notTrue *-> \[Boolean]:not .knownToBeTrue
}


@@

   
Mapping<KEY:[SetObject],VALUE:[Object]> : [Object]
   :: newEmptyMapping [ -> [Mapping]]
   ++ mapKeyToValue [[&KEY],[&VALUE] -> ]
   ++ unmapKey [[&KEY] -> ]
   ++ retriveMappedValueWithKey [[&KEY],[[&VALUE] -> ] -> ]


@@




[Mapping<KEY, VALUE>] (
               BinaryTree, MappingBucket, Object, SetObject 
               ,Integer, Data, String, Container, Boolean, Conjecture, Maybe, Variable
               ) 
   [BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>] treeOfMappedKeyValuePairs
{

   ~ newEmptyMapping *{
      .treeOfMappedKeyValuePairs = \[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]
                  :binaryTreeWithFruit initialTopLevelEmptyBucket;
   }  !{
         [MappingBucket<[&KEY][&VALUE]>] initialTopLevelEmptyBucket
            = \[MappingBucket<[&KEY][&VALUE]>]
               :newEmptyBucketWithIdentifier initialArbitraryIntegerIdentifier

         !{
            [Integer] initialArbitraryIntegerIdentifier = \[Integer]:as ##0##;
         };
         
      }


   ~ empty *{
      .treeOfMappedKeyValuePairs = \[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]
                  :binaryTreeWithFruit initialTopLevelEmptyBucket;
   }  !{
         [MappingBucket<[&KEY][&VALUE]>] initialTopLevelEmptyBucket
            = \[MappingBucket<[&KEY][&VALUE]>]
               :newEmptyBucketWithIdentifier initialArbitraryIntegerIdentifier

         !{
            [Integer] initialArbitraryIntegerIdentifier = \[Integer]:as ##0##;
         };
         
      }



   ++ mapKeyToValue *([&KEY] key, [&VALUE] value) {
      [Integer] bucketIdentifierForKey = \:getBucketIdentifierForKey key;
      \:retriveBucketWithIdentifierCreatingNewBucketIfItDoesntExist bucketIdentifierForKey 
         *([MappingBucket<[&KEY][&VALUE]>] bucketToInsertKeyAndValue) {
            \bucketToInsertKeyAndValue:insertKeyValuePairIntoBucket key value;
         };
   }

   ++ unmapKey *([&KEY] key) {
      [Integer] bucketIdentifierForKey = \:getBucketIdentifierForKey key;
      \:retriveBucketWithIdentifierIfItExists bucketIdentifierForKey 
         *([MappingBucket<[&KEY][&VALUE]>] bucketMatchingIdentifier) {
            \bucketMatchingIdentifier:removeKeyFromBucket key;
         };
   }

   ++ retriveMappedValueWithKey *([&KEY] key, [[&VALUE] -> ] valueRetriver) {
      [Container<[&VALUE]>] containerWithFoundValueMatchingKey = \[Container<[&VALUE]>]:newEmptyContainer;
      [Integer] bucketIdentifierForKey = \:getBucketIdentifierForKey key;
      \:retriveBucketWithIdentifierIfItExists bucketIdentifierForKey 
         *([MappingBucket<[&KEY][&VALUE]>] bucketMatchingIdentifier) {
            \bucketMatchingIdentifier:retriveValueForKeyIfItExists key *([&VALUE] theValueThatWasFoundMatchingKey) {
               \containerWithFoundValueMatchingKey:store theValueThatWasFoundMatchingKey;
            };
         };
      \containerWithFoundValueMatchingKey:retrive valueRetriver;
   }  

   ++ maybeRetriveMappedValueWithKey *([&KEY] key) -> [Maybe<[&VALUE]>] {
      [Variable<[Maybe<[&VALUE]>]>] foundValueMatchingKey = \[Variable<[Maybe<[&VALUE]>]>]:as (\[Maybe<[&VALUE]>]:nothing);
      [Integer] bucketIdentifierForKey = \:getBucketIdentifierForKey key;
      \:retriveBucketWithIdentifierIfItExists bucketIdentifierForKey 
         *([MappingBucket<[&KEY][&VALUE]>] bucketMatchingIdentifier) {
            \bucketMatchingIdentifier:retriveValueForKeyIfItExists key *([&VALUE] theValueThatWasFoundMatchingKey) {
               \foundValueMatchingKey:set (\[Maybe<[&VALUE]>]:as theValueThatWasFoundMatchingKey);
            };
         };
   }  -> \foundValueMatchingKey:get

   ++ get *([&KEY] key) -> [Maybe<[&VALUE]>] {
      [Variable<[Maybe<[&VALUE]>]>] foundValueMatchingKey = \[Variable<[Maybe<[&VALUE]>]>]:as (\[Maybe<[&VALUE]>]:nothing);
      [Integer] bucketIdentifierForKey = \:getBucketIdentifierForKey key;
      \:retriveBucketWithIdentifierIfItExists bucketIdentifierForKey 
         *([MappingBucket<[&KEY][&VALUE]>] bucketMatchingIdentifier) {
            \bucketMatchingIdentifier:retriveValueForKeyIfItExists key *([&VALUE] theValueThatWasFoundMatchingKey) {
               \foundValueMatchingKey:set (\[Maybe<[&VALUE]>]:as theValueThatWasFoundMatchingKey);
            };
         };
   }  -> \foundValueMatchingKey:get


   - retriveBucketWithIdentifierIfItExists 
      *([Integer] bucketIdentifier, [[MappingBucket<[&KEY][&VALUE]>]->] bucketRetriver) {
         \:retriveBucketWithIdentifierAndShouldNewBucketBeCreatedIfItDoesntExist 
            bucketIdentifier bucketRetriver flagForNewBucketShouldNoBeCreated 
               !{[Boolean] flagForNewBucketShouldNoBeCreated = \[Boolean]:false;};
         
      }


   - retriveBucketWithIdentifierCreatingNewBucketIfItDoesntExist
      *([Integer] bucketIdentifier, [[MappingBucket<[&KEY][&VALUE]>]->] bucketRetriver) {
         \:retriveBucketWithIdentifierAndShouldNewBucketBeCreatedIfItDoesntExist 
            bucketIdentifier bucketRetriver flagForNewBucketShouldBeCreatedIfItDoesntExist
               !{[Boolean] flagForNewBucketShouldBeCreatedIfItDoesntExist = \[Boolean]:true;};
      }

   - retriveBucketWithIdentifierAndShouldNewBucketBeCreatedIfItDoesntExist *(
      [Integer] bucketIdentifier, [[MappingBucket<[&KEY][&VALUE]>]->] bucketRetriver, 
      [Boolean] newBucketShouldBeCreatedIfItDoesntExist) {
   
      \:retriveBucketFromTreeWithIdentifierAndShouldNewBucketBeCreatedIfItDoesntExist
         .treeOfMappedKeyValuePairs bucketIdentifier bucketRetriver newBucketShouldBeCreatedIfItDoesntExist;
   }

   - retriveBucketFromTreeWithIdentifierAndShouldNewBucketBeCreatedIfItDoesntExist *(
      [BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>] theTreeInQuestion,
      [Integer] bucketIdentifier, [[MappingBucket<[&KEY][&VALUE]>]->] bucketRetriver, 
      [Boolean] newBucketShouldBeCreatedIfItDoesntExist) {

      [MappingBucket<[&KEY][&VALUE]>] bucketAtTheRootOfThisTree = \theTreeInQuestion:lookAtTheFruit;
      {\bucketAtTheRootOfThisTree:branchOnBucketIdentifierMatchesIsLessThanOrIsGreaterThanInteger bucketIdentifier
         retriveThisBucket
         keepLookingDownLeftBranch  !{
                        [->] keepLookingDownLeftBranch = 
                           *{\continueLookingDownBranchWithBranchObserverActionAndBranchInsertionAction
                              (theTreeInQuestion:observeLeftBranch)
                              (theTreeInQuestion:connectTreeToLeftBranch)};
                     }
         keepLookingDownRightBranch !{
                        [->] keepLookingDownRightBranch = 
                           *{\continueLookingDownBranchWithBranchObserverActionAndBranchInsertionAction 
                              (theTreeInQuestion:observeRightBranch)
                              (theTreeInQuestion:connectTreeToRightBranch)};
                     }

         }!{
            [->] retriveThisBucket = *{\bucketRetriver bucketAtTheRootOfThisTree;};

            [[[[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]->]->][[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]->]->] continueLookingDownBranchWithBranchObserverActionAndBranchInsertionAction
               = *([[[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]->]->] observeTreeDownBranch,
                  [[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]->] insertTreeOnBranch) {{

               [Conjecture] treeExistsDownBranch = \[Conjecture]:propose;
               \observeTreeDownBranch *([BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>] treeFoundOnBranch) {
                  \treeExistsDownBranch:declareTrue;
                  \continueSearchTreeDownThisBranch   !{

                                    [->] continueSearchTreeDownThisBranch = *{\:retriveBucketFromTreeWithIdentifierAndShouldNewBucketBeCreatedIfItDoesntExist
                                       treeFoundOnBranch bucketIdentifier bucketRetriver newBucketShouldBeCreatedIfItDoesntExist;};
                                 };
               };
   
               [Boolean] shouldCreateNewTreeWithBucketOnThisBranch = 
                  \[Boolean]:and (\treeExistsDownBranch:notTrue) (newBucketShouldBeCreatedIfItDoesntExist);
               \shouldCreateNewTreeWithBucketOnThisBranch:ifOrElse 
                  createAndRetriveNewTreeWithBucketOnThisBranch *{}

            }  !{
                  [->] createAndRetriveNewTreeWithBucketOnThisBranch = *{
                     [MappingBucket<[&KEY][&VALUE]>] newBucket = \[MappingBucket<[&KEY][&VALUE]>]:newEmptyBucketWithIdentifier bucketIdentifier;
                     [BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>] newTreeToInsert = 
                        \[BinaryTree<[MappingBucket<[&KEY][&VALUE]>]>]:binaryTreeWithFruit newBucket;
                     \insertTreeOnBranch newTreeToInsert;
                     \bucketRetriver newBucket;
                  };
               }}
         }
   }  



   - getBucketIdentifierForKey *([&KEY] theSetObjectInQuestion) 
       -> \[Integer]:as ##0##

}




[MappingBucket<KEY, VALUE>] (
                     Object, Integer, Train, SingleMapping, Boolean,
                     SetObject, Container, Conjecture
                     ) -> (Mapping)
   [Integer] bucketIdentifier
   [Train<[SingleMapping<[&KEY][&VALUE]>]>] mappingsStoredInBucket
{
   ~ newEmptyBucketWithIdentifier *([Integer] bucketIdentifier) {
      .bucketIdentifier = bucketIdentifier;
      .mappingsStoredInBucket = \[Train<[SingleMapping<[&KEY][&VALUE]>]>]:newEmptyTrain;
   }

   ++ insertKeyValuePairIntoBucket *([String] keyInQuestion, [&VALUE] valueInQuestion) {
      [Conjecture] keyExistsInBucket = \[Conjecture]:propose;
      \.mappingsStoredInBucket:iterateThroughObjectsOnTrain determineIfKeyExistsAndSetTheValueInQuestionAccordingly
         !{
            [[SingleMapping<[&KEY][&VALUE]>]->] determineIfKeyExistsAndSetTheValueInQuestionAccordingly = *([SingleMapping<[&KEY][&VALUE]>] singleMappingInBucket) {
               [Boolean] keyOfMappingMatchesKeyInQuestion = \keyInQuestion:isEqualTo (\singleMappingInBucket:getKey);
               \keyOfMappingMatchesKeyInQuestion:ifOrElse
                  *{
                     \keyExistsInBucket:declareTrue;
                     \singleMappingInBucket:setValue valueInQuestion;
                  } *{}
            }
         };

      [Boolean] weShouldAddKeyValueAsNewPairInMappings = \keyExistsInBucket:notTrue;
      \weShouldAddKeyValueAsNewPairInMappings:ifOrElse *{
         \.mappingsStoredInBucket:pushToFront 
            (\[SingleMapping<[&KEY][&VALUE]>]:newSingleMappingWithKeyAndValue keyInQuestion valueInQuestion);
      } *{};
      
   }  

   ++ removeKeyFromBucket  *([String] keyInQuestion) {
      \.mappingsStoredInBucket:deleteObjectsOnTrainWhenPrediateIsTrue
         *([SingleMapping<[&KEY][&VALUE]>] mappingInBucket) -> (\keyInQuestion:isEqualTo \mappingInBucket:getKey);
      
   }

   ++ retriveValueForKeyIfItExists  *([String] keyInQuestion, [[&VALUE]->] valueRetriver) {
      \.mappingsStoredInBucket:iterateThroughObjectsOnTrain *([SingleMapping<[&KEY][&VALUE]>] mappingInBucket) {
         [Boolean] keyInQuestionMatchesThisMappingInBucket = \keyInQuestion:isEqualTo \mappingInBucket:getKey;
         \keyInQuestionMatchesThisMappingInBucket:ifOrElse *{\valueRetriver \mappingInBucket:getValue}
      } *{};
   }
   
   ++ branchOnBucketIdentifierMatchesIsLessThanOrIsGreaterThanInteger *(
      [Integer] bucketIdentifierToCompare, [->] matchesIdentifier, 
      [->] lessThanIdentifier, [->]greaterThenIdentifier) {

      [Boolean] isGreaterThenIdentifier = \.bucketIdentifier:isLessThan bucketIdentifierToCompare;
      [Boolean] isLessThenIdentifier = \bucketIdentifierToCompare:isLessThan .bucketIdentifier;
      [Boolean] isEqualToIdentifier = \.bucketIdentifier:isEqualTo bucketIdentifierToCompare;
      
      \isGreaterThenIdentifier:ifOrElse greaterThenIdentifier *{};
      \isLessThenIdentifier:ifOrElse lessThanIdentifier *{};
      \isEqualToIdentifier:ifOrElse matchesIdentifier *{};
   }

}

[SingleMapping<KEY, VALUE>] (Object) -> (MappingBucket)
   [&KEY] key
   [&VALUE] value
{
   ~ newSingleMappingWithKeyAndValue *([&KEY] key, [&VALUE] value) {
      .key = key;
      .value = value;
   }

   ++ getKey *->.key
   ++ getValue *->.value

   ++ setValue *([&VALUE] newValue) {.value = newValue}
}






[BinaryTree<E>] (Object, Container) -> (Mapping)
   [&E] fruitOnThisTree
   [Container<[BinaryTree<[&E]>]>] leftBranchContainer
   [Container<[BinaryTree<[&E]>]>] rightBranchContainer
{

   ~ binaryTreeWithFruit *([&E] aFruitToPutOnThisTreeNotWhatYouWouldUsuallyExpectHa) {
      .fruitOnThisTree = aFruitToPutOnThisTreeNotWhatYouWouldUsuallyExpectHa;
      .leftBranchContainer = \[Container<[BinaryTree<[&E]>]>]:newEmptyContainer;
      .rightBranchContainer = \[Container<[BinaryTree<[&E]>]>]:newEmptyContainer;
   }

   ++ connectTreeToRightBranch *([BinaryTree<[&E]>] treeToConnect) {
      \.rightBranchContainer:store treeToConnect;
   }

   ++ connectTreeToLeftBranch *([BinaryTree<[&E]>] treeToConnect) {
      \.leftBranchContainer:store treeToConnect;
   }

   ++ disconnectRightBranch *{.rightBranchContainer = \[Container<[BinaryTree<[&E]>]>]:newEmptyContainer;}
   ++ disconnectLeftBranch *{.leftBranchContainer = \[Container<[BinaryTree<[&E]>]>]:newEmptyContainer;}

   ++ lookAtTheFruit *->.fruitOnThisTree

   ++ observeLeftBranch
      *([[BinaryTree<[&E]>]->] branchObserver) {
      \.leftBranchContainer:retrive branchObserver;
   }

   ++ observeRightBranch
      *([[BinaryTree<[&E]>]->] branchObserver) {
      \.rightBranchContainer:retrive branchObserver;
   }
}

[Container<E>] (Object, Boolean)
   [[[&E]->]->] storedObjectProvider
   [Boolean] objectIsStored
{
   ~ newEmptyContainer * {
      .objectIsStored = \[Boolean]:false;
      .storedObjectProvider = *([[&E]->]_){};
   }

   ++ store *([&E] objectToStoreInContainer) {
      .objectIsStored = \[Boolean]:true;
      .storedObjectProvider = *([[&E]->] provideObject){\provideObject objectToStoreInContainer};
   }

   ++ retrive *([[&E]->] objectTaker) {
      \.storedObjectProvider objectTaker
   }

   ++ transformStoredObject *([[&E]->[&E]] transformation) {
      \:retrive *([&E] theObjectInQuestion) {
         [&E] transformedObject = \transformation theObjectInQuestion;
         \:store transformedObject;
      };
   }

   ++ isEmpty * -> [Boolean] {} -> (\[Boolean]:not .objectIsStored)

}


@@
[] (Daina, Configuration) {
   ^ *{
      \[Daina]:run \[Configuration]:init;
   }
}@@


[] (StandardIO, File, String, Byte, Data, List, Integer, Natural, Sequence, Boolean, Loops, Variable, Mapping, Maybe, SourcePosition, Error) {
   *{

      \[Daina]:run \[Configuration]:init;

      @[Maybe<[String]>] y1 = \[Maybe<[String]>]:nothing;
      @[Maybe<[String]>] y2 = \[Maybe<[String]>]:as \[String]:as ##Hello Worl!##;
      
      @\[SystemIO]:log \y1:isOrElse (*([String] s)->s) (*->nothingStr);
      @\[SystemIO]:log \y2:isOrElse (*([String] s)->s) (*->nothingStr);


      @@[Sequence<[Number]>] 5Times = [:[Sequence<[Number]>]] {
         |++ length *->\[Natural]:as ##5##
         |++ atIndex *(n)->\[Maybe<[?]>]:as n
      };
      \[Loops]:iterate 5Times *{
         \[SystemIO]:stdout \(\[String]:as ##Hello World!!\n##):ascii;
         \[SystemIO]:stdout \(\[String]:asASCII \[SystemIO]:stdin):ascii;
      };@@
      @@@@@@@@
      @@[SourcePosition] asdf = \[SourcePosition]:initialPositionIn (\[String]:as ##sadf/asdf/filenametest.h##) (\[String]:as ##This is a line....##);
      [SourcePosition] asdf2 = \asdf:startOfNextLine (\[String]:as ##This is a line2....##);
      [SourcePosition] asdf3 = \asdf2:startOfNextLine (\[String]:as ##This is a line3....##);
      [SourcePosition] asdf4 = \asdf3:nextColumn;


      \[StandardIO]:stdout \(\(\[Error]:expectingSecondHashForDataSegmentAnchor asdf4):description):ascii;
      \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;

      \[Loops]:iterate ([:[Sequence<[Natural]>]] {
         |++ length *->\[Natural]:as ##10##
         |++ atIndex *([Natural] n)->\[Maybe<[?]>]:as \n:adding \[Natural]:as ##300000238974289438900234##
      }) *([Natural] index, [Natural]value){
         \[StandardIO]:stdout \(\[String]:stringFormatOf value):ascii;
         \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;
      };
      @@
      
      @\(\[File]:atPath \[String]:as ##TestFiles/dlang_compiler_bootstrap_test.dai##):readContents (\[Natural]:as ##1000##) [StandardIO]:stdout;
      @[File] outputFile = (\[File]:atPath \[String]:as ##TestFiles/testwrite.txt##);
      @\outputFile:clearContents;
@@
      [List<[Byte]>] bytes = \[List<[Byte]>]:empty;
      \bytes:append \[Byte]:0x01;
      \bytes:append \[Byte]:0x21;
      \bytes:append \[Byte]:0xFF;
      [Data] dat = \[Data]:copy bytes;
      @\[StandardIO]:stdout \(\[String]:stringFormatOf (\bytes:length)):ascii;
      \outputFile:appendContents dat;
      @\outputFile:appendContents \(\[String]:as ##1000##):ascii;
      \(\outputFile:exists):ifOrElse *{
         \[StandardIO]:stdout \(\[String]:as ##Exists\n##):ascii;
      } *{
         \[StandardIO]:stdout \(\[String]:as ##NotExists\n##):ascii;
      };

      \outputFile:close;@@

   } @!{[String] nothingStr = \[String]:as ##<NOTHING>##}
}

[StandardIO] (String) {
      <<dlang ##
            import std.stdio;
            import std.bigint;
         ##

   :: stdout *([Data] data) {
      [] _ = <<dlang ##
            write(cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it));
         ##;
   }

   :: stdin *-> [Data] {
      [Data] readedData = \[Data]:empty;
      [] _ = << dlang ##
         string rawLine = readln();
         if (rawLine == null) {
            rawLine = "";
         }
         ubyte[] line = cast(ubyte[])(rawLine);
         (cast(CLASSIMPL_Data)LOBJECT_readedData).value = new WRAP!(ubyte[])(line);
      ##;
@chunks(stdin, 4096)
@
@foreach (ubyte[] buffer; chunks(stdin, 4096))
 @   {
  @      ... use buffer ...
  @  }
@
   } -> readedData


}

[File] (String, Natural, Data, Boolean) 
{
   <<dlang ##
         import std.stdio;
         import std.file;
         import std.bigint;
         string fileName = null;
         File file;
      ##

   ~ atPath *([String] filePath) {
      [Data] asciiFilePath = \filePath:ascii;
      [] _ = <<dlang ##
         this.fileName = cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_asciiFilePath).IMETHOD_internalData(null, []))).it);
      ##;
   }

   ++ exists *->[Boolean] {
      [Boolean] exists = <<dlang ##
         bool fileExists = this.fileName.exists && this.fileName.isFile;
         OBJECT LOBJECT_exists = fileExists ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> exists

   ++ clearContents *{
      [] _ = <<dlang ##
         if (this.file.isOpen) {
            this.file.close();
         }
         this.file.open(this.fileName, "wb");
         if (this.file.isOpen) {
            this.file.write("");
         }
      ##;
   }

   ++ appendContents *([Data] toAppend) {
      [] _ = <<dlang ##
         if (!this.file.isOpen) {
            this.file.open(this.fileName, "ab");
         }
         if (this.file.isOpen) {
            this.file.rawWrite((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_toAppend).IMETHOD_internalData(null, []))).it);
         }
      ##;
   }

   @@++ readContents *([Natural] chunkSize, [[Data]->] readChunk) {
      [] _ = <<dlang ##
         BigInt chunkSize = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_chunkSize).IMETHOD_internalInteger(null, []))).it;
         if (this.file.isOpen) {
            this.file.close();
         }
         this.file.open(this.fileName, "rb");
         if (this.file.isOpen) {
            foreach (ubyte[] buffer; this.file.byChunk(chunkSize.toLong())) {
      ##;
      [Data] chunk = << dlang ##
               CLASSIMPL_Data LOBJECT_chunk = new CLASSIMPL_Data();
               LOBJECT_chunk.value = new WRAP!(ubyte[])(buffer);
      ##;
      \readChunk chunk;
      [] _ = <<dlang ##
         
            }
            this.file.close();
         }
      ##;
   }@@

   ++ readContents *([Natural] chunkSize) -> [Data] {
      [Variable<[Data]>] theChunk = \[Variable<[Data]>]:as \[Data]:empty;
      [] _ = <<dlang ##
         BigInt chunkSize = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_chunkSize).IMETHOD_internalInteger(null, []))).it;
         if (this.file.isOpen) {
            this.file.close();
         }
         this.file.open(this.fileName, "rb");
         if (this.file.isOpen) {
            foreach (ubyte[] buffer; this.file.byChunk(chunkSize.toLong())) {
      ##;
      [Data] chunk = << dlang ##
               CLASSIMPL_Data LOBJECT_chunk = new CLASSIMPL_Data();
               LOBJECT_chunk.value = new WRAP!(ubyte[])(buffer);
      ##;
      \theChunk:set chunk;
      [] _ = <<dlang ##
         
            }
            this.file.close();
         }
      ##;
   } -> \theChunk:get

   ++ close *{
      [] _ = <<dlang ##
         this.file.close();
      ##;
   }
}


[Data :[Sequence<[Byte]>]] (Byte, Sequence, Loops, Natural)
{
   <<dlang ##
         import std.bigint;
         import std.format;
         WRAP!(ubyte[]) value;
      ##

   ~ empty *{
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])([]);
      ##;
   }

   ~ copy *([Sequence<[Byte]>] bytes) {
      [] _ = <<dlang ##
         ubyte[] copiedData;
      ##;
      \[Loops]:iterate bytes *([] _, [Byte] byte) {
         [] _ = <<dlang ##
            ubyte thisByte = (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_byte).IMETHOD_internalByte(null, []))).it;
            copiedData ~= thisByte;
         ##;
      };
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])(copiedData);
      ##;
   }

   ~ concatenate *([Sequence<[Data]>] datas) {
      [] _ = <<dlang ##
         ubyte[] concatedData;
      ##;
      \[Loops]:iterate datas *([]_, [Data] data) {
         [] _ = <<dlang ##
            ubyte[] thisData = (cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it;
            concatedData ~= thisData;
         ##;
      };
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])(concatedData);
      ##;
   }

   |++ length *-> [Natural] {
      [Natural] length = << dlang ##
         OBJECT LOBJECT_length = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", this.value.it.length))]);
      ##;
   } -> length

   |++ atIndex *([Natural] index) -> [Maybe<[Byte]>] {
      [Maybe<[Byte]>] byteAtIndex = << dlang ##
         OBJECT LOBJECT_byteAtIndex = null;
         BigInt index = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_index).IMETHOD_internalInteger(null, []))).it;
         if (this.value.it.length > index) {
            CLASSIMPL_Byte rawByte = new CLASSIMPL_Byte();
            rawByte.value = new WRAP!(ubyte)(this.value.it[index.toLong()]);
            LOBJECT_byteAtIndex = CLASSIMPL_Maybe.TMETHOD_as(caller, cast(OBJECT[])[rawByte]);
         } else {
            LOBJECT_byteAtIndex = CLASSIMPL_Maybe.TMETHOD_nothing(caller, cast(OBJECT[])[]);
         }
      ##;
   } -> byteAtIndex


   - internalData *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }
}

[Byte]
{
   <<dlang ##
         WRAP!(ubyte) value;
      ##

   ~ 0x00 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x00); ##; }
   ~ 0x01 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x01); ##; }
   ~ 0x02 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x02); ##; }
   ~ 0x03 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x03); ##; }
   ~ 0x04 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x04); ##; }
   ~ 0x05 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x05); ##; }
   ~ 0x06 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x06); ##; }
   ~ 0x07 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x07); ##; }
   ~ 0x08 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x08); ##; }
   ~ 0x09 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x09); ##; }
   ~ 0x0A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0A); ##; }
   ~ 0x0B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0B); ##; }
   ~ 0x0C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0C); ##; }
   ~ 0x0D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0D); ##; }
   ~ 0x0E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0E); ##; }
   ~ 0x0F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0F); ##; }
   ~ 0x10 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x10); ##; }
   ~ 0x11 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x11); ##; }
   ~ 0x12 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x12); ##; }
   ~ 0x13 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x13); ##; }
   ~ 0x14 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x14); ##; }
   ~ 0x15 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x15); ##; }
   ~ 0x16 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x16); ##; }
   ~ 0x17 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x17); ##; }
   ~ 0x18 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x18); ##; }
   ~ 0x19 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x19); ##; }
   ~ 0x1A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1A); ##; }
   ~ 0x1B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1B); ##; }
   ~ 0x1C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1C); ##; }
   ~ 0x1D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1D); ##; }
   ~ 0x1E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1E); ##; }
   ~ 0x1F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1F); ##; }
   ~ 0x20 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x20); ##; }
   ~ 0x21 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x21); ##; }
   ~ 0x22 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x22); ##; }
   ~ 0x23 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x23); ##; }
   ~ 0x24 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x24); ##; }
   ~ 0x25 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x25); ##; }
   ~ 0x26 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x26); ##; }
   ~ 0x27 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x27); ##; }
   ~ 0x28 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x28); ##; }
   ~ 0x29 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x29); ##; }
   ~ 0x2A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2A); ##; }
   ~ 0x2B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2B); ##; }
   ~ 0x2C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2C); ##; }
   ~ 0x2D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2D); ##; }
   ~ 0x2E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2E); ##; }
   ~ 0x2F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2F); ##; }
   ~ 0x30 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x30); ##; }
   ~ 0x31 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x31); ##; }
   ~ 0x32 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x32); ##; }
   ~ 0x33 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x33); ##; }
   ~ 0x34 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x34); ##; }
   ~ 0x35 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x35); ##; }
   ~ 0x36 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x36); ##; }
   ~ 0x37 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x37); ##; }
   ~ 0x38 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x38); ##; }
   ~ 0x39 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x39); ##; }
   ~ 0x3A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3A); ##; }
   ~ 0x3B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3B); ##; }
   ~ 0x3C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3C); ##; }
   ~ 0x3D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3D); ##; }
   ~ 0x3E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3E); ##; }
   ~ 0x3F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3F); ##; }
   ~ 0x40 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x40); ##; }
   ~ 0x41 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x41); ##; }
   ~ 0x42 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x42); ##; }
   ~ 0x43 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x43); ##; }
   ~ 0x44 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x44); ##; }
   ~ 0x45 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x45); ##; }
   ~ 0x46 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x46); ##; }
   ~ 0x47 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x47); ##; }
   ~ 0x48 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x48); ##; }
   ~ 0x49 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x49); ##; }
   ~ 0x4A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4A); ##; }
   ~ 0x4B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4B); ##; }
   ~ 0x4C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4C); ##; }
   ~ 0x4D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4D); ##; }
   ~ 0x4E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4E); ##; }
   ~ 0x4F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4F); ##; }
   ~ 0x50 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x50); ##; }
   ~ 0x51 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x51); ##; }
   ~ 0x52 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x52); ##; }
   ~ 0x53 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x53); ##; }
   ~ 0x54 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x54); ##; }
   ~ 0x55 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x55); ##; }
   ~ 0x56 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x56); ##; }
   ~ 0x57 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x57); ##; }
   ~ 0x58 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x58); ##; }
   ~ 0x59 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x59); ##; }
   ~ 0x5A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5A); ##; }
   ~ 0x5B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5B); ##; }
   ~ 0x5C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5C); ##; }
   ~ 0x5D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5D); ##; }
   ~ 0x5E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5E); ##; }
   ~ 0x5F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5F); ##; }
   ~ 0x60 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x60); ##; }
   ~ 0x61 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x61); ##; }
   ~ 0x62 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x62); ##; }
   ~ 0x63 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x63); ##; }
   ~ 0x64 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x64); ##; }
   ~ 0x65 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x65); ##; }
   ~ 0x66 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x66); ##; }
   ~ 0x67 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x67); ##; }
   ~ 0x68 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x68); ##; }
   ~ 0x69 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x69); ##; }
   ~ 0x6A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6A); ##; }
   ~ 0x6B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6B); ##; }
   ~ 0x6C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6C); ##; }
   ~ 0x6D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6D); ##; }
   ~ 0x6E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6E); ##; }
   ~ 0x6F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6F); ##; }
   ~ 0x70 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x70); ##; }
   ~ 0x71 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x71); ##; }
   ~ 0x72 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x72); ##; }
   ~ 0x73 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x73); ##; }
   ~ 0x74 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x74); ##; }
   ~ 0x75 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x75); ##; }
   ~ 0x76 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x76); ##; }
   ~ 0x77 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x77); ##; }
   ~ 0x78 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x78); ##; }
   ~ 0x79 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x79); ##; }
   ~ 0x7A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7A); ##; }
   ~ 0x7B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7B); ##; }
   ~ 0x7C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7C); ##; }
   ~ 0x7D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7D); ##; }
   ~ 0x7E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7E); ##; }
   ~ 0x7F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7F); ##; }
   ~ 0x80 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x80); ##; }
   ~ 0x81 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x81); ##; }
   ~ 0x82 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x82); ##; }
   ~ 0x83 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x83); ##; }
   ~ 0x84 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x84); ##; }
   ~ 0x85 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x85); ##; }
   ~ 0x86 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x86); ##; }
   ~ 0x87 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x87); ##; }
   ~ 0x88 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x88); ##; }
   ~ 0x89 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x89); ##; }
   ~ 0x8A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8A); ##; }
   ~ 0x8B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8B); ##; }
   ~ 0x8C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8C); ##; }
   ~ 0x8D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8D); ##; }
   ~ 0x8E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8E); ##; }
   ~ 0x8F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8F); ##; }
   ~ 0x90 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x90); ##; }
   ~ 0x91 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x91); ##; }
   ~ 0x92 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x92); ##; }
   ~ 0x93 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x93); ##; }
   ~ 0x94 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x94); ##; }
   ~ 0x95 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x95); ##; }
   ~ 0x96 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x96); ##; }
   ~ 0x97 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x97); ##; }
   ~ 0x98 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x98); ##; }
   ~ 0x99 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x99); ##; }
   ~ 0x9A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9A); ##; }
   ~ 0x9B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9B); ##; }
   ~ 0x9C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9C); ##; }
   ~ 0x9D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9D); ##; }
   ~ 0x9E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9E); ##; }
   ~ 0x9F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9F); ##; }
   ~ 0xA0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA0); ##; }
   ~ 0xA1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA1); ##; }
   ~ 0xA2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA2); ##; }
   ~ 0xA3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA3); ##; }
   ~ 0xA4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA4); ##; }
   ~ 0xA5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA5); ##; }
   ~ 0xA6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA6); ##; }
   ~ 0xA7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA7); ##; }
   ~ 0xA8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA8); ##; }
   ~ 0xA9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA9); ##; }
   ~ 0xAA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAA); ##; }
   ~ 0xAB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAB); ##; }
   ~ 0xAC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAC); ##; }
   ~ 0xAD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAD); ##; }
   ~ 0xAE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAE); ##; }
   ~ 0xAF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAF); ##; }
   ~ 0xB0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB0); ##; }
   ~ 0xB1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB1); ##; }
   ~ 0xB2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB2); ##; }
   ~ 0xB3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB3); ##; }
   ~ 0xB4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB4); ##; }
   ~ 0xB5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB5); ##; }
   ~ 0xB6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB6); ##; }
   ~ 0xB7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB7); ##; }
   ~ 0xB8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB8); ##; }
   ~ 0xB9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB9); ##; }
   ~ 0xBA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBA); ##; }
   ~ 0xBB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBB); ##; }
   ~ 0xBC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBC); ##; }
   ~ 0xBD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBD); ##; }
   ~ 0xBE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBE); ##; }
   ~ 0xBF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBF); ##; }
   ~ 0xC0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC0); ##; }
   ~ 0xC1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC1); ##; }
   ~ 0xC2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC2); ##; }
   ~ 0xC3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC3); ##; }
   ~ 0xC4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC4); ##; }
   ~ 0xC5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC5); ##; }
   ~ 0xC6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC6); ##; }
   ~ 0xC7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC7); ##; }
   ~ 0xC8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC8); ##; }
   ~ 0xC9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC9); ##; }
   ~ 0xCA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCA); ##; }
   ~ 0xCB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCB); ##; }
   ~ 0xCC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCC); ##; }
   ~ 0xCD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCD); ##; }
   ~ 0xCE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCE); ##; }
   ~ 0xCF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCF); ##; }
   ~ 0xD0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD0); ##; }
   ~ 0xD1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD1); ##; }
   ~ 0xD2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD2); ##; }
   ~ 0xD3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD3); ##; }
   ~ 0xD4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD4); ##; }
   ~ 0xD5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD5); ##; }
   ~ 0xD6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD6); ##; }
   ~ 0xD7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD7); ##; }
   ~ 0xD8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD8); ##; }
   ~ 0xD9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD9); ##; }
   ~ 0xDA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDA); ##; }
   ~ 0xDB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDB); ##; }
   ~ 0xDC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDC); ##; }
   ~ 0xDD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDD); ##; }
   ~ 0xDE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDE); ##; }
   ~ 0xDF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDF); ##; }
   ~ 0xE0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE0); ##; }
   ~ 0xE1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE1); ##; }
   ~ 0xE2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE2); ##; }
   ~ 0xE3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE3); ##; }
   ~ 0xE4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE4); ##; }
   ~ 0xE5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE5); ##; }
   ~ 0xE6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE6); ##; }
   ~ 0xE7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE7); ##; }
   ~ 0xE8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE8); ##; }
   ~ 0xE9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE9); ##; }
   ~ 0xEA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEA); ##; }
   ~ 0xEB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEB); ##; }
   ~ 0xEC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEC); ##; }
   ~ 0xED *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xED); ##; }
   ~ 0xEE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEE); ##; }
   ~ 0xEF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEF); ##; }
   ~ 0xF0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF0); ##; }
   ~ 0xF1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF1); ##; }
   ~ 0xF2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF2); ##; }
   ~ 0xF3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF3); ##; }
   ~ 0xF4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF4); ##; }
   ~ 0xF5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF5); ##; }
   ~ 0xF6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF6); ##; }
   ~ 0xF7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF7); ##; }
   ~ 0xF8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF8); ##; }
   ~ 0xF9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF9); ##; }
   ~ 0xFA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFA); ##; }
   ~ 0xFB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFB); ##; }
   ~ 0xFC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFC); ##; }
   ~ 0xFD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFD); ##; }
   ~ 0xFE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFE); ##; }
   ~ 0xFF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFF); ##; }

   - internalByte *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }

   ++ isEqualTo *([Byte] otherByte)-> [Boolean] {
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = this.value.it == (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_otherByte).IMETHOD_internalByte(null, []))).it;
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ inclusiveBetween *([Byte] from, [Byte] to)-> [Boolean] {
      [Boolean] isInclusiveBetween = << dlang ## 
         bool isInclusiveBetween = (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_from).IMETHOD_internalByte(null, []))).it <= this.value.it && this.value.it <= (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_to).IMETHOD_internalByte(null, []))).it;
         OBJECT LOBJECT_isInclusiveBetween = isInclusiveBetween ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isInclusiveBetween

}

[String] (Data, Sequence, List) 
   [Data] ascii
{
   <<dlang ##
         import std.bigint;
         import std.format;
      ##

   ~ as *([%STRING] literal) {
      .ascii = \[Data]:empty;
      [] _ = <<dlang ##
         ubyte[] literalBytes = cast(ubyte[])((cast(WRAP!(string))LOBJECT_literal).it);
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(literalBytes);
      ##;
   }

   ~ asASCII *([Data] ascii) {
      .ascii = ascii
   }

   ~ concatenate *([Sequence<[String]>] strings) {
      [Sequence<[Data]>] asciis = [:[Sequence<[Data]>]] { 
         |++ length *->\strings:length
         |++ atIndex *([Natural] i)->\(\strings:atIndex i):isOrElse (*([String] s)->\[Maybe<[?]>]:as \s:ascii) [Maybe<[?]>]:nothing
      };
      \:~asASCII \[Data]:concatenate asciis
   }

   ~ stringFormatOf *([Integer] integer) {
      .ascii = \[Data]:empty;
      [] _ = << dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         ubyte[] bytes = cast(ubyte[])(format("%d", integer));
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(bytes);
      ##;
   }

   ++ isEqualTo *([String] otherString)-> [Boolean] {
      [Data] thisAscii = \:ascii;
      [Data] otherAscii = \otherString:ascii;
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_thisAscii).IMETHOD_internalData(null, []))).it) == cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_otherAscii).IMETHOD_internalData(null, []))).it);
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ appending *([String] other) -> [String] {
      [String] this = ^;
      [Sequence<[String]>] both = [:[Sequence<[String]>]] { 
         |++ length *->\[Natural]:as ##2##
         |++ atIndex *([Natural] index)->[Maybe<[String]>]{
            [Boolean] indexIs0 = \index:isEqualTo (\[Natural]:as ##0##);
         }->\[Maybe<[String]>]:as \indexIs0:ifOrElse (*->this) (*->other)
      }
   } -> \[String]:concatenate both

   ++ ascii *->.ascii
}


[Loops] (Sequence, Natural, Variable, Boolean)
{
   :: iterate *([Sequence<['E]>] sequence, [[Natural]['E]->] getNext) {
      [Variable<[Natural]>] currentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      \[?:]:while ((*->((\index:isLessThan \sequence:length)!{[Natural] index = \currentIndex:get}))) *{
         {
            \element:isOrElse *(e){
               \getNext index e;
            } *{};
            @\getNext index element;
            \currentIndex:set \index:adding (\[Natural]:as ##1##);
         }!{
            [Natural] index = \currentIndex:get;
            [Maybe<['E]>] element = \sequence:atIndex index;
         }
      }
   }

   :: while *([->[Boolean]] condition, [->] action) {
      \[?:]:until *([->] stop) {
         \(\condition):ifOrElse action stop
      }
   }

   :: until *([[['E]->]->['E]] actionWithStop) -> ['E] { @add
      ['E] result = <<dlang ##
         bool continueActions = true;
         OBJECT LOBJECT_result = null;
         while (continueActions) {
      ##;
      \actionWithStop *(["E] resultFromAction) {
         [] _ = <<dlang ##
            continueActions = false;
            LOBJECT_result = LOBJECT_resultFromAction;
         ##
      };
      [] _ = <<dlang
      ##
         }
      ##;
   } -> result
}

[Variable<E>]
   [&E] variableObject
{
   ~ as *([&E] initialInstantiation) {
      .variableObject = initialInstantiation;
   }

   ++ get *->.variableObject

   ++ set *([&E] newInstantiation) {
      [] _ = << dlang ##
         IOBJECT_variableObject = LOBJECT_newInstantiation;
      ##;
   }
}


[Sequence<E>] (Maybe, Natural)
{
   ++ length [->[Natural]]
   ++ atIndex [[Natural]->[Maybe<[&E]>]]
}


[Natural :[Integer]] (Integer)
{
   <<dlang ##
         import std.format;
         import std.conv;
         import std.bigint;
      ##
   

   ~ as *([%NATURAL] literal) {
      [Integer] integerRepresentation = <<dlang ##
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[LOBJECT_literal]);
      ##;
      \$~>integerRepresentation;
   }

   ~ clampTo0 *([Integer] integer) {
      [Integer] integerRepresentation = <<dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         if (integer < BigInt("0")) {
            integer = BigInt("0");
         }
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", integer))]);
      ##;
      \$~>integerRepresentation;
   }

   ~ magnitudeOf *([Integer] integer) {
      [Integer] integerRepresentation = <<dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         if (integer < BigInt("0")) {
            integer = integer*BigInt("-1");
         }
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", integer))]);
      ##;
      \$~>integerRepresentation;
   }

   ++ adding *([Natural] toAdd) -> [Natural] {
      [Natural] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toAddBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toAdd).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt + toAddBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
}


[Maybe<E>] 
{
   ~ nothing *{
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \else
   }

   ~ as *([&E] it) {
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \is it
   }

   ++ isOrElse [[[&E]->['O]][->['O]]->['O]]
}

[Boolean] 
{
   ~ false *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \else
   }

   ~ true *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \if
   }

   ++ ifOrElse [[->['O]][->['O]]->['O]]

   ~ or *([Boolean] b1, [Boolean] b2) {
      :ifOrElse = *([->["O]] if, [->["O]] else) 
         -> \b1:ifOrElse if *->\b2:ifOrElse if else
   }

   ~ and *([Boolean] b1, [Boolean] b2) {
      :ifOrElse = *([->["O]] if, [->["O]] else) 
         -> \b1:ifOrElse (*->\b2:ifOrElse if else) else
   }

   ~ not *([Boolean] b1) {
      :ifOrElse = *([->["O]] if, [->["O]] else) 
         -> \b1:ifOrElse else if
   }
}


[Integer] (Boolean)
{
   <<dlang ##
            import std.conv;
            import std.bigint;
            import std.format;
            WRAP!(BigInt) value;
         ##

   ~ as *([%INTEGER] literal) {
      [] _ = <<dlang ##
         this.value = new WRAP!(BigInt)(BigInt((cast(WRAP!(string))LOBJECT_literal).it));
      ##;
   }

   ++ isLessThan *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isLessThan = << dlang ## 
         bool isLessThan = this.value.it < (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isLessThan = isLessThan ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isLessThan

   ++ isEqualTo *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = this.value.it == (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ subtracting *([Integer] toSubtract) -> [Integer] {
      [Integer] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toSubtractBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toSubtract).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt - toSubtractBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result

   ++ adding *([Integer] toAdd) -> [Natural] {
      [Natural] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toAddBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toAdd).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt + toAddBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
   

   - internalInteger *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }

}


[ListNode<E>] () -> (List)
{
   ~ withValue *([&E] value) {
      :value = *-> value;
      :next = (*-> next) ! [?] next = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      :previous = (*-> previous) ! [?] previous = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
   }

   ++ value [->[&E]]
   ++ next [->[Variable<[Maybe<[ListNode<[&E]>]>]>]]
   ++ previous [->[Variable<[Maybe<[ListNode<[&E]>]>]>]]
}

[List<E> : [Sequence<[&E]>]] (ListNode, Boolean, Maybe, Variable, Sequence, Natural, Loops)
   [Variable<[Maybe<[ListNode<[&E]>]>]>] first
   [Variable<[Maybe<[ListNode<[&E]>]>]>] last
   [Variable<[Natural]>] length
{
   ~ empty *{
      .first = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      .last = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      .length = \[Variable<[?]>]:as \[Natural]:as ##0##;
   }

   ++ iterate *([[&E]->] getE) {
      \[Loops]:iterate ^ *([] _, [&E] e) {
         \getE e; 
      }
   }

   @ copy [Sequence<[&E]>]

   ++ length *->\.length:get

   ++ atIndex *([Natural] index) -> [Maybe<[&E]>] {
      [Variable<[Natural]>] varCurrentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      [Variable<[Maybe<[ListNode<[&E]>]>]>] varCurrentNode = \[Variable<[?]>]:as \.first:get;
      [Maybe<[&E]>] atIndex = \[Loops]:until *([[Maybe<[&E]>]->] choose) {
         [Natural] currentIndex = \varCurrentIndex:get;
         [Maybe<[ListNode<[&E]>]>] currentNode = \varCurrentNode:get;
         \varCurrentNode:set \currentNode:isOrElse (*([ListNode<[&E]>] n)-> [Maybe<[ListNode<[&E]>]>] {
               [Boolean] sameIndex = (\currentIndex:isEqualTo index);
               \sameIndex:ifOrElse *{
                  \choose \[Maybe<[&E]>]:as \n:value;
               } *{};
            } ->\(\n:next):get) 
         (*->[Maybe<[ListNode<[&E]>]>]{\choose \[Maybe<[&E]>]:nothing}->\[Maybe<[ListNode<[&E]>]>]:nothing);
         \varCurrentIndex:set \currentIndex:adding \[Natural]:as ##1##;
      };
   } -> atIndex

   ++ removeFirst *-> [Maybe<[&E]>] {
      [Maybe<[ListNode<[&E]>]>] first = \.first:get;
   } -> \first:isOrElse (*([ListNode<[&E]>] node) -> [Maybe<[&E]>] {
         \.first:set \node:next;
         [Natural] length = \.length:get;
         \.length:set \[Natural]:clampTo0 \length:subtracting \[Natural]:as ##1##;
      } -> \[Maybe<[?]>]:as \node:value) (*->\[Maybe<[&E]>]:nothing)
   
   ++ prepend *([&E] value) {
      [Natural] length = \.length:get;
      \.length:set \length:adding \[Natural]:as ##1##;
      [ListNode<[&E]>] newNode = \[ListNode<[&E]>]:withValue value;
      [Maybe<[ListNode<[&E]>]>] first = \.first:get;
      \first:isOrElse *([ListNode<[&E]>] firstNode) {
         [Variable<[Maybe<[ListNode<[&E]>]>]>] firstNodePrevious = \firstNode:previous;
         [Variable<[Maybe<[ListNode<[&E]>]>]>] newNodeNext = \newNode:next;
         \newNodeNext:set first;
         \firstNodePrevious:set \[Maybe<[?]>]:as newNode;
      } *{
         \.last:set \[Maybe<[?]>]:as newNode;
      };
      \.first:set \[Maybe<[?]>]:as newNode;
   }

   ++ removeLast *-> [Maybe<[&E]>] {
      [Maybe<[ListNode<[&E]>]>] last = \.last:get;
   } -> \last:isOrElse (*([ListNode<[&E]>] node) -> [Maybe<[&E]>] {
         \.last:set \node:previous;
         [Natural] length = \.length:get;
         \.length:set \[Natural]:clampTo0 \length:subtracting \[Natural]:as ##1##;
      } -> \[Maybe<[?]>]:as \node:value) (*->\[Maybe<[&E]>]:nothing)

   ++ append *([&E] value) {
      [Natural] length = \.length:get;
      \.length:set \length:adding \[Natural]:as ##1##;
      [ListNode<[&E]>] newNode = \[ListNode<[&E]>]:withValue value;
      [Maybe<[ListNode<[&E]>]>] last = \.last:get;
      \last:isOrElse *([ListNode<[&E]>] lastNode) {
         [Variable<[Maybe<[ListNode<[&E]>]>]>] newNodePrevious = \newNode:previous;
         [Variable<[Maybe<[ListNode<[&E]>]>]>] lastNodeNext = \lastNode:next;
         \newNodePrevious:set last;
         \lastNodeNext:set \[Maybe<[?]>]:as newNode;
      } *{
         \.first:set \[Maybe<[?]>]:as newNode;
      };
      \.last:set \[Maybe<[?]>]:as newNode;
   }
}





@ DAINA COMPILER -------

[SourcePosition] (
         Natural,
         String,
         Variable,
         Object,
         Loops
      )
   [String] sourceName
   [Natural] line
   [Natural] column
   [String] lineContent
{
   ~ initialPositionIn *([String] sourceName, [String] lineContent) {
      \:~lineAndColumnIn (\[Natural]:as ##0##) (\[Natural]:as ##0##) sourceName lineContent;
   }

   ~ -+- lineAndColumnIn *([Natural] line, [Natural] column, [String] sourceName, [String] lineContent) {
      .sourceName = sourceName;
      .column = column;
      .line = line;
      .lineContent = lineContent;
   }

   ++ description *-> [String] {
      [String] colon = \[String]:as ##:##;
      [String] pos = \[String]:as ## pos ##;
      [String] line = \[String]:stringFormatOf (\.line:adding (\[Natural]:as ##1##));
      [String] column = \[String]:stringFormatOf (\.column:adding (\[Natural]:as ##1##));
      [String] tabulation = \[String]:as ##\n    ##;
      [Variable<[String]>] linePositionArrow = \[Variable<[String]>]:as (\[String]:as ####);
      \[Loops]:iterate ([:[Sequence<[Natural]>]] { 
         |++ length *->.column
         |++ atIndex *(i)->\[Maybe<[?]>]:as i
      }) *{
         [String] curr = \linePositionArrow:get;
         \linePositionArrow:set (\curr:appending (\[String]:as ## ##));
      };
      [String] curr = \linePositionArrow:get;
      \linePositionArrow:set (\curr:appending (\[String]:as ##^##));
   } -> (\.sourceName:appending (\colon:appending (\line:appending (\pos:appending (\column:appending (\tabulation:appending (\.lineContent:appending (\tabulation:appending (\linePositionArrow:get)))))))))

   ++ nextColumn *-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Natural]:as ##1##)) (.sourceName) (.lineContent)

   ++ startOfNextLine *([String] lineContent)-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Natural]:as ##1##)) (\[Natural]:as ##0##) (.sourceName) lineContent
}



[Error] (Object, String, SourcePosition, List, Variable)
   [String] errorString
{
   ++ description *-> [String] {
      [String] errorPrefix = \[String]:as ##ERROR; ##;
   } -> (\errorPrefix:appending .errorString)

   ~ -+- as *([String] errorString) {
      .errorString = errorString;
   }

   ~ -+- errorWithContext *([String] errorString, [List<[SourcePosition]>] context) {
      [Variable<[String]>] errorWithContext = \[Variable<[String]>]:as errorString;
      \[Loops]:iterate context *([] _, [SourcePosition] sourcePosition) {
         [String] addedContext = (\prefix:appending (\sourcePosition:description)) !{
               [String] prefix = \[String]:as ## - ##;
            };
         \errorWithContext:set (\prefix:appending addedContext) !{
               [String] prefix = \errorWithContext:get;
            };
      };
      .errorString = \errorWithContext:get;
   }

   :: sourceFileNotAccessible *([String] fileName) -> [Error] {
      [String] prefix = \[String]:as ##Source file not accessible: ##;
   } -> (\[Error]:as (\prefix:appending fileName))

   :: unrecognisedToken *([String] token, [SourcePosition] position) -> [Error] {
      [String] prefix = \[String]:as ##Unrecognised token: ##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext (\prefix:appending token) context)

   :: invalidVisibilityIndicator *([SourcePosition] position) -> [Error] {
      [String] error = \[String]:as ##Invalid visibility indicator##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext error context)

    :: expectingSecondHashForDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second hash for data segment anchor##) context)

   :: expectingSecondDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second data segment anchor##) context)

   :: expectingClassAtTopLevel *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class at top level##) context)

   :: expectingBodyOfClass *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting body of class##) context)

   :: expectingEntryPointMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting entry point method##) context)

   :: expectingClosingBracketForClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class body##) context)

   :: expectingClassName *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class name##) context)

   :: expectingParentType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type##) context)

   :: expectingClosingSquareBracketAfterClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after class header##) context)

   :: expectingGenericIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting generic identifier##) context)

   :: expectingClosingBracketForGenericDeclarationList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for generic declaration list##) context)

   :: expectingDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting dependancy##) context)

   :: expectingReverseDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy##) context)

   :: expectingClosingBracketForDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy list##) context)

   :: expectingReverseDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy list##) context)

   :: expectingType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting type##) context)

   :: expectingOneOrMoreTypesForClassGenericInstantiation *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting one or more types for class generic instantiation##) context)

   :: expectingClosingBracketForClassGenericInstantiations *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class generic instantiations##) context)

   :: expectingClosingBracketForType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for type##) context)

   :: expectingClosingBracketForDependancyWithDerivatives *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy with derivatives##) context)

   :: expectingIdentifierForObjectDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for object declaration##) context)

   :: expectingVisibilityIndicatorForInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting visibility indicator for instance method##) context)

   :: expectingIdentifierForClassMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for class method##) context)

   :: expectingClassMethodExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class method expression##) context)

   :: expectingIdentifierForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for compiler injection##) context)

   :: expectingDataSegmentForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting data segment for compiler injection##) context)

   :: expectingPrologueStatement *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting prologue statement##) context)

   :: expectingMethodInput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method input##) context)

   :: expectingClosingBracketForMethodInputs *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for method inputs##) context)

   :: expectingMethodBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method body##) context)

   :: expectingMethodOutput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method output##) context)

   :: expectingClosingBracketForStatementGroup *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for statement group##) context)

   :: expectingParentTypeForAnonymousClassObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type for anonymous class object##) context)

   :: expectingClosingSquareBracketAfterAnonymousClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after anonymous class header##) context)

   :: expectingAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting anonymous class body##) context)

   :: expectingClosingBracketForAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for anonymous class body##) context)

   :: unexpectedTokenAfterType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token after type##) context)

   :: expectingInstanceMethodIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance method identifier##) context)

   :: expectingExpressionToBeCast *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to be cast##) context)

   :: expectingClosingBracketForCastExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for cast expression##) context)

   :: expectingIdentifierForTypeMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for type method##) context)

   :: expectingEqualsToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting equals to assign local declaration##) context)

   :: expectingExpressionToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign local declaration##) context)

   :: expectingExpressionToAssignInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance method##) context)

   :: expectingExpressionToAssignInstanceObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance object##) context)

   :: expectingInstanceObjectIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance object identifier##) context)

   :: unexpectedTokenBeforeTilde *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token before tilde##) context)

   :: expectingMethodToInvoke *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method to invoke##) context)

   :: expectingProxyObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting proxy object##) context)

   :: expectingCompilerInjectionIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection identifier##) context)

   :: expectingCompilerInjectionDataSegment *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection data segment##) context)

   :: expectingExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression##) context)

   :: expectingClosingBracketForExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for expression##) context)

   :: expectingConstructorIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting constructor identifier##) context)


}


[CommandReader] (String) 
{
   ++ exit [->]
   ++ parseSourceFile [[String]->]
   ++ compileToFile [[String]->]
   ++ invalidCommand [->]
}



[Character] (Byte, Boolean, String, Data)
   [Byte] asciiByte
{
   ~ fromASCII *([Byte] asciiByte) {
      .asciiByte = asciiByte;
   }

   ~ space *{
      .asciiByte = \[Byte]:0x20;
   }

   ++ asASCII *->.asciiByte

   ++ description *-> (\[String]:asASCII \[Data]:copy [:[Sequence<[Byte]>]] { 
      |++ length *->\[Natural]:as ##1## 
      |++ atIndex *->\[Maybe<[Byte]>]:as .asciiByte
   })

   ++ isNULL *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x00))

   ++ isSemicolon *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3B))
   ++ isPlus *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2B))
   ++ isUnderscore *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5F))
   ++ isBackslash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5C))
   ++ isForwardslash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2F))
   ++ isFullstop *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2E))
   ++ isColon *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3A))
   ++ isTilde *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7E))
   ++ isHash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x23))
   ++ isDollarSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x24))
   ++ isBacktick *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x60))
   ++ isAmpersand *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x26))
   ++ isSingleApostrophe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x27))
   ++ isDash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2D))
   ++ isArrowBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3C))
   ++ isArrowBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3E))
   ++ isAsterisk *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2A))
   ++ isCaret *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5E))
   ++ isComma *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2C))
   ++ isCurlyBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7B))
   ++ isCurlyBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7D))
   ++ isDoubleApostrophe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x22))
   ++ isPipe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7C))
   ++ isStrudel *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x40))
   ++ isEqualsSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3D))
   ++ isExclamationMark *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x21))
   ++ isPercentSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x25))
   ++ isQuestionMark *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3F))
   ++ isRoundBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x28))
   ++ isRoundBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x29))
   ++ isSquareBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5B))
   ++ isSquareBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5D))

   ++ isTab *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x09))
   ++ isNewline *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x0A))

   ++ isAlphanumeric *->[Boolean] {
   } -> \[Boolean]:or (\[Boolean]:or (\.asciiByte:inclusiveBetween (\[Byte]:0x30) (\[Byte]:0x39)) (\.asciiByte:inclusiveBetween (\[Byte]:0x41) (\[Byte]:0x5A))) (\.asciiByte:inclusiveBetween (\[Byte]:0x61) (\[Byte]:0x7A))

   ++ isWhitespace *->[Boolean] {
      [Byte] b = (\[Byte]:0x09);
      [Boolean] thing = (\.asciiByte:inclusiveBetween b (\[Byte]:0x0D));
   } -> \[Boolean]:or thing (\.asciiByte:isEqualTo (\[Byte]:0x20))
}


[Configuration] (Maybe, Error, String, StandardIO) {
   
   ~ init *{}

   ++ outputError *([Error] error) {
      \[StandardIO]:stdout \(\error:description):ascii;
      \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;
   }

   ++ commandInput *->[Maybe<[Data]>] {
      [Data] input = \[StandardIO]:stdin;
      [Boolean] emptyInput = (\0:isEqualTo (\input:length)) !{[Natural] 0 = (\[Natural]:as ##0##)};
   } -> \emptyInput:ifOrElse (\[Maybe<[[Data]->]>]:nothing) (*->\[Maybe<[Data]>]:as input)


   
   ++ compilationFileOutput *([String] filePath)-> [Maybe<[[Data]->]>] {
         [File] file = \[File]:atPath filePath;
         \file:clearContents;
         [Boolean] fileExists = \file:exists;
      } -> \fileExists:ifOrElse (*->\[Maybe<[[Data]->]>]:as (file:appendContents)) (\[Maybe<[[Data]->]>]:nothing)
   

   ++ sourceFileInput *([String] filePath)-> [Maybe<[->[Maybe<[Byte]>]]>] {
         [File] file = \[File]:atPath filePath;
         [Boolean] fileExists = \file:exists;
      } -> \fileExists:ifOrElse (*->\[Maybe<[->[Maybe<[Byte]>]]>]:as (
            *-> [Maybe<[Byte]>] {
               [Data] data = \file:readContents (\[Natural]:as ##1##);
            } -> (\data:atIndex (\[Natural]:as ##0##))
         )) (*->\[Maybe<[[Data]->]>]:nothing)
}



[Token] (
         Natural,
         String,
         Boolean,
         Variable
      )
   [Natural] id
   [Natural] secondId
   [String] content
{
   ~ -+- basicToken *([Natural] id) {
      .id = id;
      .content = \[String]:as ####;
      .secondId = \[Natural]:as ##0##;
   }

   ~ -+- secondIdToken *([Natural] id, [Natural] secondId) {
      .id = id;
      .content = \[String]:as ####;
      .secondId = secondId;
   }

   ~ -+- contentToken *([Natural] id, [String] content) {
      .id = id;
      .content = content;
      .secondId = \[Natural]:as ##0##;
   }

   -+- id *->[Natural] {} -> .id
   -+- content *->[String] {} -> .content
   -+- secondId *->[Natural] {} -> .secondId
@@
   ++ asDebugString *->[String] {
      [String] idString = \[String]:stringRepresentationOfNatural .id;
      [String] seperator = \[String]:as "~";
      [String] secondIDString = \[String]:stringRepresentationOfNatural .secondId;
   } -> (\idString:appending (\seperator:appending (\secondIDString:appending (\seperator:appending .content))))
@@
   ++ ifIdentifier *([[String]->] ifIdentifier) {
      [Token] idToken = \[Token]:identifier (\[String]:as ####);
      [Boolean] isIdentifier = \.id:isEqualTo (\idToken:id);
      \isIdentifier:ifOrElse *{
         \ifIdentifier .content;
      } *{};
   }

   :: isVisibilityIndicator *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##1##))

   :: isDataSegment *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##4##))

   :: isIdentifier *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##3##))

   :: isParentIdentifier *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##2##))

   @++ equals *([Token] t) -> [Boolean] {
   @} -> (\[Boolean]:and (\[Boolean]:and (\.content:isEqualTo (\t:content)) (\.secondId:isEqualTo (\t:secondId))) (\.id:isEqualTo (\t:id)))

   :: equals *([Token] t, [Token] t2) -> [Boolean] {
      [String] content = \t2:content;
      [Natural] id = \t2:id;
      [Natural] secondId = \t2:secondId;
   } -> (\[Boolean]:and (\[Boolean]:and (\content:isEqualTo (\t:content)) (\secondId:isEqualTo (\t:secondId))) (\id:isEqualTo (\t:id)))

   :: visibilityIndicator *([Boolean] externalVisibility, [Boolean] classVisibility, [Boolean] inheritedVisibility) -> [Token] {
      [Variable<[Natural]>] visibility = \[Variable<[Natural]>]:as (\[Natural]:as ##0##);
      \externalVisibility:ifOrElse (*{
            \visibility:set (\one:adding (\visibility:get));
         } !{[Natural] one = \[Natural]:as ##1##;}) *{};
      \classVisibility:ifOrElse (*{
            \visibility:set (\ten:adding (\visibility:get));
         } !{[Natural] ten = \[Natural]:as ##10##;}) *{};
      \inheritedVisibility:ifOrElse (*{
            \visibility:set (\hundred:adding (\visibility:get));
         } !{[Natural] hundred = \[Natural]:as ##100##;}) *{};
   } -> (\[Token]:secondIdToken (\[Natural]:as ##1##) (\visibility:get))

   :: parentIdentifier *([Natural] repetitionCount) -> (\[Token]:secondIdToken (\[Natural]:as ##2##) repetitionCount)
   :: identifier *([String] identifierString) -> (\[Token]:contentToken (\[Natural]:as ##3##) identifierString)
   :: dataSegment *([String] content) -> (\[Token]:contentToken (\[Natural]:as ##4##) content)
   
   :: ampersand *-> (\[Token]:basicToken \[Natural]:as ##5##)
   :: singleApostrophe *-> (\[Token]:basicToken \[Natural]:as ##6##)
   :: arrow *-> (\[Token]:basicToken \[Natural]:as ##7##)
   :: arrowBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##8##)
   :: arrowBracketClose *-> (\[Token]:basicToken \[Natural]:as ##9##)
   :: asterisk *-> (\[Token]:basicToken \[Natural]:as ##10##)
   :: asteriskCaret *-> (\[Token]:basicToken \[Natural]:as ##11##)
   :: asteriskArrow *-> (\[Token]:basicToken \[Natural]:as ##12##)
   :: backslash *-> (\[Token]:basicToken \[Natural]:as ##13##)
   :: caret *-> (\[Token]:basicToken \[Natural]:as ##14##)
   :: colon *-> (\[Token]:basicToken \[Natural]:as ##15##)
   :: comma *-> (\[Token]:basicToken \[Natural]:as ##16##)
   :: curlyBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##17##)
   :: curlyBracketClose *-> (\[Token]:basicToken \[Natural]:as ##18##)
   :: doubleApostrophe *-> (\[Token]:basicToken \[Natural]:as ##19##)
   :: doubleColon *-> (\[Token]:basicToken \[Natural]:as ##20##)
   :: equalsSign *-> (\[Token]:basicToken \[Natural]:as ##23##)
   :: exclamationMark *-> (\[Token]:basicToken \[Natural]:as ##24##)
   :: forwardSlash *-> (\[Token]:basicToken \[Natural]:as ##25##)
   :: fullStop *-> (\[Token]:basicToken \[Natural]:as ##26##)
   :: percentSign *-> (\[Token]:basicToken \[Natural]:as ##27##)
   :: pipe *-> (\[Token]:basicToken \[Natural]:as ##28##)
   :: questionMark *-> (\[Token]:basicToken \[Natural]:as ##29##)
   :: roundBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##30##)
   :: roundBracketClose *-> (\[Token]:basicToken \[Natural]:as ##31##)
   :: semicolon *-> (\[Token]:basicToken \[Natural]:as ##32##)
   :: squareBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##33##)
   :: squareBracketClose *-> (\[Token]:basicToken \[Natural]:as ##34##)
   :: tilde *-> (\[Token]:basicToken \[Natural]:as ##36##)
   :: doubleLessThan *-> (\[Token]:basicToken \[Natural]:as ##37##)
   :: EOF *-> (\[Token]:basicToken \[Natural]:as ##38##)
}







[Parser] (
         String,
         Maybe,
         List,
         Error,
         Character,
         Byte,
         Token,
         SourcePosition,
         Boolean,
         Variable,
         Loops,
         Data,
         Integer
      ) 
   [->[Maybe<[Byte]>]] inputStream
   [List<[Error]>] errors
   [Variable<[Maybe<[Token]>]>] currentToken
   [Variable<[SourcePosition]>] currentTokenPosition
   [[[Maybe<[Token]>][SourcePosition]->][->]->] ifNextTokenOrElse
   [Variable<[Maybe<[Character]>]>] currentCharacter
   [SourcePosition] currentCharacterPosition
   [List<[Character]>] buffer
{
   ~ withSourceNameAndInput *([String] sourceName, [->[Maybe<[Byte]>]] inputStream) {
      .inputStream = inputStream;
      .errors = \[List<[Error]>]:empty;
      .currentToken = \[Variable<[?]>]:as (\[Maybe<[Token]>]:nothing);
      .buffer = \[List<[Character]>]:empty;
      .currentCharacter = \[Variable<[?]>]:as \[Maybe<[Character]>]:nothing;
      [SourcePosition] initialPosition = \[SourcePosition]:initialPositionIn sourceName (\:getCopyOfNextLine);
      .currentCharacterPosition = initialPosition;
      .currentTokenPosition = \[Variable<[?]>]:as initialPosition;
      .ifNextTokenOrElse = *([]a,[->]else){\else};
      \:gotoNextCharacterTrue;
      \:gotoNextToken;
   }

   - getCopyOfNextLine *->[String] {
      [String] line = \:stringFromCharacters *([[Character]->] useCharacter) {
         \[Loops]:until *([->] stop) {
            [Maybe<[Character]>] nextChar = \(\.inputStream):isOrElse (*([Byte] b) -> [Maybe<[Character]>] {} -> \[Maybe<[Character]>]:as \[Character]:fromASCII b) ([Maybe<[Character]>]:nothing);
            \nextChar:isOrElse *([Character] c) {
               @\c:debugLog;
               \.buffer:append c;
               [Boolean] notEndOfLine = \[Boolean]:not (\c:isNewline);
               \notEndOfLine:ifOrElse *{
                  [Boolean] cIsTab = \c:isTab;
                  \cIsTab:ifOrElse *{
                     \useCharacter (\[Character]:space);
                  } *{
                     \useCharacter c;
                  };
               } stop;
            } stop;
         };
      };
   } -> line

   - stringFromCharacters *([[[Character]->]->] getCharacters) -> [String] {
            [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
            \getCharacters *([Character] character) {
               \asciiString:append (\character:asASCII);
            };
         } -> \[String]:asASCII \[Data]:copy asciiString

    - gotoNextCharacter *{
      [Maybe<[Character]>] currentCharacter = (\.currentCharacter:get);
      \currentCharacter:isOrElse *([Character] t) {
         \(\t:isNULL):ifOrElse *{} *{\:gotoNextCharacterTrue;};
      } *{};
    }

   - gotoNextCharacterTrue *{
      [Maybe<[Character]>] currentCharacter = (\.currentCharacter:get);
      [Boolean] isNewline = \currentCharacter:isOrElse (*([Character] c) -> [Boolean] {} -> \c:isNewline) (*->\[Boolean]:false);
      [SourcePosition] currentCharacterPosition = .currentCharacterPosition;
      \isNewline:ifOrElse *{
         .currentCharacterPosition = \currentCharacterPosition:startOfNextLine (\:getCopyOfNextLine);
      } *{
         .currentCharacterPosition = \currentCharacterPosition:nextColumn;
      };
      [Maybe<[Character]>] bufferedChar = \.buffer:removeFirst;
      .currentCharacter = bufferedChar;
      @\bufferedChar:isOrElse *{} *{
         @.currentCharacter = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
      @};
   }

   - eatWhitespaceCharacters *{
      \[Loops]:while (*->[Boolean]{
         [Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
         [Maybe<[Character]>] currentCharacter = (\.currentCharacter:get);
         \currentCharacter:isOrElse *([Character] character) {
            \isWhitespace:set (\character:isWhitespace);
         } *{};
      } -> \isWhitespace:get) (:gotoNextCharacter);
   }

   ++ hasErrors *-> [Boolean] {} -> (\[Boolean]:not (\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)})

    ++ errors *-> [List<[Error]>] {} -> .errors

    ++ addError *([Error] error) {
      \.errors:append error;
    }

   ++ token *->[Token] {
      [Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
      [Maybe<[Token]>] m = \.currentToken:get;
      \m:isOrElse *([Token] t) {\token:set t} *{};
   } -> \token:get

   ++ position *->[SourcePosition] {} -> \.currentTokenPosition:get

   ++ peekAtNextToken *->[Token] {
      [Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
      \.ifNextTokenOrElse *([Maybe<[Token]>] t, [SourcePosition] p) {} *{
         [Maybe<[Token]>] currT = \.currentToken:get;
         [SourcePosition] currS = \.currentTokenPosition:get;
         \:gotoNextToken;
         [Maybe<[Token]>] nextT = \.currentToken:get;
         [SourcePosition] nextS = \.currentTokenPosition:get;
         \.currentToken:set currT;
         \.currentTokenPosition:set currS;
         .ifNextTokenOrElse = *([[Maybe<[Token]>][SourcePosition]->]get,[]e){
            \get nextT nextS;
         };
      };
      \.ifNextTokenOrElse *([Maybe<[Token]>] m, [SourcePosition] p) {
         \m:isOrElse *([Token] t) {\token:set t} *{};
      } *{};
   } -> \token:get

   ++ gotoNextToken *{
      \.ifNextTokenOrElse *([Maybe<[Token]>] m, [SourcePosition] p) {
         \m:isOrElse *([Token] t) {\setToken p t;} *{};
         .ifNextTokenOrElse = *([]a,[->]else){\else};
      } *{

      \.currentToken:set (\[Maybe<[Token]>]:nothing);
      \:eatWhitespaceCharacters;

      \ifStrudelOrElse *{
         \[Loops]:while (*->[Boolean]{
                  [Maybe<[Character]>] currentCharacter = \.currentCharacter:get;
               }->\currentCharacter:isOrElse (*([Character] c)->\c:isStrudel) (*->\[Boolean]:false)) *{
            \:gotoNextCharacter;
            \ifStrudelOrElse *{
                     \:gotoNextCharacter;
                  [Variable<[Boolean]>] lastCharacterWasStrudel = \[Variable<[Boolean]>]:as (\[Boolean]:false);
                     \scanToken *([Character] thisCharacter, [->] continueScanning) {
                        \ifElse (thisCharacter:isStrudel) *{
                           \ifElse (lastCharacterWasStrudel:get) *{
                              \lastCharacterWasStrudel:set (\[Boolean]:false);
                              \:gotoNextCharacter;
                              \:eatWhitespaceCharacters;
                           } *{
                              \lastCharacterWasStrudel:set (\[Boolean]:true);
                              \continueScanning;
                           };
                        } *{
                           \lastCharacterWasStrudel:set (\[Boolean]:false);
                           \continueScanning;
                        };
               };
                  } *{
                     \scanToken *([Character] thisCharacter, [->] continueScanning) {
                        \ifElse (thisCharacter:isNewline) *{
                           \:eatWhitespaceCharacters;
                        } *{
                           \continueScanning;
                        };
               };
                  };
            };
        } *{};

        \ifHashOrElse *{
            [SourcePosition] position1 = .currentCharacterPosition;
         \:gotoNextCharacter;
         \ifHashOrElse *{
            \:gotoNextCharacter;
            [String] dataSegmentString = \stringFromCharacters *([[Character]->] useCharacter) {
               [Variable<[Character]>] variablePreviousCharacter = \[Variable<[Character]>]:as (\[Character]:space);
               \[Loops]:until *([->] stop) {
                  [Character] previousCharacter = \variablePreviousCharacter:get;
                  [Maybe<[Character]>] currentCharacter = (\.currentCharacter:get);
                  \currentCharacter:isOrElse *([Character] char) {\variablePreviousCharacter:set char} *{};
                  \ifElse (previousCharacter:isHash) *{
                     \ifHashOrElse stop *{
                        \useCharacter previousCharacter;
                        \currentCharacter:isOrElse *([Character] char) {\useCharacter char} *{
                           \:addError (\[Error]:expectingSecondDataSegmentAnchor position1);
                           \stop;
                        };
                     };
                  } *{
                     \ifHashOrElse *{} *{
                        \currentCharacter:isOrElse *([Character] char) {\useCharacter char} *{\:addError (
                           \[Error]:expectingSecondDataSegmentAnchor position1);
                           \stop;
                        };
                     };
                  };
                  \:gotoNextCharacter;
               } 
            };
            \ifElse ((\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)}) *{
               \setToken position1 (\[Token]:dataSegment dataSegmentString);
            } *{};            
         } *{
            \:addError (\[Error]:expectingSecondHashForDataSegmentAnchor position1);
         }; 
        } *{
         [Maybe<[Character]>] currentCharacter = (\.currentCharacter:get);
         \currentCharacter:isOrElse *([Character] character1) {
         [SourcePosition] position1 = .currentCharacterPosition;
         \:gotoNextCharacter;
         
         [Boolean] isIdentifier = \[Boolean]:or (\character1:isAlphanumeric) (\character1:isUnderscore);
         \isIdentifier:ifOrElse *{
            [String] identifierString = \stringFromCharacters *([[Character]->] useCharacter) {
               \useCharacter character1;
               \scanToken *([Character] thisCharacter, [->] continueScanning) {
                  [Boolean] thisCharacterIsForIdentifier = \[Boolean]:or (\thisCharacter:isAlphanumeric) (\thisCharacter:isUnderscore);
                  \thisCharacterIsForIdentifier:ifOrElse *{\useCharacter thisCharacter;\continueScanning;} *{};
               };
            };
            \setToken position1 (\[Token]:identifier identifierString);
         } *{};

         \if (character1:isDollarSign) *{
                  [Variable<[Integer]>] repetitionCount = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
                  \scanToken *([Character] thisCharacter, [->] continueScanning) {
                     \ifElse (thisCharacter:isDollarSign) *{
                        \repetitionCount:set (\x:adding (\[Integer]:as ##1##)) !{[Integer] x = \repetitionCount:get};
                        \continueScanning;
                     } *{};
                  };
                  \setToken position1 (\[Token]:parentIdentifier (\repetitionCount:get));
            };

            \if (*->\[Boolean]:or (\character1:isDash) (\character1:isPlus)) *{
                  \ifPlusOrDashOrElse (\[Maybe<[Character]>]:as character1) *{
                     \ifPlusOrDashOrElse .currentCharacter *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:false));
                        } *{
                           \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
                        };
                     } *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
                     };
                  } *{
                     \ifPlusOrDashOrElse .currentCharacter *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
                     };
                  } *{};
            };

         [Maybe<[Character]>] currentCharacter2 = (\.currentCharacter:get);
         \currentCharacter2:isOrElse *([Character] character2) {
            [SourcePosition] position2 = .currentCharacterPosition;
                \if (character1:isDash) *{
                     \if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:arrow)};
                  };
                \if (character1:isAsterisk) *{
                     \if (character2:isCaret) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskCaret)};
                     \if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskArrow)};
                  };
                   \if (character1:isColon) *{
                     \if (character2:isColon) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleColon)};
                  };
                \if (character1:isArrowBracketOpen) *{
                     \if (character2:isArrowBracketOpen) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleLessThan)};
                     };
         } *{}; 

         \ifNoToken *{
            \if (character1:isAmpersand) *{\setToken position1 (\[Token]:ampersand)};
            \if (character1:isSingleApostrophe) *{\setToken position1 (\[Token]:singleApostrophe)};
            \if (character1:isArrowBracketOpen) *{\setToken position1 (\[Token]:arrowBracketOpen)};
            \if (character1:isArrowBracketClose) *{\setToken position1 (\[Token]:arrowBracketClose)};
            \if (character1:isAsterisk) *{\setToken position1 (\[Token]:asterisk)};
            \if (character1:isBackslash) *{\setToken position1 (\[Token]:backslash)};
            \if (character1:isCaret) *{\setToken position1 (\[Token]:caret)};
            \if (character1:isColon) *{\setToken position1 (\[Token]:colon)};
            \if (character1:isComma) *{\setToken position1 (\[Token]:comma)};
            \if (character1:isCurlyBracketOpen) *{\setToken position1 (\[Token]:curlyBracketOpen)};
            \if (character1:isCurlyBracketClose) *{\setToken position1 (\[Token]:curlyBracketClose)};
            \if (character1:isDoubleApostrophe) *{\setToken position1 (\[Token]:doubleApostrophe)};
            \if (character1:isEqualsSign) *{\setToken position1 (\[Token]:equalsSign)};
            \if (character1:isExclamationMark) *{\setToken position1 (\[Token]:exclamationMark)};
            \if (character1:isForwardslash) *{\setToken position1 (\[Token]:forwardSlash)};
            \if (character1:isFullstop) *{\setToken position1 (\[Token]:fullStop)};
            \if (character1:isPercentSign) *{\setToken position1 (\[Token]:percentSign)};
            \if (character1:isPipe) *{\setToken position1 (\[Token]:pipe)};
            \if (character1:isQuestionMark) *{\setToken position1 (\[Token]:questionMark)};
            \if (character1:isRoundBracketOpen) *{\setToken position1 (\[Token]:roundBracketOpen)};
            \if (character1:isRoundBracketClose) *{\setToken position1 (\[Token]:roundBracketClose)};
            \if (character1:isSemicolon) *{\setToken position1 (\[Token]:semicolon)};
            \if (character1:isSquareBracketOpen) *{\setToken position1 (\[Token]:squareBracketOpen)};
            \if (character1:isSquareBracketClose) *{\setToken position1 (\[Token]:squareBracketClose)};
            \if (character1:isTilde) *{\setToken position1 (\[Token]:tilde)};
         };
         
         \ifNoToken *{
            \:addError (\[Error]:unrecognisedToken (\character1:description) position1);
         };
      } *{} };   
      }; 
   }  !{
         [[SourcePosition][Token]->] setToken = *([SourcePosition] position, [Token] token) {
            \.currentToken:set (\[Maybe<[Token]>]:as token);
            \.currentTokenPosition:set position;
         };
         [[->]->] ifNoToken = *([->] noToken) {
            (\currentToken:isOrElse *{} noToken) !{[Maybe<[Token]>] currentToken = \.currentToken:get};
         };
         [[->[Boolean]][->]->] if = *([->[Boolean]] condition, [->] action) {
            [Boolean] result = \condition;
            \result:ifOrElse action *{};
         };
         [[->[Boolean]][->][->]->] ifElse = *([->[Boolean]] condition, [->] action, [->] else) {
            [Boolean] result = \condition;
            \result:ifOrElse action else;
         };
         [[[Character][->]->]->] scanToken = *([[Character][->]->] provideCharacterAndContinueScannning) {
            [Variable<[Boolean]>] continuing = \[Variable<[Boolean]>]:as (\[Boolean]:true);
            \[Loops]:while (continuing:get) *{
               \continuing:set (\[Boolean]:false);
               [Maybe<[Character]>] maybeCurrentCharacter = \.currentCharacter:get;
               \maybeCurrentCharacter:isOrElse *([Character] character) {
                  \provideCharacterAndContinueScannning character *{
                     \continuing:set (\[Boolean]:true);
                     \:gotoNextCharacter;
                  };
               } *{};
            };
         };
         [[[[Character]->]->]->[String]] stringFromCharacters = *([[[Character]->]->] getCharacters) -> [String] {
            [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
            \getCharacters *([Character] character) {
               \asciiString:append (\character:asASCII);
            };
         } -> \[String]:asASCII \[Data]:copy asciiString;
         [[->][->]->] ifStrudelOrElse = *([->] action, [->] else) {
            [Maybe<[Character]>] maybeCurrentCharacter = \.currentCharacter:get;
            \maybeCurrentCharacter:isOrElse *([Character] currentCharacter) {
               \ifElse (currentCharacter:isStrudel) action else;
            } else;
         };
         [[->][->]->] ifHashOrElse = *([->] action, [->] else) {
            [Maybe<[Character]>] maybeCurrentCharacter = \.currentCharacter:get;
            \maybeCurrentCharacter:isOrElse *([Character] currentCharacter) {
               \ifElse (currentCharacter:isHash) action else;
            } else;
         };
         [[Maybe<[Character]>][->][->][->]->] ifPlusOrDashOrElse = *([Maybe<[Character]>] maybeChar, [->] plus, [->] dash, [->] else) {
            \maybeChar:isOrElse *([Character] char) {
               \ifElse (char:isPlus) plus *{
                  \ifElse (char:isDash) dash else;
               };
            } else;
         };
      }
}



[Commands] (InputStream, CommandReader, Maybe, Byte, Debug, Boolean, String, Character, Loops, Variable, Data) 
   [->[Maybe<[Byte]>]] inputStream
   [Maybe<[Character]>] currentCharacter
{
   ~ from *([->[Maybe<[Data]>]] dataInputStream) {
      [Variable<[Maybe<[Data]>]>] varCurrentData = \[Variable<[Maybe<[Data]>]>]:as \[Maybe<[Data]>]:nothing;
      [Variable<[Natural]>] currentIndex = \[Variable<[Natural]>]:as \[Natural]:as ##0##;
      [Natural] 1 = \[Natural]:as ##1##;
      [Natural] 0 = \[Natural]:as ##0##;
      .inputStream = * -> [Maybe<[Byte]>] {
         [Variable<[Maybe<[Byte]>]>] nextByte = \[Variable<[Maybe<[Byte]>]>]:as \[Maybe<[Byte]>]:nothing;
         [Maybe<[Data]>] maybeCurrentData = (\varCurrentData:get);
         [->] gotoNextData = *{
            \varCurrentData:set \dataInputStream;
            \currentIndex:set 0;
         };
         \maybeCurrentData:isOrElse *([Data] currentData){
            [Maybe<[Byte]>] inCurrentData = \currentData:atIndex \currentIndex:get;
            \inCurrentData:isOrElse (*([Byte] b) {
            }) gotoNextData;
         } gotoNextData;
         [Maybe<[Data]>] maybeCurrentData2 = (\varCurrentData:get);
         \maybeCurrentData2:isOrElse *([Data] currentData){
         
            [Maybe<[Byte]>] inCurrentData = \currentData:atIndex \currentIndex:get;
            \inCurrentData:isOrElse (*([Byte] b) {
               \nextByte:set \[Maybe<[Byte]>]:as b;
               \currentIndex:set \1:adding \currentIndex:get;
            }) *{};

         } *{};
            
         
      } -> \nextByte:get;

      .currentCharacter = \[Maybe<[Character]>]:nothing;
      \:readNextCharacter;
   }

   ++ readNext *([CommandReader] reader) {
      \:eatWhitespaceCharacters;
      \.currentCharacter:isOrElse *([Character] character) {
         [Boolean] exit = (\character:isSemicolon);
         \exit:ifOrElse reader:exit *{};
         [Variable<[Boolean]>] validCommand = \[Variable<[Boolean]>]:as exit;
         [Boolean] parseSourceFile = (\character:isPlus);
         \parseSourceFile:ifOrElse *{
            \reader:parseSourceFile (\:readNextFilePath);
            \validCommand:set (\[Boolean]:true);
         } *{};
         [Boolean] compileToFile = (\character:isTilde);
         \compileToFile:ifOrElse *{
            [String] compilationMethod = \:readNextString (*([Character]c)->\c:isAlphanumeric);
            \:eatWhitespaceCharacters;
            [Boolean] colonPresent = (\.currentCharacter:isOrElse (*([Character]c)->\c:isColon) (*->\[Boolean]:false));
            \colonPresent:ifOrElse *{
               \reader:compileToFile (\:readNextFilePath);
               \validCommand:set (\[Boolean]:true);
            } *{};
         } *{};
         [Boolean] invalidCommand = \[Boolean]:not (\validCommand:get);
         \invalidCommand:ifOrElse *{
            \reader:invalidCommand;
            \:readNextCharacter;
         } *{};
      } (reader:exit);
   }

   - readNextCharacter *{
      [Maybe<[Byte]>] input = (\.inputStream);
      .currentCharacter = \input:isOrElse (*([Byte] b)->(\[Maybe<[Character]>]:as (\[Character]:fromASCII b))) ([Maybe<[Character]>]:nothing);
   }

   - readNextString *([[Character]->[Boolean]] inString) -> [String] {
      \:eatWhitespaceCharacters;
      [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
      \[Loops]:while (*->[Boolean]{
            [Variable<[Boolean]>] charcterInString = \[Variable<[Boolean]>]:as (\[Boolean]:false);
            \:readNextCharacter;
            \.currentCharacter:isOrElse *([Character] character) {
               \charcterInString:set (\inString character);
            } *{};
         } -> \charcterInString:get) *{
            \.currentCharacter:isOrElse *([Character] character) {
               \asciiString:append (\character:asASCII);
            } *{};
         };
   } -> \[String]:asASCII \[Data]:copy asciiString

   - readNextFilePath *-> [String] {
   } -> \:readNextString *([Character] c) ->[Boolean] {
      } -> \[Boolean]:or (\[Boolean]:or (\[Boolean]:or (\[Boolean]:or (\c:isAlphanumeric) (\c:isFullstop)) (\c:isForwardslash)) (\c:isBackslash)) (\c:isUnderscore)

   - eatWhitespaceCharacters *{
      \[Loops]:while (*->[Boolean]{
         [Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
         \.currentCharacter:isOrElse *([Character] character) {
            \isWhitespace:set (\character:isWhitespace);
         } *{
         };
      } -> \isWhitespace:get) (:readNextCharacter);
   }
}



[DainaGeneralIdentifier] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String, Variable,
         Error, M, O,

         Debug
      )
   @[Variable<[Maybe<[String]>]>]
      [String] content

{
   :: isFirstToken *([Token] token) -> [Boolean] {
      [Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
      \token:ifIdentifier *([String] s) {
         \isIdentifier:set \[Boolean]:true;
      };
   } -> (\isIdentifier:get)

   ~ base *{
      .content = \[String]:as ####;
   }

   ++ content *->.content

   ++ parse *([Parser] parser) {
      [Token] identifierToken = \parser:token;
      \identifierToken:ifIdentifier *([String] s) {
      .content = s;
         @\isIdentifier:set \[Boolean]:true;
      };
      \parser:gotoNextToken;
   }
}


[DainaGenericDeclarationList] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,

         Debug
      )
   [List<[DainaGeneralIdentifier]>] generics
{
   ~ base *{
      .generics = \[List<[DainaGeneralIdentifier]>]:empty;
   }

   ++ parse *([Parser] parser) {
      \(\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen):ifOrElse *{
         \parser:gotoNextToken;
         \[Loops]:until *([->] stop) {
            \(\[DainaGeneralIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
               [DainaGeneralIdentifier] generic = \[DainaGeneralIdentifier]:base;
               \generic:parse parser;
               \.generics:append generic;
               \(\[Token]:equals (\parser:token) \[Token]:comma):ifOrElse *{
                  \parser:gotoNextToken;
               } stop;
            } *{
               \parser:addError (\[Error]:expectingGenericIdentifier (\parser:position));
               \stop;
            };
         };
         \(\[Token]:equals (\parser:token) \[Token]:arrowBracketClose):ifOrElse *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForGenericDeclarationList (\parser:position));
         };
      } *{};
   }
}


[DainaDependancyStructure] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,
         SourcePosition,

         Debug
      )
   [List<[DainaGeneralIdentifier]>] dependancies
   [List<[DainaGeneralIdentifier]>] dependanciesWithDerivatives
   [List<[DainaGeneralIdentifier]>] reverseDependancies
{
   ~ base *{
      .dependancies = \[List<[DainaGeneralIdentifier]>]:empty;
      .reverseDependancies = \[List<[DainaGeneralIdentifier]>]:empty;
      .dependanciesWithDerivatives = \[List<[DainaGeneralIdentifier]>]:empty;
   }

   ++ parse *([Parser] parser) {{
      \(\[Token]:equals (\parser:token) \[Token]:roundBracketOpen):ifOrElse *{
         \parseIDList .dependancies ([Error]:expectingDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:as .dependanciesWithDerivatives);
         \(\[Token]:equals (\parser:token) (\[Token]:arrow)):ifOrElse *{
            \parser:gotoNextToken;
            \(\[Token]:equals (\parser:token) \[Token]:roundBracketOpen):ifOrElse *{
               \parseIDList .reverseDependancies ([Error]:expectingReverseDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:nothing);
            } *{
               \parser:addError (\[Error]:expectingReverseDependancyList (\parser:position));
            };
         } *{};
      } *{};
   }  !{
         [[List<[DainaGeneralIdentifier]>][[SourcePosition]->[Error]][Maybe<[List<[DainaGeneralIdentifier]>]>]->] parseIDList = *([List<[DainaGeneralIdentifier]>] list, [[SourcePosition]->[Error]] missingIDError, [Maybe<[List<[DainaGeneralIdentifier]>]>] maybeDerivativeList) {
            \parser:gotoNextToken;
            \(\[DainaGeneralIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
               \[Loops]:until *([->] stop) {
                  \(\[DainaGeneralIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
                     [DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
                     \id:parse parser;
                     \list:append id;
                     \(\[Token]:equals (\parser:token) \[Token]:comma):ifOrElse *{
                        \parser:gotoNextToken;
                     } stop;
                  } *{
                     \maybeDerivativeList:isOrElse *([List<[DainaGeneralIdentifier]>] derivativeList) {
                        \(\[Token]:equals (\parser:token) \[Token]:roundBracketOpen):ifOrElse *{
                           \parser:gotoNextToken;
                           \(\[DainaGeneralIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
                              [DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
                              \id:parse parser;
                              \list:append id;
                              \derivativeList:append id;
                              \(\[Token]:equals (\parser:token) \[Token]:roundBracketClose):ifOrElse *{
                                 \parser:gotoNextToken;
                                 \(\[Token]:equals (\parser:token) \[Token]:comma):ifOrElse *{
                                    \parser:gotoNextToken;
                                 } stop;
                              } *{
                                 \parser:addError (\[Error]:expectingClosingBracketForDependancyWithDerivatives (\parser:position));
                                 \stop;
                              };
                           } missingId;
                        } missingId;
                     } missingId;
                  }  !{ 
                        [->] missingId = *{
                           \parser:addError (\missingIDError (\parser:position));
                           \stop;
                        }
                     };
               };
            } *{};
            \(\[Token]:equals (\parser:token) \[Token]:roundBracketClose):ifOrElse *{
               \parser:gotoNextToken;
            } *{
               \parser:addError (\[Error]:expectingClosingBracketForDependancyList (\parser:position));
            };
         };
         }}
}



[DainaClassIdentifier] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String, Variable,
         Error, M, O,

         Debug
      )
   @[Variable<[Maybe<[String]>]>]
   [String] content
{
   :: isFirstToken *([Token] token) -> [Boolean] {
      [Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
      \token:ifIdentifier *([String] s) {
         \isIdentifier:set \[Boolean]:true;
      };
   } -> (\isIdentifier:get)

   ~ base *{
      .content = \[String]:as ####;
   }

   ++ content *->.content

   ++ parse *([Parser] parser) {
      [Token] identifierToken = \parser:token;
      \identifierToken:ifIdentifier *([String] s) {
      .content = s;
         @\isIdentifier:set \[Boolean]:true;
      };
      \parser:gotoNextToken;
   }
}




[O] {
   :: ifElse *([Boolean] b, [->] if, [->] else) {
      \b:ifOrElse if else;
   } 

   :: selectOrDefault *([[->]->] select, [->] default) {
      [Variable<[Boolean]>] wasSelected = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      \select *{
         \wasSelected:set (\[Boolean]:true);
      };
      [Boolean] b =  (\wasSelected:get);
      \b:ifOrElse (*{}) default;
   }
}


[DainaType] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Integer,
         Maybe,
         String,
         Error, M, O,
         Variable,
         DainaClassIdentifier,
         DainaGeneralIdentifier,

         Debug
      )
   [[[DainaClassIdentifier][List<[DainaType]>]->]->] ifClassNameAndGenericInstantiation

   [[[List<[DainaType]>][Maybe<[DainaType]>]->]->] ifMethodInputsAndOutput
   [[[List<[DainaType]>]->]->] ifDisjoint
   [[[DainaGeneralIdentifier]->]->] ifClassGeneric
   [[[Integer][DainaGeneralIdentifier]->]->] ifMethodGenericLevelAndIdentifier
   [[[DainaGeneralIdentifier]->]->] ifDataSegment
   [[->]->] ifInferredMethod
   [[->]->] ifInferredSelf
   [[->]->] ifInferred
   [[[Integer]->]->] ifInferredParent
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:squareBracketOpen)

   ++ ifClassNameAndGenericInstantiation *([[DainaClassIdentifier][List<[DainaType]>]->] get) {
      \.ifClassNameAndGenericInstantiation get;
   }

   ++ ifMethodInputsAndOutput *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {
      \.ifMethodInputsAndOutput get;
   }

   ~ base *{
      .ifClassNameAndGenericInstantiation = *([]a){};

      .ifMethodInputsAndOutput = *([]a){};
      .ifDisjoint = *([]a){};
      .ifClassGeneric = *([]a){};
      .ifMethodGenericLevelAndIdentifier = *([]a){};
      .ifDataSegment = *([]a){};
      .ifInferredMethod = *([]a){};
      .ifInferredSelf = *([]a){};
      .ifInferredParent = *([]a){};
      .ifInferred = *([->]a){\a};
   }

   ++ setAsMethodWithOutputType *([DainaType] outputType) {
      .ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->]get){\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:as outputType)};
   }

   ++ setAsClassName *([DainaClassIdentifier] className) {
      .ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->]get){\get className (\[List<[DainaType]>]:empty)};
   }

   ++ parse *([Parser] parser) {
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
            [DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
            \className:parse parser;
            [List<[DainaType]>] genericInstantiations = \[List<[DainaType]>]:empty;
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
               \parser:gotoNextToken;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
                     [DainaType] genericInstantiation = \[DainaType]:base;
                     \genericInstantiation:parse parser;
                     \genericInstantiations:append genericInstantiation;
                     \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{} stop;
                  } *{
                     \parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
                     \stop;
                  };
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
               };
            } *{};
            .ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->] get) {\get className genericInstantiations};
         } *{
            @ bla my way through
            \[Loops]:until *([->] stop) {
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
                  [DainaType] subtype = \[DainaType]:base;
                  \subtype:parse parser;
                  \.ifMethodInputsAndOutput *([List<[DainaType]>] a, [Maybe<[DainaType]>]b) {
                     .ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:as subtype)};
                  };
               } *{
                  \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow) *{
                     \parser:gotoNextToken;
                     .ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:nothing)};
                  } *{
                     \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) stop *{
                        \parser:gotoNextToken;
                     };
                  };
               };
            };
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
         };
      } *{
         \parser:addError (\[Error]:expectingType (\parser:position));
      };
   }
}


[DainaObjectDeclaration] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaType,
         DainaGeneralIdentifier,

         Debug
      )
   [DainaType] type
   [DainaGeneralIdentifier] identifier
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Boolean]:or (\[DainaType]:isFirstToken token) (\[DainaGeneralIdentifier]:isFirstToken token))

   ++ type*->.type
   ++ identifier*->.identifier

   ~ base *{
      .type = \[DainaType]:base;
      .identifier = \[DainaGeneralIdentifier]:base;
   }

   ~ as *([DainaType] type, [DainaGeneralIdentifier] identifier){
      .type = type;
      .identifier = identifier;
   }

   ++ parse *([Parser] parser) {
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
         \.identifier:parse parser;
      } *{
         \.type:parse parser;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            \.identifier:parse parser;
         } *{
            \parser:addError (\[Error]:expectingIdentifierForObjectDeclaration (\parser:position));
         };
      };
   }
}


@class-method-classification identifier ( type | expression )

@    class-method-classification: ( ( | | || )? method-visibility-indicator ) | ( ( ~ | :: ) ( | )? ( method-visibility-indicator )? )


[DainaClassMethod<DainaExpression>] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,
         Variable,
         DainaType,

         Debug
      )
   [Variable<[Boolean]>] unimplementedMethod
   [DainaGeneralIdentifier] identifier
   [&DainaExpression] methodExpression
   [[->][->][->]->] isInstanceTypeOrConstructor
   [[Parser][&DainaExpression]->] parseExpression
   [[Token]->[Boolean]] isExpressionFirstToken
   [DainaType] unimplementedType
{
   ++ isInstanceTypeOrConstructor *([->] isInstance,[->] isType,[->] isConstructor) {
      \.isInstanceTypeOrConstructor isInstance isType isConstructor;
   }

   ++ isUnimplementedMethod *->(\.unimplementedMethod:get)

   ++ unimplementedType *->(.unimplementedType)

   ++ methodExpression *->.methodExpression

   ++ identifier*-> .identifier

   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Boolean]:or (\[Boolean]:or (\[Token]:isVisibilityIndicator token) (\[Token]:equals token (\[Token]:pipe))) (\[Boolean]:or (\[Token]:equals token (\[Token]:doubleColon)) (\[Token]:equals token (\[Token]:tilde))))

   ~ base *([->[&DainaExpression]] getBase, [[Parser][&DainaExpression]->] parseExpression, [[Token]->[Boolean]] isExpressionFirstToken){
      .isInstanceTypeOrConstructor = *([->]a,[]b,[]c){};
      .methodExpression = \getBase;
      .identifier = \[DainaGeneralIdentifier]:base;
      .unimplementedMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      .parseExpression = parseExpression;
      .isExpressionFirstToken = isExpressionFirstToken;
      .unimplementedType = \[DainaType]:base;
   }

   ++ parse *([Parser] parser) {
      .isInstanceTypeOrConstructor = *([->]a,[]b,[]c){\a};
      \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:tilde)) *{
         \parser:gotoNextToken;
         .isInstanceTypeOrConstructor = *([]a,[]b,[->]c){\c};
      } *{
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:doubleColon)) *{
            \parser:gotoNextToken;
            .isInstanceTypeOrConstructor = *([]a,[->]b,[]c){\b};
         } *{};
      };
      \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:pipe)) *{
         \parser:gotoNextToken;
      } *{};
      \.isInstanceTypeOrConstructor *{
         \[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingVisibilityIndicatorForInstanceMethod (\parser:position));
         };
      } *{
         \[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
            \parser:gotoNextToken;
         } *{};
      } *{
         \[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
            \parser:gotoNextToken;
         } *{};
      };
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
         \.identifier:parse parser;
         \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
            \.unimplementedMethod:set (\[Boolean]:true); 
            [DainaType] typeForUnimplemented = \[DainaType]:base;
            \.unimplementedType:parse parser;
         } *{
            \[O]:ifElse (\.isExpressionFirstToken (\parser:token)) *{
               \.parseExpression parser (.methodExpression);
            } *{
               \parser:addError (\[Error]:expectingClassMethodExpression (\parser:position));
            };
         };
      } *{
         \parser:addError (\[Error]:expectingIdentifierForClassMethod (\parser:position));
      };
   }
}



[DainaCompilerInjection] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,

         Debug
      )
   [DainaGeneralIdentifier] identifier
   [String] dataSegment
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:doubleLessThan)

   ~ base *{
      .identifier = \[DainaGeneralIdentifier]:base;
      .dataSegment = \[String]:as ####;
   }

   ++ identifierString *->\.identifier:content

   ++ dataSegment *->.dataSegment

   ++ parse *([Parser] parser) {
      \parser:gotoNextToken;
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
         \.identifier:parse parser;
         \[O]:ifElse (\[Token]:isDataSegment (\parser:token)) *{
            [Token] token = (\parser:token);
            .dataSegment = \token:content;
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingDataSegmentForCompilerInjection (\parser:position));
         };
      } *{
         \parser:addError (\[Error]:expectingIdentifierForCompilerInjection (\parser:position));
      };
   }
}



[DainaExpression] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaObjectDeclaration,
         DainaType,
         Variable,
         DainaClassMethod,
         DainaGeneralIdentifier,
         Integer,
         DainaCompilerInjection,

         Debug
      )
   [DainaType] outputType
   [[[List<[DainaExpression]>]->]->] ifStatementGroup
   [[[String]->]->] ifDataSegment
   [[[DainaExpression][DainaExpression]->]->] ifWithPrologueStatement
   [[[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->]->] ifMethodExpression
   [[[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->]->] ifAnonymousClassObject
   [[[DainaExpression][DainaGeneralIdentifier]->]->] ifInstanceMethod
   [[[DainaObjectDeclaration][DainaExpression]->]->] ifLocalObjectAssignment
   [[[DainaType][DainaGeneralIdentifier]->]->] ifTypeMethod

   [[[DainaExpression][List<[DainaExpression]>]->]->] ifInvocation
   [[[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->]->] ifConstructorInvocation @ parentnum, identifier, ispointerconsturcotr, params
   [[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceMethodAssignment
   [[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceObjectAssignment
   [[[DainaExpression]->]->] ifProxyObject
   [[[DainaCompilerInjection]->]->] ifCompilerInjection
   [[[DainaGeneralIdentifier]->]->] ifLocalObject
   [[[Integer][DainaGeneralIdentifier]->]->] ifInternalInstanceMethod @ prentnum, id
   [[[DainaGeneralIdentifier]->]->] ifInternalInstanceObject
   [[->]->] ifSelfReference
   [[->]->] ifMethodSelfReference
   
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } ->  

(\[Boolean]:or (\[Token]:equals token (\[Token]:backslash))
(\[Boolean]:or (\[Token]:equals token (\[Token]:fullStop))
(\[Boolean]:or (\[Token]:equals token (\[Token]:colon))
(\[Boolean]:or (\[Token]:equals token (\[Token]:asteriskCaret))
(\[Boolean]:or (\[Token]:equals token (\[Token]:asteriskArrow))
(\[Boolean]:or (\[Token]:equals token (\[Token]:caret))
(\[Boolean]:or (\[Token]:equals token (\[Token]:doubleLessThan))
(\[Boolean]:or (\[Token]:equals token (\[Token]:roundBracketOpen))
(\[Boolean]:or (\[Token]:isIdentifier token)
(\[Boolean]:or (\[Token]:isParentIdentifier token)

   (\[Boolean]:or (\[Token]:equals token (\[Token]:squareBracketOpen)) (\[Boolean]:or (\[Token]:equals token (\[Token]:curlyBracketOpen)) (\[Boolean]:or (\[Token]:isDataSegment token) (\[Token]:equals token (\[Token]:asterisk))))) ))))))))))


   ~ base *{
      .ifStatementGroup = *([[List<[DainaExpression]>]->]get){};
      .ifDataSegment = *([]a){};
      .ifWithPrologueStatement = *([]a){};
      .ifMethodExpression = *([]a){};
      .ifAnonymousClassObject = *([]a){};
      .ifInstanceMethod = *([]a){};
      .ifLocalObjectAssignment = *([]a){};
      .ifTypeMethod = *([]a){};
      .outputType = \[DainaType]:base;

      .ifInvocation = *([]a){};
      .ifConstructorInvocation = *([]a){};
      .ifInstanceMethodAssignment = *([]a){};
      .ifInstanceObjectAssignment = *([]a){};
      .ifProxyObject = *([]a){};
      .ifCompilerInjection = *([]a){};
      .ifLocalObject = *([]a){};
      .ifInternalInstanceMethod = *([]a){};
      .ifInternalInstanceObject = *([]a){};
      .ifSelfReference = *([]a){};
      .ifMethodSelfReference = *([]a){};
   }

   ++ toBase *{
      .ifStatementGroup = *([[List<[DainaExpression]>]->]get){};
      .ifDataSegment = *([]a){};
      .ifWithPrologueStatement = *([]a){};
      .ifMethodExpression = *([]a){};
      .ifAnonymousClassObject = *([]a){};
      .ifInstanceMethod = *([]a){};
      .ifLocalObjectAssignment = *([]a){};
      .ifTypeMethod = *([]a){};
      .outputType = \[DainaType]:base;

      .ifInvocation = *([]a){};
      .ifConstructorInvocation = *([]a){};
      .ifInstanceMethodAssignment = *([]a){};
      .ifInstanceObjectAssignment = *([]a){};
      .ifProxyObject = *([]a){};
      .ifCompilerInjection = *([]a){};
      .ifLocalObject = *([]a){};
      .ifInternalInstanceMethod = *([]a){};
      .ifInternalInstanceObject = *([]a){};
      .ifSelfReference = *([]a){};
      .ifMethodSelfReference = *([]a){};
   }

   ++ outputType *->[DainaType]{}->.outputType
   ++ setOutputType *([DainaType] outputType) {.outputType = outputType}

   ++ ifInvocation *([[DainaExpression][List<[DainaExpression]>]->] get) {\.ifInvocation get}
   ++ ifConstructorInvocation *([[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->] get) {\.ifConstructorInvocation get}
   ++ ifInstanceMethodAssignment *([[DainaGeneralIdentifier][DainaExpression]->] get) {\.ifInstanceMethodAssignment get}
   ++ ifInstanceObjectAssignment *([[DainaGeneralIdentifier][DainaExpression]->] get) {\.ifInstanceObjectAssignment get}
   ++ ifProxyObject *([[DainaExpression]->] get) {\.ifProxyObject get}
   ++ ifCompilerInjection *([[DainaCompilerInjection]->] get) {\.ifCompilerInjection get}
   ++ ifLocalObject *([[DainaGeneralIdentifier]->] get) {\.ifLocalObject get}
   ++ ifInternalInstanceMethod *([[Integer][DainaGeneralIdentifier]->] get) {\.ifInternalInstanceMethod get}
   ++ ifInternalInstanceObject *([[DainaGeneralIdentifier]->] get) {\.ifInternalInstanceObject get}
   ++ ifSelfReference *([->] get) {\.ifSelfReference get}
   ++ ifMethodSelfReference *([->] get) {\.ifMethodSelfReference get}

   ++ ifStatementGroup *([[List<[DainaExpression]>]->] get) {\.ifStatementGroup get}
   ++ ifDataSegment *([[String]->] get) {\.ifDataSegment get}
   ++ ifWithPrologueStatement *([[DainaExpression][DainaExpression]->] get) {\.ifWithPrologueStatement get}
   ++ ifMethodExpression *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {\.ifMethodExpression get}
   ++ ifAnonymousClassObject *([[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->] get) {\.ifAnonymousClassObject get}
   ++ ifInstanceMethod *([[DainaExpression][DainaGeneralIdentifier]->] get) {\.ifInstanceMethod get}
   ++ ifLocalObjectAssignment *([[DainaObjectDeclaration][DainaExpression]->] get) {\.ifLocalObjectAssignment get}
   ++ ifTypeMethod *([[DainaType][DainaGeneralIdentifier]->] get) {\.ifTypeMethod get}

   -+- copy *([DainaExpression] other) {
      .ifStatementGroup = other:ifStatementGroup;
      .ifDataSegment = other:ifDataSegment;
      .ifWithPrologueStatement = other:ifWithPrologueStatement;
      .ifMethodExpression = other:ifMethodExpression;
      .ifAnonymousClassObject = other:ifAnonymousClassObject;
      .ifInstanceMethod = other:ifInstanceMethod;
      .ifLocalObjectAssignment = other:ifLocalObjectAssignment;
      .ifTypeMethod = other:ifTypeMethod;
      .outputType = \other:outputType;

      .ifInvocation = other:ifInvocation;
      .ifConstructorInvocation = other:ifConstructorInvocation;
      .ifInstanceMethodAssignment = other:ifInstanceMethodAssignment;
      .ifInstanceObjectAssignment = other:ifInstanceObjectAssignment;
      .ifProxyObject = other:ifProxyObject;
      .ifCompilerInjection = other:ifCompilerInjection;
      .ifLocalObject = other:ifLocalObject;
      .ifInternalInstanceMethod = other:ifInternalInstanceMethod;
      .ifInternalInstanceObject = other:ifInternalInstanceObject;
      .ifSelfReference = other:ifSelfReference;
      .ifMethodSelfReference = other:ifMethodSelfReference;
   }
@@
   - copyTo *([DainaExpression] it) {
      @[DainaExpression] me = \[DainaExpression]:base;
      <instant
      ##
         //Z_local_me = Z_self;
      ##;
      @\it:copy me;
      <instant
      ##

      void* Z_temporary_9 = ((void *)(0));
           //ASSIGN temporary_9 = Z_self
/*C*/      Z_temporary_9 = Z_self;
           //CREATE STATIC_OBJECT temporary_11 WITH METHOD classmethod_DainaExpression_copy
/*C*/      void* Z_temporary_11 = &Z_classmethod_DainaExpression_copy;
           //CREATE DYNAMIC_OBJECT temporary_10 WITH METHOD[STATIC_OBJECT] temporary_11 FRAME{STATIC(),DYNAMIC(local_it)}
/*C*/      void* Z_temporary_10 = allocateDynamicLambda(1,1,Z_temporary_11);
/*C*/      *(((void* *)(Z_temporary_10+sizeof(DynamicLambda)+sizeof(void*)*0))) = Z_local_it;
           //CREATE OBJECT temporary_8 = INVOKE temporary_10(temporary_9)
/*C*/      void* Z_temporary_8 = ((void*(*)(void*,void*))(((DynamicLambda *)(Z_temporary_10))->method))(Z_temporary_10+sizeof(DynamicLambda), Z_temporary_9);


         //Z_local_me = Z_self;
      ##;
   }@@

   ++ makeEmptyStatement *{.ifStatementGroup = *([[List<[DainaExpression]>]->] get){\get (\[List<[DainaExpression]>]:empty)}}

   ++ parse *([Parser] parser) {
      [DainaExpression] left = \[DainaExpression]:base;
      \left:parseStrongBinding parser;
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:exclamationMark) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
            [DainaExpression] right = \[DainaExpression]:base;
            \right:parse parser;
            .ifWithPrologueStatement = *([[DainaExpression][DainaExpression]->] get) {\get left right};
         } *{
            \parser:addError (\[Error]:expectingPrologueStatement (\parser:position));
         };
      } *{
         \:copy left;
      };
   }

   

   -+- parseStrongBinding *([Parser] parser) {
      [DainaExpression] left = \[DainaExpression]:base;
      \left:parseStrongestBinding parser;
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:colon) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] right = \[DainaGeneralIdentifier]:base;
            \right:parse parser;
            .ifInstanceMethod = *([[DainaExpression][DainaGeneralIdentifier]->] get) {\get left right};
         } *{
            \parser:addError (\[Error]:expectingInstanceMethodIdentifier (\parser:position));
         };
      } *{
         \:copy left;
      };
   }

   -+- parseStrongestBinding *([Parser] parser) {
      [Token] token1 = (\parser:token);
      [Token] token2 = (\parser:peekAtNextToken);
      \[O]:ifElse (\[Token]:isDataSegment token1) *{
         .ifDataSegment = *([[String]->] get) {\get (\token1:content)};
         \parser:gotoNextToken;
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:asterisk)) *{
         \parser:gotoNextToken;
         [List<[DainaObjectDeclaration]>] parameters = \[List<[DainaObjectDeclaration]>]:empty;
         [DainaExpression] body = (\[DainaExpression]:base);
         [Variable<[Maybe<[DainaExpression]>]>] output = \[Variable<[Maybe<[DainaExpression]>]>]:as (\[Maybe<[DainaExpression]>]:nothing);
         .ifMethodExpression = *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {
            \get parameters body (\output:get);
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
            \parser:gotoNextToken;
            \[Loops]:until *([->] stop) {
               \[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
                  [DainaObjectDeclaration] parameter = \[DainaObjectDeclaration]:base;
                  \parameter:parse parser;
                  \parameters:append parameter;
               } *{
                  \parser:addError (\[Error]:expectingMethodInput (\parser:position));
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:comma)) (parser:gotoNextToken) stop;
            };
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
               \parser:gotoNextToken;
            } *{
               \parser:addError (\[Error]:expectingClosingBracketForMethodInputs (\parser:position));
            };
         } *{};
         \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
            \body:parseStrongBinding parser;
         } *{
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[Boolean]:and (\[DainaType]:isFirstToken (\parser:token)) (\[Boolean]:not (\[Token]:equals (\parser:peekAtNextToken) (\[Token]:colon)))) *{
                  [DainaType] outputType = \[DainaType]:base;
                  \outputType:parse parser;
                  .outputType = outputType;
                  \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                     \body:parseStrongBinding parser;
                  } *{
                     \parser:addError (\[Error]:expectingMethodBody (\parser:position));
                  };
                  \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
                     \parser:gotoNextToken;
                  } *{
                     \parser:addError (\[Error]:expectingMethodOutput (\parser:position));
                  };
               } *{
                  \body:makeEmptyStatement;
               };
               \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                  [DainaExpression] outputExpression = \[DainaExpression]:base;
                  \outputExpression:parseStrongBinding parser;
                  \output:set (\[Maybe<[DainaExpression]>]:as outputExpression);
               } *{
                  \parser:addError (\[Error]:expectingMethodOutput (\parser:position));
               };
            } *{
               \body:makeEmptyStatement;
            };
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:curlyBracketOpen)) *{
         \parser:gotoNextToken;
         [List<[DainaExpression]>] statements = \[List<[DainaExpression]>]:empty;
         .ifStatementGroup = *([[List<[DainaExpression]>]->] get) {\get statements};
         \[Loops]:until *([->] stop) {
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] statement = \[DainaExpression]:base;
               \statement:parse parser;
               \statements:append statement;
            } *{};
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:semicolon)) (parser:gotoNextToken) stop;
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketClose)) *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForStatementGroup (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Boolean]:and (\[Token]:equals token1 (\[Token]:squareBracketOpen)) (\[Token]:equals token2 (\[Token]:colon))) *{
         @anonymous-class-object
         \parser:gotoNextToken;
         \parser:gotoNextToken;
         [List<[DainaType]>] parents = \[List<[DainaType]>]:empty;
         [List<[DainaExpression]>] constructor = \[List<[DainaExpression]>]:empty;
         [List<[DainaClassMethod<[DainaExpression]>]>] classMethods = \[List<[DainaClassMethod<[DainaExpression]>]>]:empty;
         .ifAnonymousClassObject = *([[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->] get)  {
            \get parents constructor classMethods;
         };
         \[Loops]:until *([->] stop) {
            \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
               [DainaType] parent = \[DainaType]:base;
               \parent:parse parser;
               \parents:append parent;
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) (parser:gotoNextToken) stop;
            } *{
               \parser:addError (\[Error]:expectingParentTypeForAnonymousClassObject (\parser:position));
               \stop;
            }
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:squareBracketClose)) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketOpen)) *{
               \parser:gotoNextToken;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                     [DainaExpression] constructorStatement = \[DainaExpression]:base;
                     \constructorStatement:parse parser;
                     \constructor:append constructorStatement;
                  } *{};
                  \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:semicolon)) (parser:gotoNextToken) stop;
               };
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaClassMethod<[DainaExpression]>]:isFirstToken (\parser:token)) *{
                     [DainaClassMethod<[DainaExpression]>] classMethod = \[DainaClassMethod<[DainaExpression]>]:base ([DainaExpression]:base) (*([Parser] parser, [DainaExpression] e){\e:parse parser}) ([DainaExpression]:isFirstToken);
                     \classMethod:parse parser;
                     \classMethods:append classMethod;
                  } stop;
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketClose)) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForAnonymousClassBody (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingAnonymousClassBody (\parser:position));
            };
         } *{
            \parser:addError (\[Error]:expectingClosingSquareBracketAfterAnonymousClassHeader (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Boolean]:and (\[DainaType]:isFirstToken token1) (\[Boolean]:not (\[Token]:equals token2 (\[Token]:colon)))) *{
         [DainaType] type = \[DainaType]:base;
         \type:parse parser;
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] expr = \[DainaExpression]:base;
               \expr:parse parser;
               \:copy expr;
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForCastExpression (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingExpressionToBeCast (\parser:position));
            };
         } *{
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
                  [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
                  \identifier:parse parser;
                  .ifTypeMethod = *([[DainaType][DainaGeneralIdentifier]->] get) {\get type identifier};
               } *{
                  \parser:addError (\[Error]:expectingIdentifierForTypeMethod (\parser:position));
               };
            } *{
               \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
                  [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
                  \identifier:parse parser;
                  [DainaObjectDeclaration] localDeclaration = \[DainaObjectDeclaration]:as type identifier;
                  \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
                     \parser:gotoNextToken;
                     \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                        [DainaExpression] expr = \[DainaExpression]:base;
                        \expr:parse parser;
                        .ifLocalObjectAssignment = *([[DainaObjectDeclaration][DainaExpression]->] get) {\get localDeclaration expr};
                     } *{
                        \parser:addError (\[Error]:expectingExpressionToAssignLocalDeclaration (\parser:position));  
                     };
                  } *{
                     \parser:addError (\[Error]:expectingEqualsToAssignLocalDeclaration (\parser:position));   
                  };
               } *{
                  \parser:addError (\[Error]:unexpectedTokenAfterType (\parser:position));
               };
            };
         };
      } *{};

      \[O]:ifElse (\[Token]:equals token1 (\[Token]:colon)) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
            \identifier:parse parser;
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                  [DainaExpression] expr = \[DainaExpression]:base;
                  \expr:parse parser;
                  .ifInstanceMethodAssignment = *([[DainaGeneralIdentifier][DainaExpression]->] get) {\get identifier expr};
               } *{
                  \parser:addError (\[Error]:expectingExpressionToAssignInstanceMethod (\parser:position)); 
               };
            } *{
               .ifInternalInstanceMethod = *([[Integer][DainaGeneralIdentifier]->] get) {\get (\[Integer]:as ##0##) identifier};
            };
         } *{
            \parser:addError (\[Error]:expectingInstanceMethodIdentifier (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:fullStop)) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
            \identifier:parse parser;
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                  [DainaExpression] expr = \[DainaExpression]:base;
                  \expr:parse parser;
                  .ifInstanceObjectAssignment = *([[DainaGeneralIdentifier][DainaExpression]->] get) {\get identifier expr};
               } *{
                  \parser:addError (\[Error]:expectingExpressionToAssignInstanceObject (\parser:position)); 
               };
            } *{
               .ifInternalInstanceObject = *([[DainaGeneralIdentifier]->] get) {\get identifier};
            };
         } *{
            \parser:addError (\[Error]:expectingInstanceObjectIdentifier (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Token]:isParentIdentifier token1) *{
         [Integer] parentNum = \token1:secondId;
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
            \identifier:parse parser;
            .ifInternalInstanceMethod = *([[Integer][DainaGeneralIdentifier]->] get) {\get parentNum identifier};
         } *{
            \parser:addError (\[Error]:expectingInstanceObjectIdentifier (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:backslash)) *{
         [->[List<[DainaExpression]>]] parseParameterList = *->[List<[DainaExpression]>] {
            [List<[DainaExpression]>] paramList = \[List<[DainaExpression]>]:empty;
            \[Loops]:while (*->(\[DainaExpression]:isFirstToken (\parser:token))) *{
               [DainaExpression] expr = \[DainaExpression]:base;
               \expr:parse parser;
               \paramList:append expr;
            };
         } -> paramList;
         \parser:gotoNextToken;
         \[O]:ifElse (\[Token]:equals (\parser:peekAtNextToken) (\[Token]:tilde)) *{
            [Token] idToken = (\parser:token);
            [Variable<[Maybe<[Integer]>]>] parentNum = \[Variable<[Maybe<[Integer]>]>]:as (\[Maybe<[Integer]>]:nothing);
            \[O]:ifElse (\[Token]:isParentIdentifier idToken) *{
               \parentNum:set (\[Maybe<[Integer]>]:as (\idToken:secondId));
            } *{
               \[O]:ifElse (\[Token]:equals idToken (\[Token]:colon)) *{
                  \parentNum:set (\[Maybe<[Integer]>]:as (\[Integer]:as ##0##));
               } *{
                  \parser:addError (\[Error]:unexpectedTokenBeforeTilde (\parser:position));
               };
            };
            [Maybe<[Integer]>] m = \parentNum:get;
            \m:isOrElse *([Integer] parentNumber) {
               \parser:gotoNextToken;
               \parser:gotoNextToken;
               [Boolean] isPointerConstructor = (\[Token]:equals (\parser:token) (\[Token]:arrowBracketClose));
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \[O]:ifElse isPointerConstructor (parser:gotoNextToken) *{
                  \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
                     \identifier:parse parser;
                  } *{
                     \parser:addError (\[Error]:expectingConstructorIdentifier (\parser:position));   
                  };
               };
               [List<[DainaExpression]>] paramList = \parseParameterList;
               .ifConstructorInvocation = *([[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->] get) {\get parentNumber identifier isPointerConstructor paramList};
            } *{};
         } *{
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] methodExpr = \[DainaExpression]:base;
               \methodExpr:parse parser;
               [List<[DainaExpression]>] paramList = \parseParameterList;
               .ifInvocation = *([[DainaExpression][List<[DainaExpression]>]->] get) {\get methodExpr paramList};
            } *{
               \parser:addError (\[Error]:expectingMethodToInvoke (\parser:position)); 
            };
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:asteriskArrow)) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
            [DainaExpression] expr = \[DainaExpression]:base;
            \expr:parse parser;
            .ifProxyObject = *([[DainaExpression]->] get) {\get expr};
         } *{
            \parser:addError (\[Error]:expectingProxyObject (\parser:position)); 
         };
      } *{};
      \[O]:ifElse (\[DainaCompilerInjection]:isFirstToken token1) *{
         [DainaCompilerInjection] inj = \[DainaCompilerInjection]:base;
         \inj:parse parser;
         .ifCompilerInjection = *([[DainaCompilerInjection]->] get) {\get inj};
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:roundBracketOpen)) *{
         \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] expr = \[DainaExpression]:base;
               \expr:parse parser;
               \:copy expr;
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForExpression (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingExpression (\parser:position));
            };
      } *{};
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken token1) *{
         [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
         \identifier:parse parser;
         .ifLocalObject = *([[DainaGeneralIdentifier]->] get) {\get identifier};
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:caret)) *{
         \parser:gotoNextToken;
         .ifSelfReference = *([->] get) {\get};
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:asteriskCaret)) *{
         \parser:gotoNextToken;
         .ifMethodSelfReference = *([->] get) {\get};
      } *{};

      @@\[O]:ifElse (\parser:hasErrors) *{} *{
         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:exclamationMark) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] left = \[DainaExpression]:base;
               \:copyTo left;
               [DainaExpression] right = \[DainaExpression]:base;
               \right:parse parser;
               \:toBase;
               .ifWithPrologueStatement = *([[DainaExpression][DainaExpression]->] get) {\get left right};
            } *{
               \parser:addError (\[Error]:expectingPrologueStatement (\parser:position));
            };
         } *{};
      };@@
   }
}




[DainaClass] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaDependancyStructure,
         DainaExpression,
         Variable,
         DainaClassIdentifier,
         DainaGenericDeclarationList,
         DainaType,
         DainaObjectDeclaration,
         DainaClassMethod,
         DainaCompilerInjection,

         Debug
      )
   [Variable<[Boolean]>] isEntryPointClass
   [DainaDependancyStructure] dependancyStructure
   [DainaExpression] entryPointMethod
   [DainaClassIdentifier] className
   [DainaGenericDeclarationList] genericDeclarationList
   [List<[DainaType]>] inheritedParentTypes
   [List<[DainaObjectDeclaration]>] instanceObjects
   [List<[DainaClassMethod<[DainaExpression]>]>] classMethods
   [List<[DainaCompilerInjection]>] compilerInjections
{
   :: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
      [List<[DainaClass]>] classes = \[List<[DainaClass]>]:empty;
      \[Loops]:until *([->] stop) {
         \[O]:ifElse (\[DainaClass]:isFirstToken (\parser:token)) *{
            [DainaClass] class = \[DainaClass]:base;
            \class:parse parser;
            \classes:append class;
            @\[O]:ifElse (\parser:hasErrors) stop *{};
         } *{  
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:EOF) *{} *{
               \parser:addError (\[Error]:expectingClassAtTopLevel (\parser:position));
            };
            \stop;
         };
      };

      @@\[Loops]:while (*->[Boolean]{[Token] token = \parser:token;}->\[Boolean]:not (\[Token]:equals token (\[Token]:EOF))) *{
         [Token] token = \parser:token;
         \[Debug]:log (\token:asDebugString);
         \[Debug]:log (\[String]:as ##\n##);
         \parser:gotoNextToken;
      }@@
   } -> classes

   ++ isEntryPointOrRegularClass *([[DainaDependancyStructure][DainaExpression]->] getEntryPoint, [[DainaClassIdentifier][List<[DainaType]>][List<[DainaObjectDeclaration]>][List<[DainaClassMethod<[DainaExpression]>]>][List<[DainaCompilerInjection]>]->] getRegularClass) {
      \[O]:ifElse (\.isEntryPointClass:get) *{
         \getEntryPoint .dependancyStructure .entryPointMethod;
      } *{
         \getRegularClass .className .inheritedParentTypes .instanceObjects .classMethods .compilerInjections;
      };
   }

   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:squareBracketOpen)

   ~ base *{
      .isEntryPointClass = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      .dependancyStructure = \[DainaDependancyStructure]:base;
      .entryPointMethod = \[DainaExpression]:base;
      .className = \[DainaClassIdentifier]:base;
      .genericDeclarationList = \[DainaGenericDeclarationList]:base;
      .inheritedParentTypes = \[List<[DainaType]>]:empty;
      .instanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
      .classMethods = \[List<[DainaClassMethod<[DainaExpression]>]>]:empty;
      .compilerInjections = \[List<[DainaCompilerInjection]>]:empty;
   }

   ++ parse *([Parser] parser) {
      \parser:gotoNextToken;
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
         \.isEntryPointClass:set (\[Boolean]:true);
         \parser:gotoNextToken;
         \.dependancyStructure:parse parser;
         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               \.entryPointMethod:parse parser;
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
                  \parser:gotoNextToken;
               } *{  
                  \parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingEntryPointMethod (\parser:position));  
            };
         } *{
            \parser:addError (\[Error]:expectingBodyOfClass (\parser:position)); 
         };
      } *{  
         \[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
            \.className:parse parser;
            \.genericDeclarationList:parse parser;
            \[Loops]:until *([->] stop) {
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
                  \parser:gotoNextToken;
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
                     [DainaType] parentType = \[DainaType]:base;
                     \parentType:parse parser;
                     \.inheritedParentTypes:append parentType;
                  } *{  
                     \parser:addError (\[Error]:expectingParentType (\parser:position));
                     \stop;
                  };
               } stop;
            };
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
               \parser:gotoNextToken;
               \.dependancyStructure:parse parser;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
                     [DainaObjectDeclaration] instanceObject = \[DainaObjectDeclaration]:base;
                     \instanceObject:parse parser;
                     \.instanceObjects:append instanceObject;
                  } stop;
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
                  \parser:gotoNextToken;
                  \[Loops]:until *([->] stop) {
                     \[O]:ifElse (\[DainaClassMethod<[DainaExpression]>]:isFirstToken (\parser:token)) *{
                        [DainaClassMethod<[DainaExpression]>] classMethod = \[DainaClassMethod<[DainaExpression]>]:base ([DainaExpression]:base) (*([Parser] parser, [DainaExpression] e){\e:parse parser}) ([DainaExpression]:isFirstToken);
                        \classMethod:parse parser;
                        \classMethod:isInstanceTypeOrConstructor *{} *{} *{
                           [DainaType] classType = \[DainaType]:base;
                           \classType:setAsClassName .className;
                           [DainaExpression] methodExpression = \classMethod:methodExpression;
                           \methodExpression:setOutputType classType;
                        };
                        \.classMethods:append classMethod;
                     } *{
                        \[O]:ifElse (\[DainaCompilerInjection]:isFirstToken (\parser:token)) *{
                           [DainaCompilerInjection] compilerInjection = \[DainaCompilerInjection]:base;
                           \compilerInjection:parse parser;
                           \.compilerInjections:append compilerInjection;
                        } stop;
                     };
                  };
                  \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
                     \parser:gotoNextToken;
                  } *{  
                     \parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
                  };
               } *{
                  \parser:addError (\[Error]:expectingBodyOfClass (\parser:position));
               };
            } *{  
               \parser:addError (\[Error]:expectingClosingSquareBracketAfterClassHeader (\parser:position));
            };
         } *{
            \parser:addError (\[Error]:expectingClassName (\parser:position));   
         }; 
      };
   }
}








[DLangSynthesizer] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaDependancyStructure,
         DainaExpression,
         Variable,
         DainaClassIdentifier,
         DainaGenericDeclarationList,
         DainaType,
         DainaObjectDeclaration,
         DainaClassMethod,
         DainaCompilerInjection,
         DainaClass,
         Integer,
         DainaGeneralIdentifier,
         Mapping,
         Debug
      )
   [[Data]->] output
   [Integer] tab
   [Boolean] blockOutput
   [Mapping<[String][DainaClass]>] mappedClasses
   [Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>] mappedClassMethods
   [DainaClassIdentifier] selfClassName
   [List<[DainaObjectDeclaration]>] selfInstanceObjects
   [Integer] temporaryNumber
   [DainaType] synthesizedExpressionType
   [Mapping<[String][DainaType]>] localObjectScope
{
   ~ to *([[Data]->] output) {
      .tab = \[Integer]:as ##0##;
      .output = output;
      .mappedClasses = \[Mapping<[String][DainaClass]>]:empty;
      .mappedClassMethods = \[Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>]:empty;
      .temporaryNumber = \[Integer]:as ##0##;
      .selfClassName = \[DainaClassIdentifier]:base;
      .synthesizedExpressionType = \[DainaType]:base;
      .selfInstanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
      .localObjectScope = \[Mapping<[String][DainaType]>]:empty;
      .blockOutput = \[Boolean]:false;
   }

   - outputNextTemporaryVariableName *{
      .temporaryNumber = \.temporaryNumber:adding (\[Integer]:as ##1##);
      \:output (\[String]:as ##temp##);
      \:output (\[String]:stringFormatOf .temporaryNumber);
   }

   - output *([String] string) {
      \[O]:ifElse .blockOutput *{} *{
         \.output \string:ascii;
      };
   }

   - outputTabbed *([String] string) {
      \[O]:ifElse .blockOutput *{} *{
         \[Loops]:iterate ([:[Sequence<[Natural]>]] { 
            |++ length *->(\[Natural]:magnitudeOf .tab)
            |++ atIndex *(i)->\[Maybe<[?]>]:as i
         }) *{
            [String] tab = (\[String]:as ##   ##);
            \.output \tab:ascii;
         };
         \.output \string:ascii;
      };
   }

   - incrementTab *{
      .tab = \.tab:adding (\[Integer]:as ##1##);
   }

   - decrementTab *{
      .tab = \.tab:subtracting (\[Integer]:as ##1##);
   }

   - iterateUnoverridenInstanceMethods *([DainaClass] class, [[Integer][DainaClassMethod<[DainaExpression]>]->] get) {
      \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
      } *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {{
         [Variable<[Integer]>] varParentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
         \[Loops]:iterate inheritedParentTypes *([] _, [DainaType] parentType) {
            [Integer] parentNumber = \varParentNumber:get;
            \varParentNumber:set (\parentNumber:adding (\[Integer]:as ##1##));
            \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
               [String] parentID = (\parentTypeIdentifier:content);
               \.mappedClasses:retriveMappedValueWithKey parentID *([DainaClass] parentClass) {
                  \:iterateUnoverridenInstanceMethods parentClass *([Integer] i, [DainaClassMethod<[DainaExpression]>]c) {
                     \getIfNotOverriden parentNumber c;
                  };
                  \parentClass:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
                  } *([DainaClassIdentifier] a1, [List<[DainaType]>] a2, [List<[DainaObjectDeclaration]>] a3, [List<[DainaClassMethod<[DainaExpression]>]>] parentClassMethods, [List<[DainaCompilerInjection]>] a5) {
                     \[Loops]:iterate parentClassMethods *([] _, [DainaClassMethod<[DainaExpression]>] parentClassMethod) {
                        \getIfNotOverriden parentNumber parentClassMethod;
                     };
                  };
               };    
            };
         };

      } !{
            [[Integer][DainaClassMethod<[DainaExpression]>]->] getIfNotOverriden = *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] parentMethod) {
               [DainaGeneralIdentifier] parentMethodIdentifier = \parentMethod:identifier;
               \.mappedClassMethods:retriveMappedValueWithKey (\className:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] ownClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] ifOverriden = \ownClassMethods:maybeRetriveMappedValueWithKey (\parentMethodIdentifier:content);
                  \ifOverriden:isOrElse *{} *{
                     \get parentNumber parentMethod;
                  };
               };
            };
         }};
   }

   - iterateUnoverridenInstanceMethodsAnon *([List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaType]>] inheritedParentTypes, [[Integer][DainaClassMethod<[DainaExpression]>]->] get) {{
      
         [Variable<[Integer]>] varParentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            [Integer] parentNumber = \varParentNumber:get;
            \varParentNumber:set (\parentNumber:adding (\[Integer]:as ##1##));
            \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
               [String] parentID = (\parentTypeIdentifier:content);
               \.mappedClasses:retriveMappedValueWithKey parentID *([DainaClass] parentClass) {
                  \:iterateUnoverridenInstanceMethods parentClass *([Integer] i, [DainaClassMethod<[DainaExpression]>]c) {
                     \getIfNotOverriden parentNumber c;
                  };
                  \parentClass:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
                  } *([DainaClassIdentifier] a1, [List<[DainaType]>] a2, [List<[DainaObjectDeclaration]>] a3, [List<[DainaClassMethod<[DainaExpression]>]>] parentClassMethods, [List<[DainaCompilerInjection]>] a5) {
                     \parentClassMethods:iterate *([DainaClassMethod<[DainaExpression]>] parentClassMethod) {
                        \getIfNotOverriden parentNumber parentClassMethod;
                     };
                  };
               };    
            };
         };

      
   }  !{
            [Mapping<[String][DainaClassMethod<[DainaExpression]>]>] ownClassMethods = \[Mapping<[String][DainaClassMethod<[DainaExpression]>]>]:empty;
            \classMethods:iterate *([DainaClassMethod<[DainaExpression]>] classMethod) {
               [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
               \ownClassMethods:mapKeyToValue (\classMethodIdentifier:content) classMethod;
            };
            [[Integer][DainaClassMethod<[DainaExpression]>]->] getIfNotOverriden = *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] parentMethod) {
               [DainaGeneralIdentifier] parentMethodIdentifier = \parentMethod:identifier;
               [Maybe<[DainaClassMethod<[DainaExpression]>]>] ifOverriden = \ownClassMethods:maybeRetriveMappedValueWithKey (\parentMethodIdentifier:content);
               \ifOverriden:isOrElse *{} *{
                  \get parentNumber parentMethod;
               };
            };
         }  }


   

   ++ synthesizeClasses *([List<[DainaClass]>] classes) {
      \classes:iterate *([DainaClass] class) {
         \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
         } *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
            \.mappedClasses:mapKeyToValue (\className:content) class;
            [Mapping<[String][DainaClassMethod<[DainaExpression]>]>] classMethodsMapping = \[Mapping<[String][DainaClassMethod<[DainaExpression]>]>]:empty;
            \classMethods:iterate *([DainaClassMethod<[DainaExpression]>] classMethod) {
               [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
               \classMethodsMapping:mapKeyToValue (\classMethodIdentifier:content) classMethod;
            };
            \.mappedClassMethods:mapKeyToValue (\className:content) classMethodsMapping;
         }; 
      };
      \:output (\[String]:as ##/* *** HEADER *** */\n##);
      \:output (\[String]:as ##interface OBJECT {}\n##);
      \:output (\[String]:as ##class WRAP(E) : OBJECT { E it; this(E v) {this.it = v;} }\n##);
      \:output (\[String]:as ##interface LAMBDA {\n   OBJECT method(OBJECT caller, OBJECT[] parameters);\n}\n\n##);
      \classes:iterate :synthesizeClass;
   }

   - synthesizeClass *([DainaClass] class) {
      \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
         \:output (\[String]:as ##/* *** ENTRY POINT CLASS *** */\n##);
         \:output (\[String]:as ##void main() { ENTRY_POINT_CLASS.entryPointMethod(null, []); }\n##); 
         \:output (\[String]:as ##class ENTRY_POINT_CLASS {\n##);
         \:output (\[String]:as ##   static OBJECT entryPointMethod(OBJECT caller, OBJECT[] parameters) {\n##); \:incrementTab; \:incrementTab;
         \:synthesizeMethodBodyContent entryPointMethod; 
         \:decrementTab; \:decrementTab; \:output (\[String]:as ##   }\n}\n\n##);
      } *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
         .selfClassName = className;
         .selfInstanceObjects = instanceObjects;
         \:output (\[String]:as ##/* *** CLASS: ##);
         \:output (\className:content);
         \:output (\[String]:as ## *** */\n##);
         \:output (\[String]:as ##interface CLASSTYPE_##);
         \:output (\className:content);
         \:output (\[String]:as ## : OBJECT, LAMBDA##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            \:output (\[String]:as ##, ##);
            \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
               \:output (\[String]:as ##CLASSTYPE_##);
               \:output (\parentTypeIdentifier:content);
            };
         };
         \:output (\[String]:as ## {\n##); \:incrementTab;
         \classMethods:iterate :synthesizeClassMethodInterface;
         \:decrementTab; \:output (\[String]:as ##}\n##);
         \:output (\[String]:as ##class CLASSIMPL_##);
         \:output (\className:content);
         \:output (\[String]:as ## : CLASSTYPE_##);
         \:output (\className:content);
         \:output (\[String]:as ## {\n##); \:incrementTab;
         \compilerInjections:iterate *([DainaCompilerInjection] compilerInjection) {
            [String] dlang = \[String]:as ##dlang##;
            \[O]:ifElse (\dlang:isEqualTo (\compilerInjection:identifierString)) *{
               \:output (\[String]:as ##/* dlang injection start */##);
               \:output (\compilerInjection:dataSegment);
               \:output (\[String]:as ##/* dlang injection end */\n##);
            } *{
               \:outputTabbed (\[String]:as ##ERROR UNKNOWN INJECTION!!!\n##);
            };
         };
         \:outputTabbed (\[String]:as ##override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n##);
         [Variable<[Integer]>] parentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            [Integer] curr = \parentNumber:get;
            \:synthesizeParentObjectDeclaration curr parentType;
            \parentNumber:set (\curr:adding (\[Integer]:as ##1##));
         };
         \instanceObjects:iterate :synthesizeInstanceObjectDeclaration;
         \:iterateUnoverridenInstanceMethods class (:synthesizeParentUnoverridenMethod);
         \classMethods:iterate :synthesizeClassMethodImplementation;
         \:decrementTab; \:output (\[String]:as ##}\n\n##);
      };
   }

   - synthesizeInstanceObjectDeclaration *([DainaObjectDeclaration] instanceObject) {
      \:outputTabbed (\[String]:as ##private OBJECT IOBJECT_##);
      [DainaGeneralIdentifier] instanceObjectIdentifier = \instanceObject:identifier;
      \:output (\instanceObjectIdentifier:content);
      \:output (\[String]:as ## = null;\n##);
   }

   - synthesizeParentObjectDeclaration *([Integer] parentNumber, [DainaType] parentType) {
      \:outputTabbed (\[String]:as ####);
      \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\parentTypeIdentifier:content);
      };
      \:output (\[String]:as ## ##);
      \:output (\[String]:as ##PARENT_##);
      \:output (\[String]:stringFormatOf parentNumber);
      \:output (\[String]:as ## = new ##);
      \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\parentTypeIdentifier:content);
      };
      \:output (\[String]:as ##();\n##);
   }

   - synthesizeParentUnoverridenMethod *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] unoverridenMethod) {
      \unoverridenMethod:isInstanceTypeOrConstructor *{
         [DainaGeneralIdentifier] unoverridenMethodIdentifier = \unoverridenMethod:identifier;
         \:outputTabbed (\[String]:as ##override OBJECT IMETHOD_##);
         \:output (\unoverridenMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters) { return PARENT_##);
         \:output (\[String]:stringFormatOf parentNumber);
         \:output (\[String]:as ##.IMETHOD_##);
         \:output (\unoverridenMethodIdentifier:content);
         \:output (\[String]:as ##(caller, parameters); }\n##);
      } *{} *{};
   }


   - synthesizeClassMethodInterface *([DainaClassMethod<[DainaExpression]>] classMethod) {
      [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
      \classMethod:isInstanceTypeOrConstructor *{
         \:outputTabbed (\[String]:as ##OBJECT IMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters);\n##);
      } *{
      } *{
         @@\:outputTabbed (\[String]:as ##OBJECT CMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters);\n##);@@
      };
   }

   - synthesizeClassMethodImplementation *([DainaClassMethod<[DainaExpression]>] classMethod) {
      [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
      \[O]:ifElse (\classMethod:isUnimplementedMethod) *{
         \:outputTabbed (\[String]:as ##private LAMBDA ASSIGNIMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ## = null;\n##);
      } *{};
      \classMethod:isInstanceTypeOrConstructor *{
         \:outputTabbed (\[String]:as ##override OBJECT IMETHOD_##);
      } *{
         \:outputTabbed (\[String]:as ##static OBJECT TMETHOD_##);
      } *{
         \:outputTabbed (\[String]:as ##static OBJECT TMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters) { ##);
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\.selfClassName:content);
         \:output (\[String]:as ## newInstance = new ##);
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\.selfClassName:content);
         \:output (\[String]:as ##(); return newInstance.CMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(newInstance, parameters); }\n##);
         \:outputTabbed (\[String]:as ##OBJECT CMETHOD_##);
      };
      \:output (\classMethodIdentifier:content);
      \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters)##);
      \:output (\[String]:as ## {\n##); \:incrementTab;
      \:outputTabbed (\[String]:as ##CLASSTYPE_##);
      \:output (\.selfClassName:content);
      \:output (\[String]:as ## self = ##);
      \:output (\[String]:as ##cast(##);
      \:output (\[String]:as ##CLASSTYPE_##);
      \:output (\.selfClassName:content);
      \:output (\[String]:as ##)caller##);
      \:output (\[String]:as ##;\n##);
      \[O]:ifElse (\classMethod:isUnimplementedMethod) *{
         \:outputTabbed (\[String]:as ##return ASSIGNIMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##.method(caller, parameters);\n##);
      } *{
         \:synthesizeMethodBodyContent (\classMethod:methodExpression);
      };
      \:decrementTab; \:outputTabbed (\[String]:as ##}\n##);
   }


   - pushScope *([List<[DainaObjectDeclaration]>] parameters) {
      [Variable<[Integer]>] paramNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##0##);
      [Integer] one = \[Integer]:as ##1##;
      \parameters:iterate *([DainaObjectDeclaration] parameter) {
         \:addLocalObjectToScope parameter;
         [DainaGeneralIdentifier] id = \parameter:identifier;
         \:outputTabbed (\[String]:as ##OBJECT LOBJECT_##);
         \:output (\id:content);
         \:output (\[String]:as ## = parameters.length > ##);
         \:output (\[String]:stringFormatOf (\paramNumber:get));
         \:output (\[String]:as ## ? parameters[##);
         \:output (\[String]:stringFormatOf (\paramNumber:get));
         \:output (\[String]:as ##] : null;\n##);
         \paramNumber:set (\one:adding (\paramNumber:get));
      };
   }

   - popScope *{
      
   }

   - pushPrologueScope *{

   }

   - pushPrelogueScopeAfterPrologue *{

   }

   - popPrelogueAndPrologueScope *{

   }

   - addLocalObjectToScope *([DainaObjectDeclaration] localObject) {
      [DainaGeneralIdentifier] id = \localObject:identifier;
      \.localObjectScope:mapKeyToValue (\id:content) (\localObject:type);
   }

   - getLocalObjectType *([DainaGeneralIdentifier] localObjectIdentifier) -> [DainaType] {
      [Variable<[DainaType]>] ret = \[Variable<[DainaType]>]:as (\[DainaType]:base);
      \.localObjectScope:retriveMappedValueWithKey (\localObjectIdentifier:content) (ret:set);
   } -> \ret:get


   - synthesizeMethodBodyContent *([DainaExpression] methodExpression) {
      \[O]:selectOrDefault *([->] select) {
         \methodExpression:ifMethodExpression *([List<[DainaObjectDeclaration]>] inputs, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
            \select;
            \:pushScope inputs; 
            \:synthesizeStatement body (\[Boolean]:true);
            \output:isOrElse *{} *{
               \:outputTabbed (\[String]:as ##return caller;\n##);
            };
            \output:isOrElse *([DainaExpression] outputExpression) {
               \:outputTabbed (\[String]:as ##return ##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  outputExpression;
               \:output (\[String]:as ##;\n##);
            } *{};
            \:popScope;
         };
      } *{
         \:outputTabbed (\[String]:as ##return (cast(LAMBDA)##);
         \:synthesizeInPlaceExpression (\[Boolean]:false)  methodExpression;
         \:output (\[String]:as ##).method(caller, []);\n##);
      };
   }

   - synthesizeStatement *([DainaExpression] statement, [Boolean] baseStatement) {
      \[O]:selectOrDefault *([->] select) {
         \statement:ifStatementGroup *([List<[DainaExpression]>] statements) {
            \select;
            \[O]:ifElse baseStatement *{} *{
               \:pushScope (\[List<[DainaObjectDeclaration]>]:empty); 
               \:outputTabbed (\[String]:as ##{\n##);
               \:incrementTab;
            };
            \statements:iterate *([DainaExpression] subStatement) {
               \:synthesizeStatement subStatement (\[Boolean]:false);
            };
            \[O]:ifElse baseStatement *{} *{
               \:decrementTab;
               \:outputTabbed (\[String]:as ##}\n##);
               \:popScope;
            };
         };
         \statement:ifWithPrologueStatement *([DainaExpression] prelogueStatement, [DainaExpression] prologueStatement) {
            \select;
            \:pushPrologueScope;
            \:synthesizeStatement prologueStatement (\[Boolean]:true);
            \:pushPrelogueScopeAfterPrologue;
            \:synthesizeStatement prelogueStatement (baseStatement);
            \:popPrelogueAndPrologueScope;
         };
         \statement:ifLocalObjectAssignment *([DainaObjectDeclaration] declaration, [DainaExpression] assginedExpression) {
            \select;
            \[O]:selectOrDefault *([->] _select) {
               \assginedExpression:ifCompilerInjection *([DainaCompilerInjection] compilerInjection) {
                  \_select;
                  [String] dlang = \[String]:as ##dlang##;
                  \[O]:ifElse (\dlang:isEqualTo (\compilerInjection:identifierString)) *{
                     \:output (\[String]:as ##/* dlang injection start */##);
                     \:output (\compilerInjection:dataSegment);
                     \:output (\[String]:as ##/* dlang injection end */\n##);
                  } *{
                     \:outputTabbed (\[String]:as ##ERROR UNKNOWN INJECTION!!!\n##);
                  };
               };
            } *{
               [String] nothing = \[String]:as ####;
               [DainaGeneralIdentifier] identifier = \declaration:identifier;
               \:outputTabbed (\[String]:as ####);
               \[O]:ifElse (\nothing:isEqualTo (\identifier:content)) *{} *{
                  \:addLocalObjectToScope declaration;
                  \:output (\[String]:as ##OBJECT LOBJECT_##);
                  \:output (\identifier:content);
                  \:output (\[String]:as ## = ##);
               };
               \:synthesizeInPlaceExpression (\[Boolean]:false)  assginedExpression;
               \:output (\[String]:as ##;\n##);
            };
         };
         \statement:ifInvocation *([] a, [] b) {
            \select;
            \:outputTabbed (\[String]:as ####);
            \:synthesizeInPlaceExpression (\[Boolean]:false)  statement;
            \:output (\[String]:as ##;\n##);
         };
         \statement:ifInstanceMethodAssignment *([DainaGeneralIdentifier] identifier, [DainaExpression] assignedExpression) {
            \select;
            \:outputTabbed (\[String]:as ##ASSIGNIMETHOD_##);
            \:output (\identifier:content);
            \:output (\[String]:as ## = cast(LAMBDA)##);
            \:synthesizeInPlaceExpression (\[Boolean]:false)  assignedExpression;
            \:output (\[String]:as ##;\n##);
         };
         \statement:ifInstanceObjectAssignment *([DainaGeneralIdentifier] identifier, [DainaExpression] assignedExpression) {
            \select;
            \:outputTabbed (\[String]:as ##IOBJECT_##);
            \:output (\identifier:content);
            \:output (\[String]:as ## = ##);
            \:synthesizeInPlaceExpression (\[Boolean]:false)  assignedExpression;
            \:output (\[String]:as ##;\n##);
         };
         \statement:ifConstructorInvocation *([Integer] parentNumber, [DainaGeneralIdentifier] identifier, [Boolean] isPointerConstructor, [List<[DainaExpression]>] inputs) {
            \select;
            \[O]:ifElse (\parentNumber:isEqualTo (\[Integer]:as ##0##)) *{
               \[O]:ifElse isPointerConstructor *{
                  \:outputTabbed (\[String]:as ##caller = ##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##;\n##);
               } *{
                  \:outputTabbed (\[String]:as ##(cast(##);
                  \:output (\[String]:as ##CLASSIMPL_##);
                  \:output (\.selfClassName:content);
                  \:output (\[String]:as ##)##);
                  \:output (\[String]:as ##self).CMETHOD_##);
                  \:output (\identifier:content);
                  \:output (\[String]:as ##(this##);
                  \:output (\[String]:as ##, [##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##]);\n##);
               };
            } *{
               \:outputTabbed (\[String]:as ##PARENT_##);
               \:output (\[String]:stringFormatOf parentNumber);
               \[O]:ifElse isPointerConstructor *{
                  \:output (\[String]:as ## = ##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##;\n##);
               } *{
                  \:output (\[String]:as ##.CMETHOD_##);
                  \:output (\identifier:content);
                  \:output (\[String]:as ##(PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##, [##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##]);\n##);
               };
            };
         };
      } *{
         \:outputTabbed (\[String]:as ##INTERNAL STATEMENT ERROR!!!\n##);
      };
   }

   - synthesizeMethodInputs *([List<[DainaExpression]>] inputs) {
      [Variable<[String]>] seperator = \[Variable<[String]>]:as (\[String]:as ####);
      \inputs:iterate *([DainaExpression] input) {
         \:output (\seperator:get);
         \:synthesizeInPlaceExpression (\[Boolean]:false)  input;
         \seperator:set (\[String]:as ##, ##);
      };
   }

   - synthesizeInPlaceExpression *([Boolean] usedAsInstantMethod, [DainaExpression] expression) {
      .synthesizedExpressionType = \[DainaType]:base;
      \[O]:selectOrDefault *([->] select) {
         \expression:ifWithPrologueStatement *([DainaExpression] prelogue, [DainaExpression] prologue) {
            \select;
            \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
            \:incrementTab;
            \:synthesizeStatement prologue (\[Boolean]:true);
            \[O]:selectOrDefault *([->] selectInner) {
               \prelogue:ifStatementGroup *([] a) {
                  \selectInner;
                  \:synthesizeStatement prelogue (\[Boolean]:true);
                  \:outputTabbed (\[String]:as ##return caller;\n##);
               };
            } *{
               \:outputTabbed (\[String]:as ##return ##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  prelogue;
               \:output (\[String]:as ##;\n##);
            };
            \:decrementTab;
            \:outputTabbed (\[String]:as ##} }).method(caller, [])##);
         };
         \expression:ifLocalObject *([DainaGeneralIdentifier] identifier) {
            \select;
            \:output (\[String]:as ##LOBJECT_##);
            \:output (\identifier:content);
            .synthesizedExpressionType = \:getLocalObjectType identifier;
         };
         \expression:ifMethodExpression *([List<[DainaObjectDeclaration]>] params, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
            \select;
            \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
            \:incrementTab;
            \:synthesizeMethodBodyContent expression;
            \:decrementTab;
            \:outputTabbed (\[String]:as ##} })##);
            [DainaType] outputType = .synthesizedExpressionType;
            .synthesizedExpressionType = \[DainaType]:base;
            \.synthesizedExpressionType:setAsMethodWithOutputType (\expression:outputType);
         };
         \expression:ifInstanceMethod *([DainaExpression] instanceExpression, [DainaGeneralIdentifier] identifier) {
            \select;
            [Variable<[DainaType]>] instanceExpressionType = \[Variable<[DainaType]>]:as .synthesizedExpressionType;
            \[O]:ifElse (usedAsInstantMethod) *{
               \:output (\[String]:as ##(cast(##);
               .blockOutput = \[Boolean]:true;
               \:synthesizeInPlaceExpression (\[Boolean]:false)  instanceExpression;
               .blockOutput = \[Boolean]:false;
               \instanceExpressionType:set .synthesizedExpressionType;
               \.synthesizedExpressionType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] instanceExpressionClassName, [List<[DainaType]>] insta) {
                  \:output (\[String]:as ##CLASSTYPE_##);
                  \:output (\instanceExpressionClassName:content);
               };
               \:output (\[String]:as ##)##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  instanceExpression;
               \:output (\[String]:as ##).IMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(caller##);
            } *{
               \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
               \:incrementTab;
               \:outputTabbed (\[String]:as ##OBJECT instance = ##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  instanceExpression;
               \:output (\[String]:as ##;\n##);
               \:outputTabbed (\[String]:as ##return (cast(##);
               \instanceExpressionType:set .synthesizedExpressionType;
               \.synthesizedExpressionType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] instanceExpressionClassName, [List<[DainaType]>] insta) {
                  \:output (\[String]:as ##CLASSTYPE_##);
                  \:output (\instanceExpressionClassName:content);
               };
               \:output (\[String]:as ##)instance).IMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(instance, parameters);\n##);
               \:decrementTab;
               \:outputTabbed (\[String]:as ##} })##);
            };
            [DainaType] theinstanceExpressionType = \instanceExpressionType:get;
            \theinstanceExpressionType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] instanceExpressionClassName, [List<[DainaType]>] insta) {
               \.mappedClassMethods:retriveMappedValueWithKey (\instanceExpressionClassName:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] instanceExpressionClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] mInvokedMethod = \instanceExpressionClassMethods:maybeRetriveMappedValueWithKey (\identifier:content);
                  \mInvokedMethod:isOrElse *([DainaClassMethod<[DainaExpression]>] invokedMethod) {
                     \[O]:ifElse (\invokedMethod:isUnimplementedMethod) *{
                        .synthesizedExpressionType = \invokedMethod:unimplementedType;
                     } *{
                        [DainaExpression] methodExpression = \invokedMethod:methodExpression;
                        .synthesizedExpressionType = \[DainaType]:base;
                        \.synthesizedExpressionType:setAsMethodWithOutputType (\methodExpression:outputType);
                     };
                  } *{};
               };
            };
         };
         \expression:ifTypeMethod *([DainaType] type, [DainaGeneralIdentifier] identifier) {
            \select;
            \[O]:ifElse (usedAsInstantMethod) *{
               \type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
                  \:output (\[String]:as ##CLASSIMPL_##);
                  \:output (\typeIdentifier:content);
                  \:output (\[String]:as ##.##);
               };
               \:output (\[String]:as ##TMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(caller##);
            } *{
               \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
               \:incrementTab;
               \:outputTabbed (\[String]:as ##return ##);
               \type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
                  \:output (\[String]:as ##CLASSIMPL_##);
                  \:output (\typeIdentifier:content);
                  \:output (\[String]:as ##.##);
               };
               \:output (\[String]:as ##TMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(caller, parameters);\n##);
               \:decrementTab;
               \:outputTabbed (\[String]:as ##} })##);
            };
            \type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
               \.mappedClassMethods:retriveMappedValueWithKey (\typeIdentifier:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] typeExpressionClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] mInvokedMethod = \typeExpressionClassMethods:maybeRetriveMappedValueWithKey (\identifier:content);
                  \mInvokedMethod:isOrElse *([DainaClassMethod<[DainaExpression]>] invokedMethod) {
                     [DainaExpression] methodExpression = \invokedMethod:methodExpression;
                     .synthesizedExpressionType = \[DainaType]:base;
                     \.synthesizedExpressionType:setAsMethodWithOutputType (\methodExpression:outputType);
                  } *{};
               };
            };
         };
         \expression:ifInvocation *([DainaExpression] method, [List<[DainaExpression]>] params) {
            \select;
            [Variable<[Boolean]>] isInstantMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
            \method:ifTypeMethod *([DainaType] a, [DainaGeneralIdentifier] b) {\isInstantMethod:set (\[Boolean]:true)};
            \method:ifInternalInstanceMethod *([Integer] a, [DainaGeneralIdentifier] b) {\isInstantMethod:set (\[Boolean]:true)};
            @\method:ifInstanceMethod *([DainaExpression] a, [DainaGeneralIdentifier] b) {\isInstantMethod:set (\[Boolean]:true)};
            [Variable<[DainaType]>] invokedExpressionType = \[Variable<[DainaType]>]:as .synthesizedExpressionType;
            \[O]:ifElse (\isInstantMethod:get) *{
               \:synthesizeInPlaceExpression (\[Boolean]:true) method;
               \invokedExpressionType:set .synthesizedExpressionType;
               \:output (\[String]:as ##, cast(OBJECT[])[##);
               \:synthesizeMethodInputs params;
               \:output (\[String]:as ##])##);
            } *{
               \:output (\[String]:as ##(cast(LAMBDA)##);
               \:synthesizeInPlaceExpression (\[Boolean]:false) method;
               \invokedExpressionType:set .synthesizedExpressionType;
               \:output (\[String]:as ##).method(caller, cast(OBJECT[])[##);
               \:synthesizeMethodInputs params;
               \:output (\[String]:as ##])##);
            };
            [DainaType] _invokedExpressionType = \invokedExpressionType:get;
            \_invokedExpressionType:ifMethodInputsAndOutput *([List<[DainaType]>] asd,[Maybe<[DainaType]>] MoutputType) {
               \MoutputType:isOrElse *([DainaType] outputType) {
                  .synthesizedExpressionType = outputType;
               } *{};
            };
         };
         \expression:ifProxyObject *([DainaExpression] object) {
            \select;
            \:synthesizeInPlaceExpression (\[Boolean]:false)  object;
         };
         \expression:ifInternalInstanceMethod *([Integer] parentNumber, [DainaGeneralIdentifier] identifier) {
            \select;
            \[O]:ifElse (usedAsInstantMethod) *{
               \[O]:ifElse (\parentNumber:isEqualTo (\[Integer]:as ##0##)) *{
                  \:output (\[String]:as ##self.IMETHOD_##);
               } *{
                  \:output (\[String]:as ##PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##.IMETHOD_##);
               };
               \:output (\identifier:content);
               \:output (\[String]:as ##(self##);
            } *{
               \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
               \:incrementTab;
               \[O]:ifElse (\parentNumber:isEqualTo (\[Integer]:as ##0##)) *{
                  \:outputTabbed (\[String]:as ##OBJECT instance = self;\n##);
                  \:outputTabbed (\[String]:as ##return self.IMETHOD_##);
               } *{
                  \:outputTabbed (\[String]:as ##OBJECT instance = PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##;\n##);
                  \:outputTabbed (\[String]:as ##return PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##.IMETHOD_##);
               };
               \:output (\identifier:content);
               \:output (\[String]:as ##(instance, parameters);\n##);
               \:decrementTab;
               \:outputTabbed (\[String]:as ##} })##);
            };
            \.mappedClassMethods:retriveMappedValueWithKey (\.selfClassName:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] typeExpressionClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] mInvokedMethod = \typeExpressionClassMethods:maybeRetriveMappedValueWithKey (\identifier:content);
                  \mInvokedMethod:isOrElse *([DainaClassMethod<[DainaExpression]>] invokedMethod) {
                     \[O]:ifElse (\invokedMethod:isUnimplementedMethod) *{
                        .synthesizedExpressionType = \invokedMethod:unimplementedType;
                     } *{
                        [DainaExpression] methodExpression = \invokedMethod:methodExpression;
                        .synthesizedExpressionType = \[DainaType]:base;
                        \.synthesizedExpressionType:setAsMethodWithOutputType (\methodExpression:outputType);
                     };
                  } *{};
               };
         };
         \expression:ifInternalInstanceObject *([DainaGeneralIdentifier] instanceObjectIdentifier) {
            \select;
            \:output (\[String]:as ##IOBJECT_##);
            \:output (\instanceObjectIdentifier:content);
            [String] instanceObjectIdentifierString = \instanceObjectIdentifier:content;
            \.selfInstanceObjects:iterate *([DainaObjectDeclaration] decl) {
               [DainaGeneralIdentifier] thisId = \decl:identifier;
               \[O]:ifElse (\instanceObjectIdentifierString:isEqualTo (\thisId:content)) *{
                  .synthesizedExpressionType = \decl:type;
               } *{};
            };
         };
         \expression:ifSelfReference * {
            \select;
            \:output (\[String]:as ##caller##);
         };
         \expression:ifDataSegment *([String] dataSegmentContent) {
            \select;
            \:output (\[String]:as ##new WRAP!(string)(\"##);
            \:output (dataSegmentContent);
            \:output (\[String]:as ##\")##);
         };
         \expression:ifAnonymousClassObject *([List<[DainaType]>] parents, [List<[DainaExpression]>] constructor, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods) {
            \select;
            [DainaClassIdentifier] originalClassName = .selfClassName;
            \:output (\[String]:as ##((){\n##);
            \:incrementTab;
            [Variable<[Integer]>] parentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
            \parents:iterate *([DainaType] parentType) {
               [Integer] curr = \parentNumber:get;
               \:synthesizeParentObjectDeclaration curr parentType;
               \parentNumber:set (\curr:adding (\[Integer]:as ##1##));
               \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] a) {
                  .selfClassName = parentTypeIdentifier;
               };
            };

            \:outputTabbed (\[String]:as ##OBJECT caller;\n##);
            \:outputTabbed (\[String]:as ##OBJECT anonymousClassObject = ##);
            \:output (\[String]:as ##new class OBJECT, LAMBDA##);
            \parents:iterate *([DainaType] parentType) {
               \:output (\[String]:as ##, ##);
               \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
                  \:output (\[String]:as ##CLASSTYPE_##);
                  \:output (\parentTypeIdentifier:content);
               };
            };
            \:output (\[String]:as ## {\n##); \:incrementTab;
            \:outputTabbed (\[String]:as ##override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n##);
            \:iterateUnoverridenInstanceMethodsAnon classMethods parents (:synthesizeParentUnoverridenMethod);
            \classMethods:iterate :synthesizeClassMethodImplementation;
            \:decrementTab; \:outputTabbed (\[String]:as ##};\n##);

            
            \:outputTabbed (\[String]:as ##caller = anonymousClassObject;\n##);
            \:outputTabbed (\[String]:as ##CLASSTYPE_##);
            \:output (\.selfClassName:content);
            \:output (\[String]:as ## self = ##);
            \:output (\[String]:as ##cast(##);
            \:output (\[String]:as ##CLASSTYPE_##);
            \:output (\.selfClassName:content);
            \:output (\[String]:as ##)caller##);
            \:output (\[String]:as ##;\n##);
            \constructor:iterate *([DainaExpression] constructorStatement) {
               \:synthesizeStatement constructorStatement (\[Boolean]:false);
            };
            \:outputTabbed (\[String]:as ##return anonymousClassObject;\n##);
            \:decrementTab;
            \:outputTabbed (\[String]:as ##})()##);
            .selfClassName = originalClassName;
         };
      } *{
         \:output (\[String]:as ##<INTERNAL EXPRESSION ERROR!!!>##);
      };

      @[[->]->] ifMethodSelfReference
   }

   
}



[Daina :[CommandReader]] (
         Configuration, 
         OutputStream, 
         InputStream, 
         Loops, 
         Variable, 
         Boolean, 
         CommandReader, 
         String,
         Commands,
         Parser,
         Error,
         DainaClass,
         List,
         Maybe,
         DLangSynthesizer,

         Debug
      ) 
   [Configuration] configuration
   [Variable<[Boolean]>] exitReached
   [List<[DainaClass]>] parsedClasses
{

   :: run *([Configuration] configuration) {
      [Daina] daina = \[Daina]:init configuration;
      [Commands] commands = \[Commands]:from (configuration:commandInput);
      \[Loops]:while (*->(\[Boolean]:not \daina:exitReached)) *{
         \commands:readNext daina;
      };
   }
   
   ~ -+- init *([Configuration] configuration) {
      .exitReached = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      .configuration = configuration;
      .parsedClasses = \[List<[DainaClass]>]:empty;
   }

   -+- exitReached *->[Boolean]{}-> \.exitReached:get

   |++ exit *{
      \.exitReached:set (\[Boolean]:true);
      \[Debug]:log (\[String]:as ##Exit\n##);
   }

   |++ parseSourceFile *([String] path) {
      \[Debug]:log (\[String]:as ##parse from ##);
      \[Debug]:log path;
      \[Debug]:log (\[String]:as ##...\n##);
@[->[Maybe<[Byte]>]] == [InputStream]
      [Maybe<[InputStream]>] maybeSourceInput = \.configuration:sourceFileInput path;
      [Boolean] sourceFileSuccess = \maybeSourceInput:isOrElse (*([InputStream] sourceInput) -> [Boolean] {
         [Parser] parser = \[Parser]:withSourceNameAndInput path sourceInput;
         [List<[DainaClass]>] parsedClasses = \[DainaClass]:parseClasses parser;
         [List<[Error]>] errors = \parser:errors;
         [Boolean] parseSuccess = \(\[Integer]:as ##0##):isEqualTo (\errors:length);
         \parseSuccess:ifOrElse *{
            \parsedClasses:iterate *([DainaClass] parsedClass) {
               \.parsedClasses:append parsedClass;
            };
         } *{
            \errors:iterate *([Error] error) {
               \.configuration:outputError error;
            };
         };
      } -> \[Boolean]:true) (*->\[Boolean]:false);
      \sourceFileSuccess:ifOrElse *{} *{
         \.configuration:outputError (\[Error]:sourceFileNotAccessible path);
      };
   }

   |++ compileToFile *([String] path) {
      \[Debug]:log (\[String]:as ##compile to ##);
      \[Debug]:log path;
      \[Debug]:log (\[String]:as ##...\n##);

      [Maybe<[OutputStream]>] maybeOutputFile = \.configuration:compilationFileOutput path;
      \maybeOutputFile:isOrElse *{} *{
         \[Debug]:log (\[String]:as ##Can't output to file.\n##);
      };
      \maybeOutputFile:isOrElse *([OutputStream] outputFile) {
         [DLangSynthesizer] dlang = \[DLangSynthesizer]:to outputFile;
         \dlang:synthesizeClasses .parsedClasses;

         \[Debug]:log (\[String]:as ##Done!\n##);
      } *{};
      
   }

   |++ invalidCommand *{
      \[Debug]:log (\[String]:as ##Invalid command\n##);
   }

}


@@
Analysis: analysing class - InternalValue...
Analysis: analysing class - InternalPointer...
Analysis: analysing class - Object...
Analysis: analysing class - Variable...
Analysis: analysing class - InternalNonReleasingReference...
Analysis: analysing class - WeakReference...
Analysis: analysing class - Boolean...
Analysis: analysing class - Container...
Analysis: analysing class - TrainCarriage...
Analysis: analysing class - ControlFlowRecursiveConstructor...
Analysis: analysing class - ControlFlowRecursiveTransformer...
Analysis: analysing class - SingleMapping...
Analysis: analysing class - BinaryTree...
Analysis: analysing class - Byte...
Analysis: analysing class - Conjecture...
Analysis: analysing class - LambdaAToB...
Analysis: analysing class - Wrapper...
Analysis: analysing class - CoreFlow...
Analysis: analysing class - Train...
Analysis: analysing class - ControlFlow2...
Analysis: analysing class - Maybe...
Analysis: analysing class - List...
Analysis: analysing class - Sequence...
Analysis: analysing class - Sequences2...
Analysis: analysing class - Data...
Analysis: analysing class - SetObject...
Analysis: analysing class - Integer...
Analysis: analysing class - Natural...
Analysis: analysing class - ControlFlow...
Analysis: analysing class - String...
Analysis: analysing class - Token...
Analysis: analysing class - Loops...
**Analysis: analysing class - SourcePosition...
**Analysis: analysing class - Error...
Analysis: analysing class - MappingBucket...
Analysis: analysing class - Mapping...
**Analysis: analysing class - CommandReader...
**Analysis: analysing class - Character...
Analysis: analysing class - O...
Analysis: analysing class - M...
Analysis: analysing class - SocketPort...
Analysis: analysing class - InternalSocketHeader...
Analysis: analysing class - DataStream...
Analysis: analysing class - AutomaticallyClosingSocketLink...
Analysis: analysing class - OutputStream...
Analysis: analysing class - SocketLinkOutputStream...
Analysis: analysing class - InputStream...
Analysis: analysing class - SocketLinkInputStream...
Analysis: analysing class - SocketConnection...
Analysis: analysing class - SocketBinding...
Analysis: analysing class - AutomaticallyClosingInputFileDataStream...
Analysis: analysing class - AutomaticallyClosingOutputFileDataStream...
Analysis: analysing class - IPAddress...
Analysis: analysing class - SystemInputOutput...
**Analysis: analysing class - Configuration...
Analysis: analysing class - Debug...
Analysis: analysing class - Parser...
Analysis: analysing class - Commands...
Analysis: analysing class - DainaGeneralIdentifier...
Analysis: analysing class - DainaGenericDeclarationList...
Analysis: analysing class - DainaDependancyStructure...
Analysis: analysing class - DainaClassIdentifier...

*Analysis: analysing class - DainaType...
*Analysis: analysing class - DainaObjectDeclaration...
*Analysis: analysing class - DainaClassMethod...
*Analysis: analysing class - DainaCompilerInjection...
*Analysis: analysing class - DainaExpression...
*Analysis: analysing class - DainaClass...
*Analysis: analysing class - DLangSynthesizer...
*Analysis: analysing class - Daina...


@@


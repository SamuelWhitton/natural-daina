

[] (StandardIO, File, String, Byte, Data, List, Integer, Natural, Sequence, Boolean, Loops, Variable, Mapping, Maybe, SourcePosition, Error) {
   *{

      @[Maybe<[String]>] y1 = \[Maybe<[String]>]:nothing;
      @[Maybe<[String]>] y2 = \[Maybe<[String]>]:as \[String]:as ##Hello Worl!##;
      
      @\[SystemIO]:log \y1:isOrElse (*([String] s)->s) (*->nothingStr);
      @\[SystemIO]:log \y2:isOrElse (*([String] s)->s) (*->nothingStr);


      @@[Sequence<[Number]>] 5Times = [:[Sequence<[Number]>]] {
         |++ length *->\[Natural]:as ##5##
         |++ atIndex *(n)->\[Maybe<[?]>]:as n
      };
      \[Loops]:iterate 5Times *{
         \[SystemIO]:stdout \(\[String]:as ##Hello World!!\n##):ascii;
         \[SystemIO]:stdout \(\[String]:asASCII \[SystemIO]:stdin):ascii;
      };@@
      [SourcePosition] asdf = \[SourcePosition]:initialPositionIn (\[String]:as ##sadf/asdf/filenametest.h##) (\[String]:as ##This is a line....##);
      [SourcePosition] asdf2 = \asdf:startOfNextLine (\[String]:as ##This is a line2....##);
      [SourcePosition] asdf3 = \asdf2:startOfNextLine (\[String]:as ##This is a line3....##);
      [SourcePosition] asdf4 = \asdf3:nextColumn;


      \[StandardIO]:stdout \(\(\[Error]:expectingSecondHashForDataSegmentAnchor asdf4):description):ascii;
      \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;

      \[Loops]:iterate ([:[Sequence<[Natural]>]] {
         |++ length *->\[Natural]:as ##10##
         |++ atIndex *([Natural] n)->\[Maybe<[?]>]:as \n:adding \[Natural]:as ##300000238974289438900234##
      }) *([Natural] index, [Natural]value){
         \[StandardIO]:stdout \(\[String]:stringFormatOf value):ascii;
         \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;
      };
      
      @\(\[File]:atPath \[String]:as ##TestFiles/dlang_compiler_bootstrap_test.dai##):readContents (\[Natural]:as ##1000##) [StandardIO]:stdout;
      @[File] outputFile = (\[File]:atPath \[String]:as ##TestFiles/testwrite.txt##);
      @\outputFile:clearContents;
@@
      [List<[Byte]>] bytes = \[List<[Byte]>]:empty;
      \bytes:append \[Byte]:0x01;
      \bytes:append \[Byte]:0x21;
      \bytes:append \[Byte]:0xFF;
      [Data] dat = \[Data]:copy bytes;
      @\[StandardIO]:stdout \(\[String]:stringFormatOf (\bytes:length)):ascii;
      \outputFile:appendContents dat;
      @\outputFile:appendContents \(\[String]:as ##1000##):ascii;
      \(\outputFile:exists):ifOrElse *{
         \[StandardIO]:stdout \(\[String]:as ##Exists\n##):ascii;
      } *{
         \[StandardIO]:stdout \(\[String]:as ##NotExists\n##):ascii;
      };

      \outputFile:close;@@

   } @!{[String] nothingStr = \[String]:as ##<NOTHING>##}
}

[StandardIO] (String) {
      <<dlang ##
            import std.stdio;
            import std.bigint;
         ##

   :: stdout *([Data] data) {
      [] _ = <<dlang ##
            write(cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it));
         ##;
   }

   :: stdin *-> [Data] {
      [Data] readedData = \[Data]:empty;
      [] _ = << dlang ##
         string rawLine = readln();
         if (rawLine == null) {
            rawLine = "";
         }
         ubyte[] line = cast(ubyte[])(rawLine);
         (cast(CLASSIMPL_Data)LOBJECT_readedData).value = new WRAP!(ubyte[])(line);
      ##;
@chunks(stdin, 4096)
@
@foreach (ubyte[] buffer; chunks(stdin, 4096))
 @   {
  @      ... use buffer ...
  @  }
@
   } -> readedData


}

[File] (String, Natural, Data, Boolean) 
{
   <<dlang ##
         import std.stdio;
         import std.file;
         import std.bigint;
         string fileName = null;
         File file;
      ##

   ~ atPath *([String] filePath) {
      [Data] asciiFilePath = \filePath:ascii;
      [] _ = <<dlang ##
         this.fileName = cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_asciiFilePath).IMETHOD_internalData(null, []))).it);
      ##;
   }

   ++ exists *->[Boolean] {
      [Boolean] exists = <<dlang ##
         bool fileExists = this.fileName.exists && this.fileName.isFile;
         OBJECT LOBJECT_exists = fileExists ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> exists

   ++ clearContents *{
      [] _ = <<dlang ##
         if (this.file.isOpen) {
            this.file.close();
         }
         this.file.open(this.fileName, "wb");
         if (this.file.isOpen) {
            this.file.write("");
         }
      ##;
   }

   ++ appendContents *([Data] toAppend) {
      [] _ = <<dlang ##
         if (!this.file.isOpen) {
            this.file.open(this.fileName, "ab");
         }
         if (this.file.isOpen) {
            this.file.rawWrite((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_toAppend).IMETHOD_internalData(null, []))).it);
         }
      ##;
   }

   ++ readContents *([Natural] chunkSize, [[Data]->] readChunk) {
      [] _ = <<dlang ##
         BigInt chunkSize = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_chunkSize).IMETHOD_internalInteger(null, []))).it;
         if (this.file.isOpen) {
            this.file.close();
         }
         this.file.open(this.fileName, "rb");
         if (this.file.isOpen) {
            foreach (ubyte[] buffer; this.file.byChunk(chunkSize.toLong())) {
      ##;
      [Data] chunk = << dlang ##
               CLASSIMPL_Data LOBJECT_chunk = new CLASSIMPL_Data();
               LOBJECT_chunk.value = new WRAP!(ubyte[])(buffer);
      ##;
      \readChunk chunk;
      [] _ = <<dlang ##
         
            }
            this.file.close();
         }
      ##;
   }

   ++ close *{
      [] _ = <<dlang ##
         this.file.close();
      ##;
   }
}


[Data :[Sequence<[Byte]>]] (Byte, Sequence, Loops, Natural)
{
   <<dlang ##
         import std.bigint;
         import std.format;
         WRAP!(ubyte[]) value;
      ##

   ~ empty *{
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])([]);
      ##;
   }

   ~ copy *([Sequence<[Byte]>] bytes) {
      [] _ = <<dlang ##
         ubyte[] copiedData;
      ##;
      \[Loops]:iterate bytes *([] _, [Byte] byte) {
         [] _ = <<dlang ##
            ubyte thisByte = (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_byte).IMETHOD_internalByte(null, []))).it;
            copiedData ~= thisByte;
         ##;
      };
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])(copiedData);
      ##;
   }

   ~ concatenate *([Sequence<[Data]>] datas) {
      [] _ = <<dlang ##
         ubyte[] concatedData;
      ##;
      \[Loops]:iterate datas *([]_, [Data] data) {
         [] _ = <<dlang ##
            ubyte[] thisData = (cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_data).IMETHOD_internalData(null, []))).it;
            concatedData ~= thisData;
         ##;
      };
      [] _ = <<dlang ##
         this.value = new WRAP!(ubyte[])(concatedData);
      ##;
   }

   |++ length *-> [Natural] {
      [Natural] length = << dlang ##
         OBJECT LOBJECT_length = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", this.value.it.length))]);
      ##;
   } -> length

   |++ atIndex *([Natural] index) -> [Maybe<[Byte]>] {
      [Maybe<[Byte]>] byteAtIndex = << dlang ##
         OBJECT LOBJECT_byteAtIndex = null;
         BigInt index = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_index).IMETHOD_internalInteger(null, []))).it;
         if (this.value.it.length > index) {
            CLASSIMPL_Byte rawByte = new CLASSIMPL_Byte();
            rawByte.value = new WRAP!(ubyte)(this.value.it[index.toLong()]);
            LOBJECT_byteAtIndex = CLASSIMPL_Maybe.TMETHOD_as(caller, cast(OBJECT[])[rawByte]);
         } else {
            LOBJECT_byteAtIndex = CLASSIMPL_Maybe.TMETHOD_nothing(caller, cast(OBJECT[])[]);
         }
      ##;
   } -> byteAtIndex


   - internalData *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }
}

[Byte]
{
   <<dlang ##
         WRAP!(ubyte) value;
      ##

   ~ 0x00 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x00); ##; }
   ~ 0x01 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x01); ##; }
   ~ 0x02 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x02); ##; }
   ~ 0x03 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x03); ##; }
   ~ 0x04 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x04); ##; }
   ~ 0x05 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x05); ##; }
   ~ 0x06 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x06); ##; }
   ~ 0x07 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x07); ##; }
   ~ 0x08 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x08); ##; }
   ~ 0x09 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x09); ##; }
   ~ 0x0A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0A); ##; }
   ~ 0x0B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0B); ##; }
   ~ 0x0C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0C); ##; }
   ~ 0x0D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0D); ##; }
   ~ 0x0E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0E); ##; }
   ~ 0x0F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x0F); ##; }
   ~ 0x10 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x10); ##; }
   ~ 0x11 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x11); ##; }
   ~ 0x12 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x12); ##; }
   ~ 0x13 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x13); ##; }
   ~ 0x14 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x14); ##; }
   ~ 0x15 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x15); ##; }
   ~ 0x16 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x16); ##; }
   ~ 0x17 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x17); ##; }
   ~ 0x18 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x18); ##; }
   ~ 0x19 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x19); ##; }
   ~ 0x1A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1A); ##; }
   ~ 0x1B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1B); ##; }
   ~ 0x1C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1C); ##; }
   ~ 0x1D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1D); ##; }
   ~ 0x1E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1E); ##; }
   ~ 0x1F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x1F); ##; }
   ~ 0x20 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x20); ##; }
   ~ 0x21 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x21); ##; }
   ~ 0x22 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x22); ##; }
   ~ 0x23 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x23); ##; }
   ~ 0x24 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x24); ##; }
   ~ 0x25 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x25); ##; }
   ~ 0x26 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x26); ##; }
   ~ 0x27 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x27); ##; }
   ~ 0x28 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x28); ##; }
   ~ 0x29 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x29); ##; }
   ~ 0x2A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2A); ##; }
   ~ 0x2B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2B); ##; }
   ~ 0x2C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2C); ##; }
   ~ 0x2D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2D); ##; }
   ~ 0x2E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2E); ##; }
   ~ 0x2F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x2F); ##; }
   ~ 0x30 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x30); ##; }
   ~ 0x31 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x31); ##; }
   ~ 0x32 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x32); ##; }
   ~ 0x33 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x33); ##; }
   ~ 0x34 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x34); ##; }
   ~ 0x35 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x35); ##; }
   ~ 0x36 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x36); ##; }
   ~ 0x37 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x37); ##; }
   ~ 0x38 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x38); ##; }
   ~ 0x39 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x39); ##; }
   ~ 0x3A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3A); ##; }
   ~ 0x3B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3B); ##; }
   ~ 0x3C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3C); ##; }
   ~ 0x3D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3D); ##; }
   ~ 0x3E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3E); ##; }
   ~ 0x3F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x3F); ##; }
   ~ 0x40 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x40); ##; }
   ~ 0x41 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x41); ##; }
   ~ 0x42 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x42); ##; }
   ~ 0x43 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x43); ##; }
   ~ 0x44 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x44); ##; }
   ~ 0x45 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x45); ##; }
   ~ 0x46 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x46); ##; }
   ~ 0x47 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x47); ##; }
   ~ 0x48 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x48); ##; }
   ~ 0x49 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x49); ##; }
   ~ 0x4A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4A); ##; }
   ~ 0x4B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4B); ##; }
   ~ 0x4C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4C); ##; }
   ~ 0x4D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4D); ##; }
   ~ 0x4E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4E); ##; }
   ~ 0x4F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x4F); ##; }
   ~ 0x50 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x50); ##; }
   ~ 0x51 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x51); ##; }
   ~ 0x52 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x52); ##; }
   ~ 0x53 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x53); ##; }
   ~ 0x54 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x54); ##; }
   ~ 0x55 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x55); ##; }
   ~ 0x56 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x56); ##; }
   ~ 0x57 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x57); ##; }
   ~ 0x58 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x58); ##; }
   ~ 0x59 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x59); ##; }
   ~ 0x5A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5A); ##; }
   ~ 0x5B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5B); ##; }
   ~ 0x5C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5C); ##; }
   ~ 0x5D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5D); ##; }
   ~ 0x5E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5E); ##; }
   ~ 0x5F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x5F); ##; }
   ~ 0x60 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x60); ##; }
   ~ 0x61 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x61); ##; }
   ~ 0x62 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x62); ##; }
   ~ 0x63 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x63); ##; }
   ~ 0x64 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x64); ##; }
   ~ 0x65 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x65); ##; }
   ~ 0x66 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x66); ##; }
   ~ 0x67 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x67); ##; }
   ~ 0x68 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x68); ##; }
   ~ 0x69 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x69); ##; }
   ~ 0x6A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6A); ##; }
   ~ 0x6B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6B); ##; }
   ~ 0x6C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6C); ##; }
   ~ 0x6D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6D); ##; }
   ~ 0x6E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6E); ##; }
   ~ 0x6F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x6F); ##; }
   ~ 0x70 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x70); ##; }
   ~ 0x71 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x71); ##; }
   ~ 0x72 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x72); ##; }
   ~ 0x73 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x73); ##; }
   ~ 0x74 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x74); ##; }
   ~ 0x75 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x75); ##; }
   ~ 0x76 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x76); ##; }
   ~ 0x77 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x77); ##; }
   ~ 0x78 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x78); ##; }
   ~ 0x79 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x79); ##; }
   ~ 0x7A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7A); ##; }
   ~ 0x7B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7B); ##; }
   ~ 0x7C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7C); ##; }
   ~ 0x7D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7D); ##; }
   ~ 0x7E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7E); ##; }
   ~ 0x7F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x7F); ##; }
   ~ 0x80 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x80); ##; }
   ~ 0x81 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x81); ##; }
   ~ 0x82 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x82); ##; }
   ~ 0x83 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x83); ##; }
   ~ 0x84 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x84); ##; }
   ~ 0x85 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x85); ##; }
   ~ 0x86 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x86); ##; }
   ~ 0x87 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x87); ##; }
   ~ 0x88 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x88); ##; }
   ~ 0x89 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x89); ##; }
   ~ 0x8A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8A); ##; }
   ~ 0x8B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8B); ##; }
   ~ 0x8C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8C); ##; }
   ~ 0x8D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8D); ##; }
   ~ 0x8E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8E); ##; }
   ~ 0x8F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x8F); ##; }
   ~ 0x90 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x90); ##; }
   ~ 0x91 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x91); ##; }
   ~ 0x92 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x92); ##; }
   ~ 0x93 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x93); ##; }
   ~ 0x94 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x94); ##; }
   ~ 0x95 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x95); ##; }
   ~ 0x96 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x96); ##; }
   ~ 0x97 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x97); ##; }
   ~ 0x98 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x98); ##; }
   ~ 0x99 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x99); ##; }
   ~ 0x9A *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9A); ##; }
   ~ 0x9B *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9B); ##; }
   ~ 0x9C *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9C); ##; }
   ~ 0x9D *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9D); ##; }
   ~ 0x9E *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9E); ##; }
   ~ 0x9F *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0x9F); ##; }
   ~ 0xA0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA0); ##; }
   ~ 0xA1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA1); ##; }
   ~ 0xA2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA2); ##; }
   ~ 0xA3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA3); ##; }
   ~ 0xA4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA4); ##; }
   ~ 0xA5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA5); ##; }
   ~ 0xA6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA6); ##; }
   ~ 0xA7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA7); ##; }
   ~ 0xA8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA8); ##; }
   ~ 0xA9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xA9); ##; }
   ~ 0xAA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAA); ##; }
   ~ 0xAB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAB); ##; }
   ~ 0xAC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAC); ##; }
   ~ 0xAD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAD); ##; }
   ~ 0xAE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAE); ##; }
   ~ 0xAF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xAF); ##; }
   ~ 0xB0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB0); ##; }
   ~ 0xB1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB1); ##; }
   ~ 0xB2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB2); ##; }
   ~ 0xB3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB3); ##; }
   ~ 0xB4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB4); ##; }
   ~ 0xB5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB5); ##; }
   ~ 0xB6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB6); ##; }
   ~ 0xB7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB7); ##; }
   ~ 0xB8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB8); ##; }
   ~ 0xB9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xB9); ##; }
   ~ 0xBA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBA); ##; }
   ~ 0xBB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBB); ##; }
   ~ 0xBC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBC); ##; }
   ~ 0xBD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBD); ##; }
   ~ 0xBE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBE); ##; }
   ~ 0xBF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xBF); ##; }
   ~ 0xC0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC0); ##; }
   ~ 0xC1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC1); ##; }
   ~ 0xC2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC2); ##; }
   ~ 0xC3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC3); ##; }
   ~ 0xC4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC4); ##; }
   ~ 0xC5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC5); ##; }
   ~ 0xC6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC6); ##; }
   ~ 0xC7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC7); ##; }
   ~ 0xC8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC8); ##; }
   ~ 0xC9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xC9); ##; }
   ~ 0xCA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCA); ##; }
   ~ 0xCB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCB); ##; }
   ~ 0xCC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCC); ##; }
   ~ 0xCD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCD); ##; }
   ~ 0xCE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCE); ##; }
   ~ 0xCF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xCF); ##; }
   ~ 0xD0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD0); ##; }
   ~ 0xD1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD1); ##; }
   ~ 0xD2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD2); ##; }
   ~ 0xD3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD3); ##; }
   ~ 0xD4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD4); ##; }
   ~ 0xD5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD5); ##; }
   ~ 0xD6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD6); ##; }
   ~ 0xD7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD7); ##; }
   ~ 0xD8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD8); ##; }
   ~ 0xD9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xD9); ##; }
   ~ 0xDA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDA); ##; }
   ~ 0xDB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDB); ##; }
   ~ 0xDC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDC); ##; }
   ~ 0xDD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDD); ##; }
   ~ 0xDE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDE); ##; }
   ~ 0xDF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xDF); ##; }
   ~ 0xE0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE0); ##; }
   ~ 0xE1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE1); ##; }
   ~ 0xE2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE2); ##; }
   ~ 0xE3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE3); ##; }
   ~ 0xE4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE4); ##; }
   ~ 0xE5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE5); ##; }
   ~ 0xE6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE6); ##; }
   ~ 0xE7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE7); ##; }
   ~ 0xE8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE8); ##; }
   ~ 0xE9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xE9); ##; }
   ~ 0xEA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEA); ##; }
   ~ 0xEB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEB); ##; }
   ~ 0xEC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEC); ##; }
   ~ 0xED *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xED); ##; }
   ~ 0xEE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEE); ##; }
   ~ 0xEF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xEF); ##; }
   ~ 0xF0 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF0); ##; }
   ~ 0xF1 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF1); ##; }
   ~ 0xF2 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF2); ##; }
   ~ 0xF3 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF3); ##; }
   ~ 0xF4 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF4); ##; }
   ~ 0xF5 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF5); ##; }
   ~ 0xF6 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF6); ##; }
   ~ 0xF7 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF7); ##; }
   ~ 0xF8 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF8); ##; }
   ~ 0xF9 *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xF9); ##; }
   ~ 0xFA *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFA); ##; }
   ~ 0xFB *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFB); ##; }
   ~ 0xFC *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFC); ##; }
   ~ 0xFD *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFD); ##; }
   ~ 0xFE *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFE); ##; }
   ~ 0xFF *{ [] _ = <<dlang ## this.value = new WRAP!(ubyte)(0xFF); ##; }

   - internalByte *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }

   ++ isEqualTo *([Byte] otherByte)-> [Boolean] {
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = this.value.it == (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_otherByte).IMETHOD_internalByte(null, []))).it;
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ inclusiveBetween *([Byte] from, [Byte] to)-> [Boolean] {
      [Boolean] isInclusiveBetween = << dlang ## 
         bool isInclusiveBetween = (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_from).IMETHOD_internalByte(null, []))).it >= this.value.it && this.value.it <= (cast(WRAP!(ubyte))((cast(CLASSTYPE_Byte)LOBJECT_to).IMETHOD_internalByte(null, []))).it;
         OBJECT LOBJECT_isInclusiveBetween = isInclusiveBetween ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isInclusiveBetween

}

[String] (Data, Sequence, List) 
   [Data] ascii
{
   <<dlang ##
         import std.bigint;
         import std.format;
      ##

   ~ as *([%STRING] literal) {
      .ascii = \[Data]:empty;
      [] _ = <<dlang ##
         ubyte[] literalBytes = cast(ubyte[])((cast(WRAP!(string))LOBJECT_literal).it);
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(literalBytes);
      ##;
   }

   ~ asASCII *([Data] ascii) {
      .ascii = ascii
   }

   ~ concatenate *([Sequence<[String]>] strings) {
      [Sequence<[Data]>] asciis = [:[Sequence<[Data]>]] { 
         |++ length *->\strings:length
         |++ atIndex *([Natural] i)->\(\strings:atIndex i):isOrElse (*([String] s)->\[Maybe<[?]>]:as \s:ascii) [Maybe<[?]>]:nothing
      };
      \:~asASCII \[Data]:concatenate asciis
   }

   ~ stringFormatOf *([Integer] integer) {
      .ascii = \[Data]:empty;
      [] _ = << dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         ubyte[] bytes = cast(ubyte[])(format("%d", integer));
         (cast(CLASSIMPL_Data)IOBJECT_ascii).value = new WRAP!(ubyte[])(bytes);
      ##;
   }

   ++ isEqualTo *([String] otherString)-> [Boolean] {
      [Data] thisAscii = \:ascii;
      [Data] otherAscii = \otherString:ascii;
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_thisAscii).IMETHOD_internalData(null, []))).it) == cast(string)((cast(WRAP!(ubyte[]))((cast(CLASSTYPE_Data)LOBJECT_otherAscii).IMETHOD_internalData(null, []))).it);
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ appending *([String] other) -> [String] {
      [String] this = ^;
      [Sequence<[String]>] both = [:[Sequence<[String]>]] { 
         |++ length *->\[Natural]:as ##2##
         |++ atIndex *([Natural] index)->[Maybe<[String]>]{
            [Boolean] indexIs0 = \index:isEqualTo (\[Natural]:as ##0##);
         }->\[Maybe<[String]>]:as \indexIs0:ifOrElse (*->this) (*->other)
      }
   } -> \[String]:concatenate both

   ++ ascii *->.ascii
}

[Loops] (Sequence, Natural, Variable, Boolean)
{
   :: iterate *([Sequence<['E]>] sequence, [[Natural]['E]->] getNext) {
      [Variable<[Natural]>] currentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      \[?:]:while ((*->((\index:isLessThan \sequence:length)!{[Natural] index = \currentIndex:get}))) *{
         {
            \element:isOrElse *(e){
               \getNext index e;
            } *{};
            @\getNext index element;
            \currentIndex:set \index:adding (\[Natural]:as ##1##);
         }!{
            [Natural] index = \currentIndex:get;
            [Maybe<['E]>] element = \sequence:atIndex index;
         }
      }
   }

   :: while *([->[Boolean]] condition, [->] action) {
      \[?:]:until *([->] stop) {
         \(\condition):ifOrElse action stop
      }
   }

   :: until *([[['E]->]->['E]] actionWithStop) -> ['E] { @add
      ['E] result = <<dlang ##
         bool continueActions = true;
         OBJECT LOBJECT_result = null;
         while (continueActions) {
      ##;
      \actionWithStop *(["E] resultFromAction) {
         [] _ = <<dlang ##
            continueActions = false;
            LOBJECT_result = LOBJECT_resultFromAction;
         ##
      };
      [] _ = <<dlang
      ##
         }
      ##;
   } -> result
}

[Variable<E>]
   [&E] variableObject
{
   ~ as *([&E] initialInstantiation) {
      .variableObject = initialInstantiation;
   }

   ++ get *->.variableObject

   ++ set *([&E] newInstantiation) {
      [] _ = << dlang ##
         IOBJECT_variableObject = LOBJECT_newInstantiation;
      ##;
   }
}


[Sequence<E>] (Maybe, Natural)
{
   ++ length [->[Natural]]
   ++ atIndex [[Natural]->[Maybe<[&E]>]]
}


[Natural :[Integer]] (Integer)
{
   <<dlang ##
         import std.format;
         import std.conv;
         import std.bigint;
      ##
   

   ~ as *([%NATURAL] literal) {
      [Integer] integerRepresentation = <<dlang ##
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[LOBJECT_literal]);
      ##;
      \$~>integerRepresentation;
   }

   ~ clampTo0 *([Integer] integer) {
      [Integer] integerRepresentation = <<dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         if (integer < BigInt("0")) {
            integer = BigInt("0");
         }
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", integer))]);
      ##;
      \$~>integerRepresentation;
   }

   ~ magnitudeOf *([Integer] integer) {
      [Integer] integerRepresentation = <<dlang ##
         BigInt integer = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_integer).IMETHOD_internalInteger(null, []))).it;
         if (integer < BigInt("0")) {
            integer = integer*BigInt("-1");
         }
         CLASSIMPL_Integer LOBJECT_integerRepresentation = cast(CLASSIMPL_Integer)CLASSIMPL_Integer.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", integer))]);
      ##;
      \$~>integerRepresentation;
   }

   ++ adding *([Natural] toAdd) -> [Natural] {
      [Natural] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toAddBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toAdd).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt + toAddBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
}


[Maybe<E>] 
{
   ~ nothing *{
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \else
   }

   ~ as *([&E] it) {
      :isOrElse = *([[&E]->['O]] is, [->['O]] else) -> \is it
   }

   ++ isOrElse [[[&E]->['O]][->['O]]->['O]]
}

[Boolean] 
{
   ~ false *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \else
   }

   ~ true *{
      :ifOrElse = *([->['O]] if, [->['O]] else) -> \if
   }

   ++ ifOrElse [[->['O]][->['O]]->['O]]

   ~ or *([Boolean] b1, [Boolean] b2) {
      :ifOrElse = *([->["O]] if, [->["O]] else) 
         -> \b1:ifOrElse if *->\b2:ifOrElse if else
   }

   ~ and *([Boolean] b1, [Boolean] b2) {
      :ifOrElse = *([->["O]] if, [->["O]] else) 
         -> \b1:ifOrElse (*->\b2:ifOrElse if else) else
   }

   ~ not *([Boolean] b1) {
      :ifOrElse = *([->["O]] if, [->["O]] else) 
         -> \b1:ifOrElse else if
   }
}


[Integer] (Boolean)
{
   <<dlang ##
            import std.conv;
            import std.bigint;
            import std.format;
            WRAP!(BigInt) value;
         ##

   ~ as *([%INTEGER] literal) {
      [] _ = <<dlang ##
         this.value = new WRAP!(BigInt)(BigInt((cast(WRAP!(string))LOBJECT_literal).it));
      ##;
   }

   ++ isLessThan *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isLessThan = << dlang ## 
         bool isLessThan = this.value.it < (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isLessThan = isLessThan ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isLessThan

   ++ isEqualTo *([Integer] otherInteger)-> [Boolean] {
      [Boolean] isEqualTo = << dlang ## 
         bool isEqualTo = this.value.it == (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_otherInteger).IMETHOD_internalInteger(null, []))).it;
         OBJECT LOBJECT_isEqualTo = isEqualTo ? CLASSIMPL_Boolean.TMETHOD_true(caller, cast(OBJECT[])[]) : CLASSIMPL_Boolean.TMETHOD_false(caller, cast(OBJECT[])[]);
      ##;
   } -> isEqualTo

   ++ subtracting *([Integer] toSubtract) -> [Integer] {
      [Integer] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toSubtractBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toSubtract).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt - toSubtractBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result

   ++ adding *([Integer] toAdd) -> [Natural] {
      [Natural] result = << dlang ##
         BigInt thisBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)self).IMETHOD_internalInteger(null, []))).it;
         BigInt toAddBigInt = (cast(WRAP!(BigInt))((cast(CLASSTYPE_Integer)LOBJECT_toAdd).IMETHOD_internalInteger(null, []))).it;
         BigInt bigIntResult = thisBigInt + toAddBigInt;
         OBJECT LOBJECT_result = CLASSIMPL_Natural.TMETHOD_as(caller, cast(OBJECT[])[new WRAP!(string)(format("%d", bigIntResult))]);
      ##;
   } -> result
   

   - internalInteger *{
      [] _ = <<dlang ##
            return this.value;
         ##;
   }

}


[ListNode<E>] () -> (List)
{
   ~ withValue *([&E] value) {
      :value = *-> value;
      :next = (*-> next) ! [?] next = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      :previous = (*-> previous) ! [?] previous = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
   }

   ++ value [->[&E]]
   ++ next [->[Variable<[Maybe<[ListNode<[&E]>]>]>]]
   ++ previous [->[Variable<[Maybe<[ListNode<[&E]>]>]>]]
}

[List<E> : [Sequence<[&E]>]] (ListNode, Boolean, Maybe, Variable, Sequence, Natural, Loops)
   [Variable<[Maybe<[ListNode<[&E]>]>]>] first
   [Variable<[Maybe<[ListNode<[&E]>]>]>] last
   [Variable<[Natural]>] length
{
   ~ empty *{
      .first = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      .last = \[Variable<[?]>]:as \[Maybe<[ListNode<[&E]>]>]:nothing;
      .length = \[Variable<[?]>]:as \[Natural]:as ##0##;
   }

   @ copy [Sequence<[&E]>]

   ++ length *->\.length:get

   ++ atIndex *([Natural] index) -> [Maybe<[&E]>] {
      [Variable<[Natural]>] varCurrentIndex = \[Variable<[?]>]:as \[Natural]:as ##0##;
      [Variable<[Maybe<[ListNode<[&E]>]>]>] varCurrentNode = \[Variable<[?]>]:as \.first:get;
      [Maybe<[&E]>] atIndex = \[Loops]:until *([[Maybe<[&E]>]->] choose) {
         [Natural] currentIndex = \varCurrentIndex:get;
         [Maybe<[ListNode<[&E]>]>] currentNode = \varCurrentNode:get;
         \varCurrentNode:set \currentNode:isOrElse (*([ListNode<[&E]>] n)-> [Maybe<[ListNode<[&E]>]>] {
               [Boolean] sameIndex = (\currentIndex:isEqualTo index);
               \sameIndex:ifOrElse *{
                  \choose \[Maybe<[&E]>]:as \n:value;
               } *{};
            } ->\(\n:next):get) 
         (*->[Maybe<[ListNode<[&E]>]>]{\choose \[Maybe<[&E]>]:nothing}->\[Maybe<[ListNode<[&E]>]>]:nothing);
         \varCurrentIndex:set \currentIndex:adding \[Natural]:as ##1##;
      };
   } -> atIndex

   ++ removeFirst *-> [Maybe<[&E]>] {
      [Maybe<[ListNode<[&E]>]>] first = \.first:get;
   } -> \first:isOrElse (*([ListNode<[&E]>] node) -> [Maybe<[&E]>] {
         \.first:set \node:next;
         [Natural] length = \.length:get;
         \.length:set \[Natural]:clampTo0 \length:subtracting \[Natural]:as ##1##;
      } -> \[Maybe<[?]>]:as \node:value) (*->\[Maybe<[&E]>]:nothing)
   
   ++ prepend *([&E] value) {
      [Natural] length = \.length:get;
      \.length:set \length:adding \[Natural]:as ##1##;
      [ListNode<[&E]>] newNode = \[ListNode<[&E]>]:withValue value;
      [Maybe<[ListNode<[&E]>]>] first = \.first:get;
      \first:isOrElse *([ListNode<[&E]>] firstNode) {
         [Variable<[Maybe<[ListNode<[&E]>]>]>] firstNodePrevious = \firstNode:previous;
         [Variable<[Maybe<[ListNode<[&E]>]>]>] newNodeNext = \newNode:next;
         \newNodeNext:set first;
         \firstNodePrevious:set \[Maybe<[?]>]:as newNode;
      } *{
         \.last:set \[Maybe<[?]>]:as newNode;
      };
      \.first:set \[Maybe<[?]>]:as newNode;
   }

   ++ removeLast *-> [Maybe<[&E]>] {
      [Maybe<[ListNode<[&E]>]>] last = \.last:get;
   } -> \last:isOrElse (*([ListNode<[&E]>] node) -> [Maybe<[&E]>] {
         \.last:set \node:previous;
         [Natural] length = \.length:get;
         \.length:set \[Natural]:clampTo0 \length:subtracting \[Natural]:as ##1##;
      } -> \[Maybe<[?]>]:as \node:value) (*->\[Maybe<[&E]>]:nothing)

   ++ append *([&E] value) {
      [Natural] length = \.length:get;
      \.length:set \length:adding \[Natural]:as ##1##;
      [ListNode<[&E]>] newNode = \[ListNode<[&E]>]:withValue value;
      [Maybe<[ListNode<[&E]>]>] last = \.last:get;
      \last:isOrElse *([ListNode<[&E]>] lastNode) {
         [Variable<[Maybe<[ListNode<[&E]>]>]>] newNodePrevious = \newNode:previous;
         [Variable<[Maybe<[ListNode<[&E]>]>]>] lastNodeNext = \lastNode:next;
         \newNodePrevious:set last;
         \lastNodeNext:set \[Maybe<[?]>]:as newNode;
      } *{
         \.first:set \[Maybe<[?]>]:as newNode;
      };
      \.last:set \[Maybe<[?]>]:as newNode;
   }
}





@ DAINA COMPILER -------

[SourcePosition] (
         Natural,
         String,
         Variable,
         Object,
         Loops
      )
   [String] sourceName
   [Natural] line
   [Natural] column
   [String] lineContent
{
   ~ initialPositionIn *([String] sourceName, [String] lineContent) {
      \:~lineAndColumnIn (\[Natural]:as ##0##) (\[Natural]:as ##0##) sourceName lineContent;
   }

   ~ -+- lineAndColumnIn *([Natural] line, [Natural] column, [String] sourceName, [String] lineContent) {
      .sourceName = sourceName;
      .column = column;
      .line = line;
      .lineContent = lineContent;
   }

   ++ description *-> [String] {
      [String] colon = \[String]:as ##:##;
      [String] pos = \[String]:as ## pos ##;
      [String] line = \[String]:stringFormatOf (\.line:adding (\[Natural]:as ##1##));
      [String] column = \[String]:stringFormatOf (\.column:adding (\[Natural]:as ##1##));
      [String] tabulation = \[String]:as ##\n    ##;
      [Variable<[String]>] linePositionArrow = \[Variable<[String]>]:as (\[String]:as ####);
      \[Loops]:iterate ([:[Sequence<[Natural]>]] { 
         |++ length *->.column
         |++ atIndex *(i)->\[Maybe<[?]>]:as i
      }) *{
         [String] curr = \linePositionArrow:get;
         \linePositionArrow:set (\curr:appending (\[String]:as ## ##));
      };
      [String] curr = \linePositionArrow:get;
      \linePositionArrow:set (\curr:appending (\[String]:as ##^##));
   } -> (\.sourceName:appending (\colon:appending (\line:appending (\pos:appending (\column:appending (\tabulation:appending (\.lineContent:appending (\tabulation:appending (\linePositionArrow:get)))))))))

   ++ nextColumn *-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Natural]:as ##1##)) (.sourceName) (.lineContent)

   ++ startOfNextLine *([String] lineContent)-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Natural]:as ##1##)) (\[Natural]:as ##0##) (.sourceName) lineContent
}



[Error] (Object, String, SourcePosition, List, Variable)
   [String] errorString
{
   ++ description *-> [String] {
      [String] errorPrefix = \[String]:as ##ERROR; ##;
   } -> (\errorPrefix:appending .errorString)

   ~ -+- as *([String] errorString) {
      .errorString = errorString;
   }

   ~ -+- errorWithContext *([String] errorString, [List<[SourcePosition]>] context) {
      [Variable<[String]>] errorWithContext = \[Variable<[String]>]:as errorString;
      \[Loops]:iterate context *([] _, [SourcePosition] sourcePosition) {
         [String] addedContext = (\prefix:appending (\sourcePosition:description)) !{
               [String] prefix = \[String]:as ## - ##;
            };
         \errorWithContext:set (\prefix:appending addedContext) !{
               [String] prefix = \errorWithContext:get;
            };
      };
      .errorString = \errorWithContext:get;
   }

   :: sourceFileNotAccessible *([String] fileName) -> [Error] {
      [String] prefix = \[String]:as ##Source file not accessible: ##;
   } -> (\[Error]:as (\prefix:appending fileName))

   :: unrecognisedToken *([String] token, [SourcePosition] position) -> [Error] {
      [String] prefix = \[String]:as ##Unrecognised token: ##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext (\prefix:appending token) context)

   :: invalidVisibilityIndicator *([SourcePosition] position) -> [Error] {
      [String] error = \[String]:as ##Invalid visibility indicator##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext error context)

    :: expectingSecondHashForDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second hash for data segment anchor##) context)

   :: expectingSecondDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second data segment anchor##) context)

   :: expectingClassAtTopLevel *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class at top level##) context)

   :: expectingBodyOfClass *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting body of class##) context)

   :: expectingEntryPointMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting entry point method##) context)

   :: expectingClosingBracketForClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class body##) context)

   :: expectingClassName *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class name##) context)

   :: expectingParentType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type##) context)

   :: expectingClosingSquareBracketAfterClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after class header##) context)

   :: expectingGenericIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting generic identifier##) context)

   :: expectingClosingBracketForGenericDeclarationList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for generic declaration list##) context)

   :: expectingDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting dependancy##) context)

   :: expectingReverseDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy##) context)

   :: expectingClosingBracketForDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy list##) context)

   :: expectingReverseDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy list##) context)

   :: expectingType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting type##) context)

   :: expectingOneOrMoreTypesForClassGenericInstantiation *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting one or more types for class generic instantiation##) context)

   :: expectingClosingBracketForClassGenericInstantiations *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class generic instantiations##) context)

   :: expectingClosingBracketForType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for type##) context)

   :: expectingClosingBracketForDependancyWithDerivatives *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy with derivatives##) context)

   :: expectingIdentifierForObjectDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for object declaration##) context)

   :: expectingVisibilityIndicatorForInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting visibility indicator for instance method##) context)

   :: expectingIdentifierForClassMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for class method##) context)

   :: expectingClassMethodExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class method expression##) context)

   :: expectingIdentifierForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for compiler injection##) context)

   :: expectingDataSegmentForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting data segment for compiler injection##) context)

   :: expectingPrologueStatement *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting prologue statement##) context)

   :: expectingMethodInput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method input##) context)

   :: expectingClosingBracketForMethodInputs *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for method inputs##) context)

   :: expectingMethodBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method body##) context)

   :: expectingMethodOutput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method output##) context)

   :: expectingClosingBracketForStatementGroup *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for statement group##) context)

   :: expectingParentTypeForAnonymousClassObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type for anonymous class object##) context)

   :: expectingClosingSquareBracketAfterAnonymousClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after anonymous class header##) context)

   :: expectingAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting anonymous class body##) context)

   :: expectingClosingBracketForAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for anonymous class body##) context)

   :: unexpectedTokenAfterType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token after type##) context)

   :: expectingInstanceMethodIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance method identifier##) context)

   :: expectingExpressionToBeCast *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to be cast##) context)

   :: expectingClosingBracketForCastExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for cast expression##) context)

   :: expectingIdentifierForTypeMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for type method##) context)

   :: expectingEqualsToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting equals to assign local declaration##) context)

   :: expectingExpressionToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign local declaration##) context)

   :: expectingExpressionToAssignInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance method##) context)

   :: expectingExpressionToAssignInstanceObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance object##) context)

   :: expectingInstanceObjectIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance object identifier##) context)

   :: unexpectedTokenBeforeTilde *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token before tilde##) context)

   :: expectingMethodToInvoke *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method to invoke##) context)

   :: expectingProxyObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting proxy object##) context)

   :: expectingCompilerInjectionIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection identifier##) context)

   :: expectingCompilerInjectionDataSegment *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection data segment##) context)

   :: expectingExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression##) context)

   :: expectingClosingBracketForExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for expression##) context)

   :: expectingConstructorIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting constructor identifier##) context)


}


[CommandReader] (String) 
{
   ++ exit [->]
   ++ parseSourceFile [[String]->]
   ++ compileToFile [[String]->]
   ++ invalidCommand [->]
}



[Character] (Byte, Boolean, String, Data)
   [Byte] asciiByte
{
   ~ fromASCII *([Byte] asciiByte) {
      .asciiByte = asciiByte;
   }

   ~ space *{
      .asciiByte = \[Byte]:0x20;
   }

   ++ asASCII *->.asciiByte

   ++ description *-> (\[String]:asASCII \[Data]:copy [:[Sequence<[Byte]>]] { 
      |++ length *->\[Natural]:as ##1## 
      |++ atIndex *->\[Maybe<[Byte]>]:as .asciiByte
   })

   ++ isNULL *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x00))

   ++ isSemicolon *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3B))
   ++ isPlus *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2B))
   ++ isUnderscore *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5F))
   ++ isBackslash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5C))
   ++ isForwardslash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2F))
   ++ isFullstop *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2E))
   ++ isColon *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3A))
   ++ isTilde *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7E))
   ++ isHash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x23))
   ++ isDollarSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x24))
   ++ isBacktick *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x60))
   ++ isAmpersand *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x26))
   ++ isSingleApostrophe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x27))
   ++ isDash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2D))
   ++ isArrowBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3C))
   ++ isArrowBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3E))
   ++ isAsterisk *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2A))
   ++ isCaret *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5E))
   ++ isComma *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2C))
   ++ isCurlyBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7B))
   ++ isCurlyBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7D))
   ++ isDoubleApostrophe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x22))
   ++ isPipe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7C))
   ++ isStrudel *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x40))
   ++ isEqualsSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3D))
   ++ isExclamationMark *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x21))
   ++ isPercentSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x25))
   ++ isQuestionMark *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3F))
   ++ isRoundBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x28))
   ++ isRoundBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x29))
   ++ isSquareBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5B))
   ++ isSquareBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5D))

   ++ isTab *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x09))
   ++ isNewline *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x0A))

   ++ isAlphanumeric *->[Boolean] {
   } -> \[Boolean]:or (\[Boolean]:or (\.asciiByte:inclusiveBetween (\[Byte]:0x30) (\[Byte]:0x39)) (\.asciiByte:inclusiveBetween (\[Byte]:0x41) (\[Byte]:0x5A))) (\.asciiByte:inclusiveBetween (\[Byte]:0x61) (\[Byte]:0x7A))

   ++ isWhitespace *->[Boolean] {
   } -> \[Boolean]:or (\.asciiByte:inclusiveBetween (\[Byte]:0x09) (\[Byte]:0x0D)) (\.asciiByte:isEqualTo (\[Byte]:0x20))
}


[Configuration] (Maybe, Error, String, StandardIO) {
   
   ~ init *{}

   ++ outputError *([Error] error) {
      \[StandardIO]:stdout \(\error:description):ascii;
      \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;
   }
   @++ commandInput *->[InputStream] {} -> \[SystemInputOutput]:stdin
   @++ compilationFileOutput *([String] filePath)-> [Maybe<[OutputStream]>] {} -> \[SystemInputOutput]:maybeOutputStreamForFileWithFilename filePath
   @++ sourceFileInput *([String] filePath)-> [Maybe<[InputStream]>] {} -> \[SystemInputOutput]:maybeInputStreamForFileWithFilename filePath
}



[Token] (
         Natural,
         String,
         Boolean,
         Variable
      )
   [Natural] id
   [Natural] secondId
   [String] content
{
   ~ -+- basicToken *([Natural] id) {
      .id = id;
      .content = \[String]:as ####;
      .secondId = \[Natural]:as ##0##;
   }

   ~ -+- secondIdToken *([Natural] id, [Natural] secondId) {
      .id = id;
      .content = \[String]:as ####;
      .secondId = secondId;
   }

   ~ -+- contentToken *([Natural] id, [String] content) {
      .id = id;
      .content = content;
      .secondId = \[Natural]:as ##0##;
   }

   -+- id *->[Natural] {} -> .id
   -+- content *->[String] {} -> .content
   -+- secondId *->[Natural] {} -> .secondId
@@
   ++ asDebugString *->[String] {
      [String] idString = \[String]:stringRepresentationOfNatural .id;
      [String] seperator = \[String]:as "~";
      [String] secondIDString = \[String]:stringRepresentationOfNatural .secondId;
   } -> (\idString:appending (\seperator:appending (\secondIDString:appending (\seperator:appending .content))))
@@
   ++ ifIdentifier *([[String]->] ifIdentifier) {
      [Token] idToken = \[Token]:identifier (\[String]:as ####);
      [Boolean] isIdentifier = \.id:isEqualTo (\idToken:id);
      \isIdentifier:ifOrElse *{
         \ifIdentifier .content;
      } *{};
   }

   :: isVisibilityIndicator *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##1##))

   :: isDataSegment *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##4##))

   :: isIdentifier *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##3##))

   :: isParentIdentifier *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##2##))

   @++ equals *([Token] t) -> [Boolean] {
   @} -> (\[Boolean]:and (\[Boolean]:and (\.content:isEqualTo (\t:content)) (\.secondId:isEqualTo (\t:secondId))) (\.id:isEqualTo (\t:id)))

   :: equals *([Token] t, [Token] t2) -> [Boolean] {
      [String] content = \t2:content;
      [Natural] id = \t2:id;
      [Natural] secondId = \t2:secondId;
   } -> (\[Boolean]:and (\[Boolean]:and (\content:isEqualTo (\t:content)) (\secondId:isEqualTo (\t:secondId))) (\id:isEqualTo (\t:id)))

   :: visibilityIndicator *([Boolean] externalVisibility, [Boolean] classVisibility, [Boolean] inheritedVisibility) -> [Token] {
      [Variable<[Natural]>] visibility = \[Variable<[Natural]>]:as (\[Natural]:as ##0##);
      \externalVisibility:ifOrElse (*{
            \visibility:set (\one:adding (\visibility:get));
         } !{[Natural] one = \[Natural]:as ##1##;}) *{};
      \classVisibility:ifOrElse (*{
            \visibility:set (\ten:adding (\visibility:get));
         } !{[Natural] ten = \[Natural]:as ##10##;}) *{};
      \inheritedVisibility:ifOrElse (*{
            \visibility:set (\hundred:adding (\visibility:get));
         } !{[Natural] hundred = \[Natural]:as ##100##;}) *{};
   } -> (\[Token]:secondIdToken (\[Natural]:as ##1##) (\visibility:get))

   :: parentIdentifier *([Natural] repetitionCount) -> (\[Token]:secondIdToken (\[Natural]:as ##2##) repetitionCount)
   :: identifier *([String] identifierString) -> (\[Token]:contentToken (\[Natural]:as ##3##) identifierString)
   :: dataSegment *([String] content) -> (\[Token]:contentToken (\[Natural]:as ##4##) content)
   
   :: ampersand *-> (\[Token]:basicToken \[Natural]:as ##5##)
   :: singleApostrophe *-> (\[Token]:basicToken \[Natural]:as ##6##)
   :: arrow *-> (\[Token]:basicToken \[Natural]:as ##7##)
   :: arrowBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##8##)
   :: arrowBracketClose *-> (\[Token]:basicToken \[Natural]:as ##9##)
   :: asterisk *-> (\[Token]:basicToken \[Natural]:as ##10##)
   :: asteriskCaret *-> (\[Token]:basicToken \[Natural]:as ##11##)
   :: asteriskArrow *-> (\[Token]:basicToken \[Natural]:as ##12##)
   :: backslash *-> (\[Token]:basicToken \[Natural]:as ##13##)
   :: caret *-> (\[Token]:basicToken \[Natural]:as ##14##)
   :: colon *-> (\[Token]:basicToken \[Natural]:as ##15##)
   :: comma *-> (\[Token]:basicToken \[Natural]:as ##16##)
   :: curlyBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##17##)
   :: curlyBracketClose *-> (\[Token]:basicToken \[Natural]:as ##18##)
   :: doubleApostrophe *-> (\[Token]:basicToken \[Natural]:as ##19##)
   :: doubleColon *-> (\[Token]:basicToken \[Natural]:as ##20##)
   :: equalsSign *-> (\[Token]:basicToken \[Natural]:as ##23##)
   :: exclamationMark *-> (\[Token]:basicToken \[Natural]:as ##24##)
   :: forwardSlash *-> (\[Token]:basicToken \[Natural]:as ##25##)
   :: fullStop *-> (\[Token]:basicToken \[Natural]:as ##26##)
   :: percentSign *-> (\[Token]:basicToken \[Natural]:as ##27##)
   :: pipe *-> (\[Token]:basicToken \[Natural]:as ##28##)
   :: questionMark *-> (\[Token]:basicToken \[Natural]:as ##29##)
   :: roundBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##30##)
   :: roundBracketClose *-> (\[Token]:basicToken \[Natural]:as ##31##)
   :: semicolon *-> (\[Token]:basicToken \[Natural]:as ##32##)
   :: squareBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##33##)
   :: squareBracketClose *-> (\[Token]:basicToken \[Natural]:as ##34##)
   :: tilde *-> (\[Token]:basicToken \[Natural]:as ##36##)
   :: doubleLessThan *-> (\[Token]:basicToken \[Natural]:as ##37##)
   :: EOF *-> (\[Token]:basicToken \[Natural]:as ##38##)
}







[Parser] (
         String,
         Maybe,
         List,
         Error,
         Character,
         Byte,
         Token,
         SourcePosition,
         Boolean,
         Variable,
         Loops,
         Data,
         Integer
      ) 
   [->[Maybe<[Byte]>]] inputStream
   [List<[Error]>] errors
   [Variable<[Maybe<[Token]>]>] currentToken
   [Variable<[SourcePosition]>] currentTokenPosition
   [Variable<[[[Maybe<[Token]>][SourcePosition]->][->]->]>] ifNextTokenOrElse
   [Variable<[Maybe<[Character]>]>] currentCharacter
   [Variable<[SourcePosition]>] currentCharacterPosition
   [List<[Character]>] buffer
{
   ~ withSourceNameAndInput *([String] sourceName, [->[Maybe<[Byte]>]] inputStream) {
      .inputStream = inputStream;
      .errors = \[List<[Error]>]:empty;
      .currentToken = \[Variable<[?]>]:as (\[Maybe<[Token]>]:nothing);
      .buffer = \[List<[Character]>]:empty;
      .currentCharacter = \[Variable<[?]>]:as \[Maybe<[Character]>]:nothing;
      [SourcePosition] initialPosition = \[SourcePosition]:initialPositionIn sourceName (\:getCopyOfNextLine);
      .currentCharacterPosition = \[Variable<[?]>]:as initialPosition;
      .currentTokenPosition = \[Variable<[?]>]:as initialPosition;
      .ifNextTokenOrElse = \[Variable<[?]>]:as *([]a,[->]else){\else};
      \:gotoNextCharacterTrue;
      \:gotoNextToken;
   }

   - getCopyOfNextLine *->[String] {
      [String] line = \:stringFromCharacters *([[Character]->] useCharacter) {
         \[Loops]:until *([->] stop) {
            [Maybe<[Character]>] nextChar = \(\.inputStream):isOrElse ([Character]:fromASCII) ([Maybe<[Character]>]:nothing);
            \nextChar:isOrElse *([Character] c) {
               @\c:debugLog;
               \.buffer:append c;
               [Boolean] notEndOfLine = \[Boolean]:not (\c:isNewline);
               \notEndOfLine:ifOrElse *{
                  [Boolean] cIsTab = \c:isTab;
                  \cIsTab:ifOrElse *{
                     \useCharacter (\[Character]:space);
                  } *{
                     \useCharacter c;
                  };
               } stop;
            } stop;
         };
      };
   } -> line

   - stringFromCharacters *([[[Character]->]->] getCharacters) -> [String] {
            [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
            \getCharacters *([Character] character) {
               \asciiString:append (\character:asASCII);
            };
         } -> \[String]:asASCII \[Data]:copy asciiString

    - gotoNextCharacter *{
      [Maybe<[Character]>] currentCharacter = (.currentCharacter:get);
      \currentCharacter:isOrElse *([Character] t) {
         \(\t:isNULL):ifOrElse *{} *{\:gotoNextCharacterTrue;};
      } *{};
    }

   - gotoNextCharacterTrue *{
      [Maybe<[Character]>] currentCharacter = (.currentCharacter:get);
      [Boolean] isNewline = \currentCharacter:isOrElse (*([Character] c) -> [Boolean] {} -> \c:isNewline) *{};
      [SourcePosition] currentCharacterPosition = \.currentCharacterPosition:get;
      \isNewline:ifOrElse *{
         .currentCharacterPosition = \currentCharacterPosition:startOfNextLine (\:getCopyOfNextLine);
      } *{
         .currentCharacterPosition = \currentCharacterPosition:nextColumn;
      };
      [Maybe<[Character]>] bufferedChar = \.buffer:removeFirst;
      .currentCharacter = bufferedChar;
      @\bufferedChar:ifNothing *{
         @.currentCharacter = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
      @};
   }

   - eatWhitespaceCharacters *{
      \[Loops]:while (*->[Boolean]{
         [Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
         [Maybe<[Character]>] currentCharacter = (.currentCharacter:get);
         \currentCharacter:isOrElse *([Character] character) {
            \isWhitespace:set (\character:isWhitespace);
         } *{};
      } -> \isWhitespace:get) (:gotoNextCharacter);
   }

   ++ hasErrors *-> [Boolean] {} -> (\[Boolean]:not (\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)})

    ++ errors *-> [List<[Error]>] {} -> .errors

    ++ addError *([Error] error) {
      \.errors:append error;
    }

   ++ token *->[Token] {
      [Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
      [Maybe<[Token]>] m = \.currentToken:get;
      \m:isOrElse *([Token] t) {\token:set t} *{};
   } -> \token:get

   ++ position *->[SourcePosition] {} -> \.currentTokenPosition:get

   ++ peekAtNextToken *->[Token] {
      [Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
      \.ifNextTokenOrElse *([Maybe<[Token]>] t, [SourcePosition] p) {} *{
         [Maybe<[Token]>] currT = \.currentToken:get;
         [SourcePosition] currS = \.currentTokenPosition:get;
         \:gotoNextToken;
         [Maybe<[Token]>] nextT = \.currentToken:get;
         [SourcePosition] nextS = \.currentTokenPosition:get;
         \.currentToken:set currT;
         \.currentTokenPosition:set currS;
         .ifNextTokenOrElse = *([[Maybe<[Token]>][SourcePosition]->]get,[]e){
            \get nextT nextS;
         };
      };
      \.ifNextTokenOrElse *([Maybe<[Token]>] m, [SourcePosition] p) {
         \m:isOrElse *([Token] t) {\token:set t} *{};
      } *{};
   } -> \token:get

   ++ gotoNextToken *{
      \.ifNextTokenOrElse *([Maybe<[Token]>] m, [SourcePosition] p) {
         \m:isOrElse *([Token] t) {\setToken p t;} *{};
         .ifNextTokenOrElse = *([]a,[->]else){\else};
      } *{

      \.currentToken:set (\[Maybe<[Token]>]:nothing);
      \:eatWhitespaceCharacters;

      \ifStrudelOrElse *{
         \[Loops]:while (*->[Boolean]{
                  [Maybe<[Character]>] currentCharacter = \.currentCharacter:get;
               }->\currentCharacter:isOrElse (*([Character] c)->\c:isStrudel) (*->\[Boolean]:false)) *{
            \:gotoNextCharacter;
            \ifStrudelOrElse *{
                     \:gotoNextCharacter;
                  [Variable<[Boolean]>] lastCharacterWasStrudel = \[Variable<[Boolean]>]:as (\[Boolean]:false);
                     \scanToken *([Character] thisCharacter, [->] continueScanning) {
                        \ifElse (thisCharacter:isStrudel) *{
                           \ifElse (lastCharacterWasStrudel:get) *{
                              \lastCharacterWasStrudel:set (\[Boolean]:false);
                              \:gotoNextCharacter;
                              \:eatWhitespaceCharacters;
                           } *{
                              \lastCharacterWasStrudel:set (\[Boolean]:true);
                              \continueScanning;
                           };
                        } *{
                           \lastCharacterWasStrudel:set (\[Boolean]:false);
                           \continueScanning;
                        };
               };
                  } *{
                     \scanToken *([Character] thisCharacter, [->] continueScanning) {
                        \ifElse (thisCharacter:isNewline) *{
                           \:eatWhitespaceCharacters;
                        } *{
                           \continueScanning;
                        };
               };
                  };
            };
        } *{};

        \ifHashOrElse *{
            [SourcePosition] position1 = .currentCharacterPosition;
         \:gotoNextCharacter;
         \ifHashOrElse *{
            \:gotoNextCharacter;
            [String] dataSegmentString = \stringFromCharacters *([[Character]->] useCharacter) {
               [Variable<[Character]>] variablePreviousCharacter = \[Variable<[Character]>]:as (\[Character]:space);
               \[Loops]:until *([->] stop) {
                  [Character] previousCharacter = \variablePreviousCharacter:get;
                  [Maybe<[Character]>] currentCharacter = (.currentCharacter:get);
                  \currentCharacter:isOrElse *([Character] char) {\variablePreviousCharacter:set char} *{};
                  \ifElse (previousCharacter:isHash) *{
                     \ifHashOrElse stop *{
                        \useCharacter previousCharacter;
                        \currentCharacter:isOrElse *([Character] char) {\useCharacter char} *{
                           \:addError (\[Error]:expectingSecondDataSegmentAnchor position1);
                           \stop;
                        };
                     };
                  } *{
                     \ifHashOrElse *{} *{
                        \currentCharacter:isOrElse *([Character] char) {\useCharacter char} *{\:addError (
                           \[Error]:expectingSecondDataSegmentAnchor position1);
                           \stop;
                        };
                     };
                  };
                  \:gotoNextCharacter;
               } 
            };
            \ifElse ((\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)}) *{
               \setToken position1 (\[Token]:dataSegment dataSegmentString);
            } *{};            
         } *{
            \:addError (\[Error]:expectingSecondHashForDataSegmentAnchor position1);
         }; 
        } *{
         [Maybe<[Character]>] currentCharacter = (.currentCharacter:get);
         \currentCharacter:isOrElse *([Character] character1) {
         [SourcePosition] position1 = .currentCharacterPosition;
         \:gotoNextCharacter;
         
         [Boolean] isIdentifier = \[Boolean]:or (\character1:isAlphanumeric) (\character1:isUnderscore);
         \isIdentifier:ifOrElse *{
            [String] identifierString = \stringFromCharacters *([[Character]->] useCharacter) {
               \useCharacter character1;
               \scanToken *([Character] thisCharacter, [->] continueScanning) {
                  [Boolean] thisCharacterIsForIdentifier = \[Boolean]:or (\thisCharacter:isAlphanumeric) (\thisCharacter:isUnderscore);
                  \thisCharacterIsForIdentifier:ifOrElse *{\useCharacter thisCharacter;\continueScanning;} *{};
               };
            };
            \setToken position1 (\[Token]:identifier identifierString);
         } *{};

         \if (character1:isDollarSign) *{
                  [Variable<[Integer]>] repetitionCount = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
                  \scanToken *([Character] thisCharacter, [->] continueScanning) {
                     \ifElse (thisCharacter:isDollarSign) *{
                        \repetitionCount:set (\x:adding (\[Integer]:as ##1##)) !{[Integer] x = \repetitionCount:get};
                        \continueScanning;
                     } *{};
                  };
                  \setToken position1 (\[Token]:parentIdentifier (\repetitionCount:get));
            };

            \if (*->\[Boolean]:or (\character1:isDash) (\character1:isPlus)) *{
                  \ifPlusOrDashOrElse (\[Maybe<[Character]>]:as character1) *{
                     \ifPlusOrDashOrElse .currentCharacter *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:false));
                        } *{
                           \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
                        };
                     } *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
                     };
                  } *{
                     \ifPlusOrDashOrElse .currentCharacter *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
                     };
                  } *{};
            };

         [Maybe<[Character]>] currentCharacter2 = (.currentCharacter:get);
         \currentCharacter2:isOrElse *([Character] character2) {
            [SourcePosition] position2 = .currentCharacterPosition;
                \if (character1:isDash) *{
                     \if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:arrow)};
                  };
                \if (character1:isAsterisk) *{
                     \if (character2:isCaret) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskCaret)};
                     \if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskArrow)};
                  };
                   \if (character1:isColon) *{
                     \if (character2:isColon) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleColon)};
                  };
                \if (character1:isArrowBracketOpen) *{
                     \if (character2:isArrowBracketOpen) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleLessThan)};
                     };
         } *{}; 

         \ifNoToken *{
            \if (character1:isAmpersand) *{\setToken position1 (\[Token]:ampersand)};
            \if (character1:isSingleApostrophe) *{\setToken position1 (\[Token]:singleApostrophe)};
            \if (character1:isArrowBracketOpen) *{\setToken position1 (\[Token]:arrowBracketOpen)};
            \if (character1:isArrowBracketClose) *{\setToken position1 (\[Token]:arrowBracketClose)};
            \if (character1:isAsterisk) *{\setToken position1 (\[Token]:asterisk)};
            \if (character1:isBackslash) *{\setToken position1 (\[Token]:backslash)};
            \if (character1:isCaret) *{\setToken position1 (\[Token]:caret)};
            \if (character1:isColon) *{\setToken position1 (\[Token]:colon)};
            \if (character1:isComma) *{\setToken position1 (\[Token]:comma)};
            \if (character1:isCurlyBracketOpen) *{\setToken position1 (\[Token]:curlyBracketOpen)};
            \if (character1:isCurlyBracketClose) *{\setToken position1 (\[Token]:curlyBracketClose)};
            \if (character1:isDoubleApostrophe) *{\setToken position1 (\[Token]:doubleApostrophe)};
            \if (character1:isEqualsSign) *{\setToken position1 (\[Token]:equalsSign)};
            \if (character1:isExclamationMark) *{\setToken position1 (\[Token]:exclamationMark)};
            \if (character1:isForwardslash) *{\setToken position1 (\[Token]:forwardSlash)};
            \if (character1:isFullstop) *{\setToken position1 (\[Token]:fullStop)};
            \if (character1:isPercentSign) *{\setToken position1 (\[Token]:percentSign)};
            \if (character1:isPipe) *{\setToken position1 (\[Token]:pipe)};
            \if (character1:isQuestionMark) *{\setToken position1 (\[Token]:questionMark)};
            \if (character1:isRoundBracketOpen) *{\setToken position1 (\[Token]:roundBracketOpen)};
            \if (character1:isRoundBracketClose) *{\setToken position1 (\[Token]:roundBracketClose)};
            \if (character1:isSemicolon) *{\setToken position1 (\[Token]:semicolon)};
            \if (character1:isSquareBracketOpen) *{\setToken position1 (\[Token]:squareBracketOpen)};
            \if (character1:isSquareBracketClose) *{\setToken position1 (\[Token]:squareBracketClose)};
            \if (character1:isTilde) *{\setToken position1 (\[Token]:tilde)};
         };
         
         \ifNoToken *{
            \:addError (\[Error]:unrecognisedToken (\character1:description) position1);
         };
      } *{} };   
      }; 
   }  !{
         [[SourcePosition][Token]->] setToken = *([SourcePosition] position, [Token] token) {
            \.currentToken:set (\[Maybe<[Token]>]:as token);
            \.currentTokenPosition:set position;
         };
         [[->]->] ifNoToken = *([->] noToken) {
            (\currentToken:isOrElse *{} noToken) !{[Maybe<[Token]>] currentToken = \.currentToken:get};
         };
         [[->[Boolean]][->]->] if = *([->[Boolean]] condition, [->] action) {
            [Boolean] result = \condition;
            \result:ifOrElse action *{};
         };
         [[->[Boolean]][->][->]->] ifElse = *([->[Boolean]] condition, [->] action, [->] else) {
            [Boolean] result = \condition;
            \result:ifOrElse action else;
         };
         [[[Character][->]->]->] scanToken = *([[Character][->]->] provideCharacterAndContinueScannning) {
            [Variable<[Boolean]>] continuing = \[Variable<[Boolean]>]:as (\[Boolean]:true);
            \[Loops]:while (continuing:get) *{
               \continuing:set (\[Boolean]:false);
               [Maybe<[Character]>] maybeCurrentCharacter = \.currentCharacter:get;
               \maybeCurrentCharacter:isOrElse *([Character] character) {
                  \provideCharacterAndContinueScannning character *{
                     \continuing:set (\[Boolean]:true);
                     \:gotoNextCharacter;
                  };
               } *{};
            };
         };
         [[[[Character]->]->]->[String]] stringFromCharacters = *([[[Character]->]->] getCharacters) -> [String] {
            [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
            \getCharacters *([Character] character) {
               \asciiString:append (\character:asASCII);
            };
         } -> \[String]:asASCII \[Data]:copy asciiString;
         [[->][->]->] ifStrudelOrElse = *([->] action, [->] else) {
            [Maybe<[Character]>] maybeCurrentCharacter = \.currentCharacter:get;
            \maybeCurrentCharacter:isOrElse *([Character] currentCharacter) {
               \ifElse (currentCharacter:isStrudel) action else;
            } else;
         };
         [[->][->]->] ifHashOrElse = *([->] action, [->] else) {
            [Maybe<[Character]>] maybeCurrentCharacter = \.currentCharacter:get;
            \maybeCurrentCharacter:isOrElse *([Character] currentCharacter) {
               \ifElse (currentCharacter:isHash) action else;
            } else;
         };
         [[Maybe<[Character]>][->][->][->]->] ifPlusOrDashOrElse = *([Maybe<[Character]>] maybeChar, [->] plus, [->] dash, [->] else) {
            \maybeChar:isOrElse *([Character] char) {
               \ifElse (char:isPlus) plus *{
                  \ifElse (char:isDash) dash else;
               };
            } else;
         };
      }
}



[Commands] (InputStream, CommandReader, Maybe, Byte, Debug, Boolean, String, Character, Loops, Variable, Data) 
   [->[Maybe<[Byte]>]] inputStream
   [Maybe<[Character]>] currentCharacter
{
   ~ from *([->[Maybe<[Byte]>]] inputStream) {
      .inputStream = inputStream;
      .currentCharacter = \[Maybe<[Character]>]:nothing;
      \:readNextCharacter;
   }

   ++ readNext *([CommandReader] reader) {
      \:eatWhitespaceCharacters;
      \.currentCharacter:isOrElse *([Character] character) {
         [Boolean] exit = (\character:isSemicolon);
         \exit:ifOrElse reader:exit *{};
         [Variable<[Boolean]>] validCommand = \[Variable<[Boolean]>]:as exit;
         [Boolean] parseSourceFile = (\character:isPlus);
         \parseSourceFile:ifOrElse *{
            \reader:parseSourceFile (\:readNextFilePath);
            \validCommand:set (\[Boolean]:true);
         } *{};
         [Boolean] compileToFile = (\character:isTilde);
         \compileToFile:ifOrElse *{
            [String] compilationMethod = \:readNextString (*([Character]c)->\c:isAlphanumeric);
            \:eatWhitespaceCharacters;
            [Boolean] colonPresent = (\.currentCharacter:isOrElse (*([Character]c)->\c:isColon) (*->\[Boolean]:false));
            \colonPresent:ifOrElse *{
               \reader:compileToFile (\:readNextFilePath);
               \validCommand:set (\[Boolean]:true);
            } *{};
         } *{};
         [Boolean] invalidCommand = \[Boolean]:not (\validCommand:get);
         \invalidCommand:ifOrElse *{
            \reader:invalidCommand;
            \:readNextCharacter;
         } *{};
      } (reader:exit);
   }

   - readNextCharacter *{
      .currentCharacter = \(\.inputStream):isOrElse ([Character]:fromASCII) ([Maybe<[Character]>]:nothing);
   }

   - readNextString *([[Character]->[Boolean]] inString) -> [String] {
      \:eatWhitespaceCharacters;
      [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
      \[Loops]:while (*->[Boolean]{
            [Variable<[Boolean]>] charcterInString = \[Variable<[Boolean]>]:as (\[Boolean]:false);
            \:readNextCharacter;
            \.currentCharacter:isOrElse *([Character] character) {
               \charcterInString:set (\inString character);
            } *{};
         } -> \charcterInString:get) *{
            \.currentCharacter:isOrElse *([Character] character) {
               \asciiString:append (\character:asASCII);
            } *{};
         };
   } -> \[String]:asASCII \[Data]:copy asciiString

   - readNextFilePath *-> [String] {
   } -> \:readNextString *([Character] c) ->[Boolean] {
      } -> \[Boolean]:or (\[Boolean]:or (\[Boolean]:or (\[Boolean]:or (\c:isAlphanumeric) (\c:isFullstop)) (\c:isForwardslash)) (\c:isBackslash)) (\c:isUnderscore)

   - eatWhitespaceCharacters *{
      \[Loops]:while (*->[Boolean]{
         [Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
         \.currentCharacter:isOrElse *([Character] character) {
            \isWhitespace:set (\character:isWhitespace);
         } *{};
      } -> \isWhitespace:get) (:readNextCharacter);
   }
}



@@
Analysis: analysing class - InternalValue...
Analysis: analysing class - InternalPointer...
Analysis: analysing class - Object...
Analysis: analysing class - Variable...
Analysis: analysing class - InternalNonReleasingReference...
Analysis: analysing class - WeakReference...
Analysis: analysing class - Boolean...
Analysis: analysing class - Container...
Analysis: analysing class - TrainCarriage...
Analysis: analysing class - ControlFlowRecursiveConstructor...
Analysis: analysing class - ControlFlowRecursiveTransformer...
Analysis: analysing class - SingleMapping...
Analysis: analysing class - BinaryTree...
Analysis: analysing class - Byte...
Analysis: analysing class - Conjecture...
Analysis: analysing class - LambdaAToB...
Analysis: analysing class - Wrapper...
Analysis: analysing class - CoreFlow...
Analysis: analysing class - Train...
Analysis: analysing class - ControlFlow2...
Analysis: analysing class - Maybe...
Analysis: analysing class - List...
Analysis: analysing class - Sequence...
Analysis: analysing class - Sequences2...
Analysis: analysing class - Data...
Analysis: analysing class - SetObject...
Analysis: analysing class - Integer...
Analysis: analysing class - Natural...
Analysis: analysing class - ControlFlow...
Analysis: analysing class - String...
Analysis: analysing class - Token...
Analysis: analysing class - Loops...
**Analysis: analysing class - SourcePosition...
**Analysis: analysing class - Error...
Analysis: analysing class - MappingBucket...
Analysis: analysing class - Mapping...
**Analysis: analysing class - CommandReader...
**Analysis: analysing class - Character...
Analysis: analysing class - O...
Analysis: analysing class - M...
Analysis: analysing class - SocketPort...
Analysis: analysing class - InternalSocketHeader...
Analysis: analysing class - DataStream...
Analysis: analysing class - AutomaticallyClosingSocketLink...
Analysis: analysing class - OutputStream...
Analysis: analysing class - SocketLinkOutputStream...
Analysis: analysing class - InputStream...
Analysis: analysing class - SocketLinkInputStream...
Analysis: analysing class - SocketConnection...
Analysis: analysing class - SocketBinding...
Analysis: analysing class - AutomaticallyClosingInputFileDataStream...
Analysis: analysing class - AutomaticallyClosingOutputFileDataStream...
Analysis: analysing class - IPAddress...
Analysis: analysing class - SystemInputOutput...
**Analysis: analysing class - Configuration...
Analysis: analysing class - Debug...
Analysis: analysing class - Parser...
Analysis: analysing class - Commands...

Analysis: analysing class - DainaGeneralIdentifier...
Analysis: analysing class - DainaGenericDeclarationList...
Analysis: analysing class - DainaDependancyStructure...
Analysis: analysing class - DainaClassIdentifier...
Analysis: analysing class - DainaType...
Analysis: analysing class - DainaObjectDeclaration...
Analysis: analysing class - DainaClassMethod...
Analysis: analysing class - DainaCompilerInjection...
Analysis: analysing class - DainaExpression...
Analysis: analysing class - DainaClass...
Analysis: analysing class - DLangSynthesizer...
Analysis: analysing class - Daina...


@@


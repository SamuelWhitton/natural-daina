@@



ControlFlow : []
	:: repeatWhile [[ -> [Boolean]],[ -> ] -> ]
	:: ifThenElse [[ -> [Boolean]],[ -> ],[ -> ] -> ]
	:: repeatNTimes [[Natural],[[Natural] -> ] -> ]

@@





[ControlFlow<Q [Object]>] (Boolean, Natural, Wrapper, Object, CoreFlow, Variable, VariableReturnerOfThing)
{
	:: repeatWhile *([->[Boolean]] conditionForRepeat, [->] lambdaToRepeat) {
		\[CoreFlow]:repeatUntilStopped *([->] stop) {
			\[ControlFlow]:ifThenElse conditionForRepeat lambdaToRepeat stop;
		};
	}

	:: ifThenElse *([->[Boolean]] conditionForIf, [->] onTrue, [->] onFalse) {
		[Boolean] conditionResult = \conditionForIf;
		\conditionResult:ifTrue onTrue;
		\conditionResult:ifFalse onFalse;
	}

	:: selectWithSelectorOrDefault *([[[&Q]->]->] selector, [->[&Q]] default) -> [&Q] {
		[Variable<[&Q]>] returnThing = \[Variable<[&Q]>]:as (\default);
		\selector *([&Q] selectedThing) {
			\returnThing:set (selectedThing);
		};

		@compiler if segfaulting here, just ignore it untill we trash this compiler
		@@[VariableReturnerOfThing<[&Q]>] currentSelection = \[VariableReturnerOfThing<[&Q]>]:as default;
		\selector *([&Q] selectedThing) {
			\currentSelection:set (*->selectedThing);
		};
		[->[&Q]] finalSelection = \currentSelection:get;@@
	} -> (\returnThing:get)

	:: repeatNTimes *([Natural] numberOfTimesToRepeat, [[Natural]->] lambdaToRepeatReceivingCurrentCount) {
		[Wrapper<[Natural]>] wrappedCurrentCount = \[Wrapper<[Natural]>]:wrapperWithObject (\[Natural]:one);

		(\[ControlFlow]:repeatWhile currentCountHasNotExceededNumberOfTimesToRepeat *{
			\lambdaToRepeatReceivingCurrentCount \wrappedCurrentCount:unwrap;
			\incrementCount;

		})	!{
				[->[Boolean]] currentCountHasNotExceededNumberOfTimesToRepeat = *-> (\numberOfTimesToRepeat:isGreaterThanOrEqualTo \wrappedCurrentCount:unwrap);
				
				[->] incrementCount = *{
					\wrappedCurrentCount:transformStoredObject *([Natural] count)-> (\count:naturalByAddingOne);
				};
			};
	}

	:: repeatUntilStopped *([[->]->] lambdaToRepeatUntilStopped) {
		[Wrapper<[Boolean]>] wrappedShouldStop = \[Wrapper<[Boolean]>]:wrapperWithObject \[Boolean]:false;
		[Boolean] shouldStop = \[Boolean]:false;
		[->] stopCommand = *{\wrappedShouldStop:store \[Boolean]:true;};
	    	<instant
		##
			while (0==0) {
		##;
		\lambdaToRepeatUntilStopped stopCommand;
		shouldStop = \wrappedShouldStop:unwrap;
		<instant
		##
			if (!((struct Z_template_Boolean *)(Z_local_shouldStop))->Z_attribute_Boolean_internalBoolean) {
		##;
		<instant
		##
			} else {
				break;
			}
			}
		##;
	}

}


[VariableReturnerOfThing<THING [Object]> : [Object]] (Object)
	[->[&THING]] thingThatReturns
{
	~ as *([->[&THING]] thingThatReturns) {
		\::newObject;
		.thingThatReturns = thingThatReturns
	}

	++ set *([->[&THING]] thingThatReturns) {
		.thingThatReturns = thingThatReturns
	}

	++ get *->.thingThatReturns
}









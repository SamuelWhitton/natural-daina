

[Sequence<ENUMERATED_OBJECT [Object]> : [Object]] (Object, Boolean, LambdaAToB, Variable)
	[[->][[&ENUMERATED_OBJECT][Sequence<[&ENUMERATED_OBJECT]>]->]->] ifEmptySequence_and_ifFirstAndRestOfSequence
{	
	~ emptySequence *{
		\::newObject;
		.ifEmptySequence_and_ifFirstAndRestOfSequence = *([->] onEmptySequence, [[&ENUMERATED_OBJECT][Sequence<[&ENUMERATED_OBJECT]>]->] onFirstInSequenceAndRestOfList) {
			\onEmptySequence;
		}
	}

	~ sequenceWithFirstAndRestOfSequenceProvider *([&ENUMERATED_OBJECT] firstInSequence, [->[Sequence<[&ENUMERATED_OBJECT]>]] provideRestOfSequence){
		\::newObject;
		.ifEmptySequence_and_ifFirstAndRestOfSequence = *([->] onEmptySequence, [[&ENUMERATED_OBJECT][Sequence<[&ENUMERATED_OBJECT]>]->] onFirstInSequenceAndRestOfList) {
			\onFirstInSequenceAndRestOfList firstInSequence (\provideRestOfSequence);
		}
	}

	++ ifEmptySequence *([->] onEmptySequence) {
		\.ifEmptySequence_and_ifFirstAndRestOfSequence onEmptySequence (*([]_,[]__){})
	}

	++ ifFirstAndRestOfSequence *([[&ENUMERATED_OBJECT][Sequence<[&ENUMERATED_OBJECT]>]->] onFirstInSequenceAndRestOfList) {
		\.ifEmptySequence_and_ifFirstAndRestOfSequence (*{}) onFirstInSequenceAndRestOfList
	}
}

[Sequences<ENUMERATED_OBJECT [Object], A [Object]>] (Boolean, Object, Variable, Sequence, ControlFlow, LambdaAToB)
{
	:: iterateThroughSequenceWithReceiver *([Sequence<[&ENUMERATED_OBJECT]>] sequence, [[&ENUMERATED_OBJECT]->] receiveElement) {
		[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>] variableUniteratedSequence = \[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>]:as sequence;
		\[ControlFlow]:repeatUntilStopped sendEachElementToReceiverUntilEndOfSequence
			!{
				[[->]->] sendEachElementToReceiverUntilEndOfSequence = *([->] stopSinceEndOfSequenceWasReached) {
					[Sequence<[&ENUMERATED_OBJECT]>] currentUniteratedSequence = \variableUniteratedSequence:get;
					\currentUniteratedSequence:ifEmptySequence stopSinceEndOfSequenceWasReached;
					\currentUniteratedSequence:ifFirstAndRestOfSequence *([&ENUMERATED_OBJECT] firstInSequence, [Sequence<[&ENUMERATED_OBJECT]>] restOfSequence) {
						\receiveElement firstInSequence;
						\variableUniteratedSequence:set restOfSequence;
					}
				}
			}
	}	

	:: sequenceByAppendingSequenceToSequence *([Sequence<[&ENUMERATED_OBJECT]>] firstSequence, [Sequence<[&ENUMERATED_OBJECT]>] secondSequence) -> [Sequence<[&ENUMERATED_OBJECT]>] {
		[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>] sequenceToResturn = \[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>]:as secondSequence;
		\firstSequence:ifFirstAndRestOfSequence *([&ENUMERATED_OBJECT] firstInSequence, [Sequence<[&ENUMERATED_OBJECT]>] restOfSequence) {
			\sequenceToResturn:set sequenceResult
				!{
					[Sequence<[&ENUMERATED_OBJECT]>] sequenceResult = \[Sequence<[&ENUMERATED_OBJECT]>]:sequenceWithFirstAndRestOfSequenceProvider firstInSequence (*->(\[Sequences<[&ENUMERATED_OBJECT]>]:sequenceByAppendingSequenceToSequence restOfSequence secondSequence))
						!{
						}
				}
		};
	} -> (\sequenceToResturn:get)

	:: foldSequenceWithInitialResultAndOperationToFoldResultIntoSequenceElement *([Sequence<[&ENUMERATED_OBJECT]>] givenSequence, [&A] initialResult, [[&A][&ENUMERATED_OBJECT]->[&A]] operationToFoldResultIntoSequenceElement) -> [&A] {
		[Variable<[&A]>] currentResult = \[Variable<[&A]>]:as initialResult;
		[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>] currentUnfoldedSequence = \[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>]:as givenSequence;
		\[ControlFlow]:repeatUntilStopped *([->] stopFolding) {
			[Sequence<[&ENUMERATED_OBJECT]>] unfoldedSequence = \currentUnfoldedSequence:get;
			\unfoldedSequence:ifEmptySequence stopFolding;
			\unfoldedSequence:ifFirstAndRestOfSequence foldFirstInSequenceAndSetCurrentUnfoldedSequenceToRestOfSequence
				!{
					[[&ENUMERATED_OBJECT][Sequence<[&ENUMERATED_OBJECT]>]->] foldFirstInSequenceAndSetCurrentUnfoldedSequenceToRestOfSequence = *([&ENUMERATED_OBJECT] firstInSequence, [Sequence<[&ENUMERATED_OBJECT]>] restOfSequence) {
						\currentResult:set (\operationToFoldResultIntoSequenceElement (\currentResult:get) firstInSequence); 
						\currentUnfoldedSequence:set restOfSequence;
					}
				}
		}
	} -> (\currentResult:get)

	:: sequenceByMappingTransformationOverSequence *([[&ENUMERATED_OBJECT]->[&A]] transformation, [Sequence<[&ENUMERATED_OBJECT]>] givenSequence) -> [Sequence<[&A]>] {
		[Variable<[Sequence<[&A]>]>] sequenceToResturn = \[Variable<[Sequence<[&A]>]>]:as (\[Sequence<[&A]>]:emptySequence);
		\givenSequence:ifFirstAndRestOfSequence *([&ENUMERATED_OBJECT] firstInSequence, [Sequence<[&ENUMERATED_OBJECT]>] restOfSequence) {
			\sequenceToResturn:set (\[Sequence<[&A]>]:sequenceWithFirstAndRestOfSequenceProvider (\transformation firstInSequence) (*()->[Sequence<[&A]>]{[Sequence<[&A]>] res = \[Sequences<[&ENUMERATED_OBJECT][&A]>]:sequenceByMappingTransformationOverSequence transformation restOfSequence}->res)); 
		}
	} -> (\sequenceToResturn:get)

	:: sequenceByFlatteningSequenceOfSequences *([Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>] sequenceOfSequencesToFlattern) -> [Sequence<[&ENUMERATED_OBJECT]>] {
		[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>] sequenceToResturn = \[Variable<[Sequence<[&ENUMERATED_OBJECT]>]>]:as (\[Sequence<[&ENUMERATED_OBJECT]>]:emptySequence);
		\sequenceOfSequencesToFlattern:ifFirstAndRestOfSequence *([Sequence<[&ENUMERATED_OBJECT]>] firstSequenceInSequence, [Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>] restOfSequenceOfSequences) {
			\sequenceToResturn:set (\[Sequences<[&ENUMERATED_OBJECT]>]:sequenceByAppendingSequenceToSequence firstSequenceInSequence flatterendRestOfSequences)
				!{
					[Sequence<[&ENUMERATED_OBJECT]>] flatterendRestOfSequences = (\[Sequences<[&ENUMERATED_OBJECT]>]:sequenceByFlatteningSequenceOfSequences restOfSequenceOfSequences);
				};
		};
	} -> (\sequenceToResturn:get)
@@
	:: sequenceBySplittingSequenceWithShouldSplitOnGivenElement *([Sequence<[&ENUMERATED_OBJECT]>] sequenceToSplit, [[&ENUMERATED_OBJECT]->[Boolean]] shouldSplitOnGivenElement) -> [Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>] {
		[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>] splittedSequenceOfSequences = \[ControlFlow<[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]>]:selectWithSelectorOrDefault *([[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]->] selectSplittedSequenceOfSequences) {
			\sequenceToSplit:ifFirstAndRestOfSequence *([&ENUMERATED_OBJECT] firstInSequenceToSplit, [Sequence<[&ENUMERATED_OBJECT]>] restOfSequenceToSplit) {
				[Boolean] firstInSequenceToSplitIsSplitter = \shouldSplitOnGivenElement firstInSequenceToSplit;
				\firstInSequenceToSplitIsSplitter:ifTRUE *{
					\selectSplittedSequenceOfSequences (\[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]:sequenceWithFirstAndRestOfSequenceProvider 
						(\[Sequence<[&ENUMERATED_OBJECT]>]:emptySequence) (*->\[Sequences<[&ENUMERATED_OBJECT]>]:sequenceBySplittingSequenceWithShouldSplitOnGivenElement restOfSequenceToSplit shouldSplitOnGivenElement))
				};
				\firstInSequenceToSplitIsSplitter:ifFALSE *{
					[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>] splittedRestOfSequence = (\[Sequences<[&ENUMERATED_OBJECT]>]:sequenceBySplittingSequenceWithShouldSplitOnGivenElement restOfSequenceToSplit shouldSplitOnGivenElement);
					\splittedRestOfSequence:ifEmptySequence *{\selectSplittedSequenceOfSequences (\[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]:sequenceWithFirstAndRestOfSequenceProvider (\[Sequence<[&ENUMERATED_OBJECT]>]:sequenceWithFirstAndRestOfSequenceProvider firstInSequenceToSplit (*->\[Sequence<[&ENUMERATED_OBJECT]>]:emptySequence)) (*->\[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]:emptySequence))};
					\splittedRestOfSequence:ifFirstAndRestOfSequence *([Sequence<[&ENUMERATED_OBJECT]>] firstInSplittedRestOfSequence, [Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>] restOfSplittedRestOfSequence){
						[Sequence<[&ENUMERATED_OBJECT]>] firstInSplittedSequence = \[Sequence<[&ENUMERATED_OBJECT]>]:sequenceWithFirstAndRestOfSequenceProvider firstInSequenceToSplit (*->firstInSplittedRestOfSequence);
						\selectSplittedSequenceOfSequences (\[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]:sequenceWithFirstAndRestOfSequenceProvider firstInSplittedSequence (*->restOfSplittedRestOfSequence))
					}
				};
			}
		} (*->\[Sequence<[Sequence<[&ENUMERATED_OBJECT]>]>]:emptySequence);
	} -> splittedSequenceOfSequences
@@
	:: sequenceWithIterator *([[[&ENUMERATED_OBJECT]->]->] iterateElementsInSequence) -> [Sequence<[&ENUMERATED_OBJECT]>] {
		[Variable<[LambdaAToB<[Sequence<[&ENUMERATED_OBJECT]>][Sequence<[&ENUMERATED_OBJECT]>]>]>] variableSequenceCreatedFromIteratingElementsInSequencePrependedToGivenTailSequence = \[Variable<[LambdaAToB<[Sequence<[&ENUMERATED_OBJECT]>][Sequence<[&ENUMERATED_OBJECT]>]>]>]:as (\[LambdaAToB<[Sequence<[&ENUMERATED_OBJECT]>][Sequence<[&ENUMERATED_OBJECT]>]>]:as (*([Sequence<[&ENUMERATED_OBJECT]>]a)->a));
		\iterateElementsInSequence consumeEachElementToBuildSequence
			!{
				[[&ENUMERATED_OBJECT]->] consumeEachElementToBuildSequence = *([&ENUMERATED_OBJECT] nextElementInSequence) {
					[LambdaAToB<[Sequence<[&ENUMERATED_OBJECT]>][Sequence<[&ENUMERATED_OBJECT]>]>] originalSequencePrependedToGivenTail = \variableSequenceCreatedFromIteratingElementsInSequencePrependedToGivenTailSequence:get;
					\variableSequenceCreatedFromIteratingElementsInSequencePrependedToGivenTailSequence:set (\[LambdaAToB<[Sequence<[&ENUMERATED_OBJECT]>][Sequence<[&ENUMERATED_OBJECT]>]>]:as 
						(*([Sequence<[&ENUMERATED_OBJECT]>]tailSequence)-> \originalSequencePrependedToGivenTail:do (\[Sequence<[&ENUMERATED_OBJECT]>]:sequenceWithFirstAndRestOfSequenceProvider nextElementInSequence (*->tailSequence))));
				}
			};
		[LambdaAToB<[Sequence<[&ENUMERATED_OBJECT]>][Sequence<[&ENUMERATED_OBJECT]>]>] sequenceCreatedFromIteratingElementsInSequencePrependedToGivenTailSequence = \variableSequenceCreatedFromIteratingElementsInSequencePrependedToGivenTailSequence:get;
	} -> (\sequenceCreatedFromIteratingElementsInSequencePrependedToGivenTailSequence:do (\[Sequence<[&ENUMERATED_OBJECT]>]:emptySequence))
}


















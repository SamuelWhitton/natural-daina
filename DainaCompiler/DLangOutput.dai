

[DLangSynthesizer] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,
			OutputStream,
			DainaClass,
			Integer,
			DainaGeneralIdentifier,
			Mapping,
			Debug
		)
	[OutputStream] output
	[Integer] tab
	[Mapping<[String][DainaClass]>] mappedClasses
	[Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>] mappedClassMethods
	[Integer] temporaryNumber
{
	~ to *([OutputStream] output) {
		.tab = \[Integer]:zero;
		.output = output;
		.mappedClasses = \[Mapping<[String][DainaClass]>]:empty;
		.mappedClassMethods = \[Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>]:empty;
		.temporaryNumber = \[Integer]:zero;
	}

	- outputNextTemporaryVariableName *{
		.temporaryNumber = \.temporaryNumber:adding (\[Integer]:one);
		\:output (\[String]:as "temp");
		\:output (\[String]:stringRepresentationOfInteger .temporaryNumber);
	}

	- output *([String] string) {
		\.output:writeString string;
	}

	- outputTabbed *([String] string) {
		\[Loops]:repeatNTimes .tab *{
			\.output:writeString (\[String]:as "   ");
		};
		\.output:writeString string;
	}

	- incrementTab *{
		.tab = \.tab:integerByAdding (\[Integer]:one);
	}

	- decrementTab *{
		.tab = \.tab:integerBySubtracting (\[Integer]:one);
	}

	- iterateUnoverridenInstanceMethods *([DainaClass] class, [[Integer][DainaClassMethod<[DainaExpression]>]->] get) {
		\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
		} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
			[Variable<[Integer]>] varParentNumber = \[Variable<[Integer]>]:as (\[Integer]:one);
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				[Integer] parentNumber = \varParentNumber:get;
				\varParentNumber:set (\parentNumber:adding (\[Integer]:one));
				\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
					[String] parentID = (\parentTypeIdentifier:content);
					\.mappedClasses:retriveMappedValueWithKey parentID *([DainaClass] parentClass) {
						\:iterateUnoverridenInstanceMethods parentClass *([Integer] i, [DainaClassMethod<[DainaExpression]>]c) {
							\getIfNotOverriden parentNumber c;
						};
						\parentClass:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
						} *([DainaClassIdentifier] a1, [List<[DainaType]>] a2, [List<[DainaObjectDeclaration]>] a3, [List<[DainaClassMethod<[DainaExpression]>]>] parentClassMethods, [List<[DainaCompilerInjection]>] a5) {
							\parentClassMethods:iterate *([DainaClassMethod<[DainaExpression]>] parentClassMethod) {
								\getIfNotOverriden parentNumber parentClassMethod;
							};
						};
					}; 	
				};
			};

		} !{
				[[Integer][DainaClassMethod<[DainaExpression]>]->] getIfNotOverriden = *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] parentMethod) {
					[DainaGeneralIdentifier] parentMethodIdentifier = \parentMethod:identifier;
					\.mappedClassMethods:retriveMappedValueWithKey (\className:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] ownClassMethods) {
						[Maybe<[DainaClassMethod<[DainaExpression]>]>] ifOverriden = \ownClassMethods:maybeRetriveMappedValueWithKey (\parentMethodIdentifier:content);
						\ifOverriden:ifNothing *{
							\get parentNumber parentMethod;
						};
					};
				};
		   };
	}	

	++ synthesizeClasses *([List<[DainaClass]>] classes) {
		\classes:iterate *([DainaClass] class) {
			\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
			} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
				\.mappedClasses:mapKeyToValue (\className:content) class;
				[Mapping<[String][DainaClassMethod<[DainaExpression]>]>] classMethodsMapping = \[Mapping<[String][DainaClassMethod<[DainaExpression]>]>]:empty;
				\classMethods:iterate *([DainaClassMethod<[DainaExpression]>] classMethod) {
					[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
					\classMethodsMapping:mapKeyToValue (\classMethodIdentifier:content) classMethod;
				};
				\.mappedClassMethods:mapKeyToValue (\className:content) classMethodsMapping;
			};	
		};
		\:output (\[String]:as "/* *** HEADER *** */\n");
		\:output (\[String]:as "interface OBJECT {}\n");
		\:output (\[String]:as "interface LAMBDA {\n   OBJECT method(OBJECT caller, OBJECT[] parameters);\n}\n\n");
		\classes:iterate :synthesizeClass;
	}

	- synthesizeClass *([DainaClass] class) {
		\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
			\:output (\[String]:as "/* *** ENTRY POINT CLASS *** */\n");
			\:output (\[String]:as "void main() { ENTRY_POINT_CLASS.entryPointMethod(null, []); }\n"); 
			\:output (\[String]:as "class ENTRY_POINT_CLASS {\n");
			\:output (\[String]:as "   static OBJECT entryPointMethod(OBJECT caller, OBJECT[] parameters) {\n"); \:incrementTab; \:incrementTab;
			\:synthesizeMethodBodyContent entryPointMethod; 
			\:decrementTab; \:decrementTab; \:output (\[String]:as "   }\n}\n\n");
		} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
			\:output (\[String]:as "/* *** CLASS: ");
			\:output (\className:content);
			\:output (\[String]:as " *** */\n");
			\:output (\[String]:as "interface CLASSTYPE_");
			\:output (\className:content);
			\:output (\[String]:as " : OBJECT, LAMBDA");
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				\:output (\[String]:as ", ");
				\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
					\:output (\[String]:as "CLASSTYPE_");
					\:output (\parentTypeIdentifier:content);
				};
			};
			\:output (\[String]:as " {\n"); \:incrementTab;
			\classMethods:iterate :synthesizeClassMethodInterface;
			\:decrementTab; \:output (\[String]:as "}\n");
			\:output (\[String]:as "class CLASSIMPL_");
			\:output (\className:content);
			\:output (\[String]:as " : CLASSTYPE_");
			\:output (\className:content);
			\:output (\[String]:as " {\n"); \:incrementTab;
			\:outputTabbed (\[String]:as "override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n");
			[Variable<[Integer]>] parentNumber = \[Variable<[Integer]>]:as (\[Integer]:one);
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				[Integer] curr = \parentNumber:get;
				\:synthesizeParentObjectDeclaration curr parentType;
				\parentNumber:set (\curr:adding (\[Integer]:one));
			};
			\instanceObjects:iterate :synthesizeInstanceObjectDeclaration;
			\:iterateUnoverridenInstanceMethods class (:synthesizeParentUnoverridenMethod);
			\classMethods:iterate :synthesizeClassMethodImplementation;
			\:decrementTab; \:output (\[String]:as "}\n\n");
		};
	}

	- synthesizeInstanceObjectDeclaration *([DainaObjectDeclaration] instanceObject) {
		\:outputTabbed (\[String]:as "private OBJECT IOBJECT_");
		[DainaGeneralIdentifier] instanceObjectIdentifier = \instanceObject:identifier;
		\:output (\instanceObjectIdentifier:content);
		\:output (\[String]:as " = null;\n");
	}

	- synthesizeParentObjectDeclaration *([Integer] parentNumber, [DainaType] parentType) {
		\:outputTabbed (\[String]:as "private ");
		\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
			\:output (\[String]:as "CLASSTYPE_");
			\:output (\parentTypeIdentifier:content);
		};
		\:output (\[String]:as " ");
		\:output (\[String]:as "PARENT_");
		\:output (\[String]:stringRepresentationOfInteger parentNumber);
		\:output (\[String]:as " = new ");
		\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
			\:output (\[String]:as "CLASSIMPL_");
			\:output (\parentTypeIdentifier:content);
		};
		\:output (\[String]:as "();\n");
	}

	- synthesizeParentUnoverridenMethod *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] unoverridenMethod) {
		\unoverridenMethod:isInstanceTypeOrConstructor *{
			[DainaGeneralIdentifier] unoverridenMethodIdentifier = \unoverridenMethod:identifier;
			\:outputTabbed (\[String]:as "override OBJECT IMETHOD_");
			\:output (\unoverridenMethodIdentifier:content);
			\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters) { return PARENT_");
			\:output (\[String]:stringRepresentationOfInteger parentNumber);
			\:output (\[String]:as ".IMETHOD_");
			\:output (\unoverridenMethodIdentifier:content);
			\:output (\[String]:as "(caller, parameters); }\n");
		} *{} *{};
	}


	- synthesizeClassMethodInterface *([DainaClassMethod<[DainaExpression]>] classMethod) {
		\classMethod:isInstanceTypeOrConstructor *{
			[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
			\classMethod:isInstanceTypeOrConstructor *{
				\:outputTabbed (\[String]:as "OBJECT IMETHOD_");
			} *{
				\:outputTabbed (\[String]:as "OBJECT TMETHOD_");
			} *{
				\:outputTabbed (\[String]:as "OBJECT CMETHOD_");
			};
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters);\n");
		} *{} *{};
	}

	- synthesizeClassMethodImplementation *([DainaClassMethod<[DainaExpression]>] classMethod) {
		[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
		\[O]:ifElse (\classMethod:isUnimplementedMethod) *{
			\:outputTabbed (\[String]:as "private LAMBDA ASSIGNIMETHOD_");
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as " = null;\n");
		} *{};
		\classMethod:isInstanceTypeOrConstructor *{
			\:outputTabbed (\[String]:as "override OBJECT IMETHOD_");
		} *{
			\:outputTabbed (\[String]:as "static OBJECT TMETHOD_");
		} *{
			\:outputTabbed (\[String]:as "static OBJECT CMETHOD_");
		};
		\:output (\classMethodIdentifier:content);
		\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters)");
		\:output (\[String]:as " {\n"); \:incrementTab;
		\[O]:ifElse (\classMethod:isUnimplementedMethod) *{
			\:outputTabbed (\[String]:as "return ASSIGNIMETHOD_");
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as ".method(caller, parameters);\n");
		} *{
			\:synthesizeMethodBodyContent (\classMethod:methodExpression);
		};
		\:decrementTab; \:outputTabbed (\[String]:as "}\n");
	}


	- pushScope *([List<[DainaObjectDeclaration]>] parameters) {
		@ params are LOBJECT_
	}

	- popScope *{
		
	}

	- pushPrologueScope *{

	}

	- pushPrelogueScopeAfterPrologue *{

	}

	- popPrelogueAndPrologueScope *{

	}

	- addLocalObjectToScope *([DainaObjectDeclaration] localObject) {

	}


	- synthesizeMethodBodyContent *([DainaExpression] methodExpression) {
		\[O]:selectOrDefault *([->] select) {
			\methodExpression:ifMethodExpression *([List<[DainaObjectDeclaration]>] inputs, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
				\select;
				\:pushScope inputs; 
				\:synthesizeStatement body (\[Boolean]:true);
				\output:ifNothing *{
					\:outputTabbed (\[String]:as "return null;\n");
				};
				\output:ifIs *([DainaExpression] outputExpression) {
					\:outputTabbed (\[String]:as "return ");
					\:synthesizeInPlaceExpression outputExpression;
					\:output (\[String]:as ";\n");
				};
				\:popScope;
			};
		} *{
			\:outputTabbed (\[String]:as "return ");
			\:synthesizeInPlaceExpression methodExpression;
			\:output (\[String]:as ";\n");
		};
	}

	- synthesizeStatement *([DainaExpression] statement, [Boolean] baseStatement) {
		\[O]:selectOrDefault *([->] select) {
			\statement:ifStatementGroup *([List<[DainaExpression]>] statements) {
				\select;
				\[O]:ifElse baseStatement *{} *{
					\:pushScope (\[List<[DainaObjectDeclaration]>]:empty); 
					\:outputTabbed (\[String]:as "{\n");
					\:incrementTab;
				};
				\statements:iterate *([DainaExpression] subStatement) {
					\:synthesizeStatement subStatement (\[Boolean]:false);
				};
				\[O]:ifElse baseStatement *{} *{
					\:decrementTab;
					\:outputTabbed (\[String]:as "}\n");
					\:popScope;
				};
			};
			\statement:ifWithPrologueStatement *([DainaExpression] prelogueStatement, [DainaExpression] prologueStatement) {
				\select;
				\:pushPrologueScope;
				\:synthesizeStatement prologueStatement (\[Boolean]:true);
				\:pushPrelogueScopeAfterPrologue;
				\:synthesizeStatement prelogueStatement (baseStatement);
				\:popPrelogueAndPrologueScope;
			};
			\statement:ifLocalObjectAssignment *([DainaObjectDeclaration] declaration, [DainaExpression] assginedExpression) {
				\select;
				\:addLocalObjectToScope declaration;
				[DainaGeneralIdentifier] identifier = \declaration:identifier;
				\:outputTabbed (\[String]:as "OBJECT LOBJECT_");
				\:output (\identifier:content);
				\:output (\[String]:as " = ");
				\:synthesizeInPlaceExpression assginedExpression;
				\:output (\[String]:as ";\n");
			};
			\statement:ifInvocation *([] a, [] b) {
				\select;
				\:outputTabbed (\[String]:as "");
				\:synthesizeInPlaceExpression statement;
				\:output (\[String]:as ";\n");
			};
			\statement:ifInstanceMethodAssignment *([DainaGeneralIdentifier] identifier, [DainaExpression] assignedExpression) {
				\select;
				\:outputTabbed (\[String]:as "ASSIGNIMETHOD_");
				\:output (\identifier:content);
				\:output (\[String]:as " = ");
				\:synthesizeInPlaceExpression assignedExpression;
				\:output (\[String]:as ";\n");
			};
			\statement:ifInstanceObjectAssignment *([DainaGeneralIdentifier] identifier, [DainaExpression] assignedExpression) {
				\select;
				\:outputTabbed (\[String]:as "IOBJECT_");
				\:output (\identifier:content);
				\:output (\[String]:as " = ");
				\:synthesizeInPlaceExpression assignedExpression;
				\:output (\[String]:as ";\n");
			};
			\statement:ifConstructorInvocation *([Integer] parentNumber, [DainaGeneralIdentifier] identifier, [Boolean] isPointerConstructor, [List<[DainaExpression]>] inputs) {
				\select;
				\[O]:ifElse isPointerConstructor *{
					\:outputTabbed (\[String]:as "PARENT_");
					\:output (\[String]:stringRepresentationOfInteger parentNumber);
					\:output (\[String]:as " = ");
					\:synthesizeMethodInputs inputs;
					\:output (\[String]:as ";\n");
				} *{
					\:outputTabbed (\[String]:as "PARENT_");
					\:output (\[String]:stringRepresentationOfInteger parentNumber);
					\:output (\[String]:as ".CMETHOD_");
					\:output (\identifier:content);
					\:output (\[String]:as "(PARENT_");
					\:output (\[String]:stringRepresentationOfInteger parentNumber);
					\:output (\[String]:as ", [");
					\:synthesizeMethodInputs inputs;
					\:output (\[String]:as "]);\n");
				};
			};
		} *{
			\:outputTabbed (\[String]:as "INTERNAL STATEMENT ERROR!!!\n");
		};
	}

	- synthesizeMethodInputs *([List<[DainaExpression]>] inputs) {
		[Variable<[String]>] seperator = \[Variable<[String]>]:as (\[String]:as "");
		\inputs:iterate *([DainaExpression] input) {
			\:output (\seperator:get);
			\:synthesizeInPlaceExpression input;
			\seperator:set (\[String]:as ", ");
		};
	}

	- synthesizeInPlaceExpression *([DainaExpression] expression) {
		\[O]:selectOrDefault *([->] select) {
			\expression:ifWithPrologueStatement *([DainaExpression] prelogue, [DainaExpression] prologue) {
				\select;
				\:output (\[String]:as "(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n");
				\:incrementTab;
				\:synthesizeStatement prologue (\[Boolean]:true);
				\[O]:selectOrDefault *([->] selectInner) {
					\prelogue:ifStatementGroup *([] a) {
						\selectInner;
						\:outputTabbed (\[String]:as "return ");
						\:synthesizeInPlaceExpression prelogue;
						\:output (\[String]:as ";\n");
					};
				} *{
					\:synthesizeStatement prelogue (\[Boolean]:true);
					\:outputTabbed (\[String]:as "return caller;\n");
				};
				\:decrementTab;
				\:outputTabbed (\[String]:as "} }).method(caller, [])");
			};
			\expression:ifLocalObject *([DainaGeneralIdentifier] identifier) {
				\select;
				\:output (\[String]:as "LOBJECT_");
				\:output (\identifier:content);
			};
			\expression:ifMethodExpression *([List<[DainaObjectDeclaration]>] params, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
				\select;
				\:output (\[String]:as "(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n");
				\:incrementTab;
				\:synthesizeMethodBodyContent expression;
				\:decrementTab;
				\:outputTabbed (\[String]:as "} })");
			};
			\expression:ifInstanceMethod *([DainaExpression] instanceExpression, [DainaGeneralIdentifier] identifier) {
				\select;
				\:output (\[String]:as "(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n");
				\:incrementTab;
				\:outputTabbed (\[String]:as "LAMBDA instance = ");
				\:synthesizeInPlaceExpression instanceExpression;
				\:output (\[String]:as ";\n");
				\:outputTabbed (\[String]:as "return instance.IMETHOD_");
				\:output (\identifier:content);
				\:output (\[String]:as "(instance, parameters);\n");
				\:decrementTab;
				\:outputTabbed (\[String]:as "} })");
			};
			\expression:ifTypeMethod *([DainaType] type, [DainaGeneralIdentifier] identifier) {
				\select;
				\:output (\[String]:as "(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n");
				\:incrementTab;
				\:outputTabbed (\[String]:as "return ");
				\type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
					\:output (\[String]:as "CLASSIMPL_");
					\:output (\typeIdentifier:content);
				};
				\:output (\[String]:as ".TMETHOD_");
				\:output (\identifier:content);
				\:output (\[String]:as "(caller, parameters);\n");
				\:decrementTab;
				\:outputTabbed (\[String]:as "} })");
			};
			\expression:ifInvocation *([DainaExpression] method, [List<[DainaExpression]>] params) {
				\select;
				\:synthesizeInPlaceExpression method;
				\:output (\[String]:as ".method(caller, [");
				\:synthesizeMethodInputs params;
				\:output (\[String]:as "])");
			};
			@@\expression:ifInvocation *([DainaExpression] method, [List<[DainaExpression]>] params) {
				\select;
				\:synthesizeInPlaceExpression method;
				\:output (\[String]:as ".(caller, [");
				\:synthesizeMethodInputs params
				\:output (\[String]:as "])");
			};@@
		} *{
			\:output (\[String]:as "<INTERNAL EXPRESSION ERROR!!!>");
		};


		
		@[[[DainaExpression]->]->] ifProxyObject
		@[[[Integer][DainaGeneralIdentifier]->]->] ifInternalInstanceMethod
		@[[[DainaGeneralIdentifier]->]->] ifInternalInstanceObject
		@[[->]->] ifSelfReference
		@[[->]->] ifMethodSelfReference

		@[[[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->]->] ifAnonymousClassObject
	}

	
}





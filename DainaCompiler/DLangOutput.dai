

[DLangSynthesizer] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,
			OutputStream,
			DainaClass,
			Integer,
			DainaGeneralIdentifier,
			Mapping,
			Debug
		)
	[OutputStream] output
	[Integer] tab
	[Mapping<[String][DainaClass]>] mappedClasses
	[Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>] mappedClassMethods
{
	~ to *([OutputStream] output) {
		.tab = \[Integer]:zero;
		.output = output;
		.mappedClasses = \[Mapping<[String][DainaClass]>]:empty;
		.mappedClassMethods = \[Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>]:empty;
	}

	- output *([String] string) {
		\.output:writeString string;
	}

	- outputTabbed *([String] string) {
		\[Loops]:repeatNTimes .tab *{
			\.output:writeString (\[String]:as "   ");
		};
		\.output:writeString string;
	}

	- incrementTab *{
		.tab = \.tab:integerByAdding (\[Integer]:one);
	}

	- decrementTab *{
		.tab = \.tab:integerBySubtracting (\[Integer]:one);
	}

	- iterateUnoverridenInstanceMethods *([DainaClass] class, [[Integer][DainaClassMethod<[DainaExpression]>]->] get) {
		\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
		} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
			[Variable<[Integer]>] varParentNumber = \[Variable<[Integer]>]:as (\[Integer]:one);
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				[Integer] parentNumber = \varParentNumber:get;
				\varParentNumber:set (\parentNumber:adding (\[Integer]:one));
				\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
					[String] parentID = (\parentTypeIdentifier:content);
					\.mappedClasses:retriveMappedValueWithKey parentID *([DainaClass] parentClass) {
						\:iterateUnoverridenInstanceMethods parentClass *([Integer] i, [DainaClassMethod<[DainaExpression]>]c) {
							\getIfNotOverriden parentNumber c;
						};
						\parentClass:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
						} *([DainaClassIdentifier] a1, [List<[DainaType]>] a2, [List<[DainaObjectDeclaration]>] a3, [List<[DainaClassMethod<[DainaExpression]>]>] parentClassMethods, [List<[DainaCompilerInjection]>] a5) {
							\parentClassMethods:iterate *([DainaClassMethod<[DainaExpression]>] parentClassMethod) {
								\getIfNotOverriden parentNumber parentClassMethod;
							};
						};
					}; 	
				};
			};

		} !{
				[[Integer][DainaClassMethod<[DainaExpression]>]->] getIfNotOverriden = *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] parentMethod) {
					[DainaGeneralIdentifier] parentMethodIdentifier = \parentMethod:identifier;
					\.mappedClassMethods:retriveMappedValueWithKey (\className:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] ownClassMethods) {
						[Maybe<[DainaClassMethod<[DainaExpression]>]>] ifOverriden = \ownClassMethods:maybeRetriveMappedValueWithKey (\parentMethodIdentifier:content);
						\ifOverriden:ifNothing *{
							\get parentNumber parentMethod;
						};
					};
				};
		   };
	}	

	++ synthesizeClasses *([List<[DainaClass]>] classes) {
		\classes:iterate *([DainaClass] class) {
			\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
			} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
				\.mappedClasses:mapKeyToValue (\className:content) class;
				[Mapping<[String][DainaClassMethod<[DainaExpression]>]>] classMethodsMapping = \[Mapping<[String][DainaClassMethod<[DainaExpression]>]>]:empty;
				\classMethods:iterate *([DainaClassMethod<[DainaExpression]>] classMethod) {
					[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
					\classMethodsMapping:mapKeyToValue (\classMethodIdentifier:content) classMethod;
				};
				\.mappedClassMethods:mapKeyToValue (\className:content) classMethodsMapping;
			};	
		};
		\:output (\[String]:as "/* *** HEADER *** */\n");
		\:output (\[String]:as "interface OBJECT {}\n");
		\:output (\[String]:as "interface LAMBDA {\n   OBJECT method(OBJECT caller, OBJECT[] parameters);\n}\n\n");
		\classes:iterate :synthesizeClass;
	}

	- synthesizeClass *([DainaClass] class) {
		\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
			\:output (\[String]:as "/* *** ENTRY POINT CLASS *** */\n");
			\:output (\[String]:as "void main() { ENTRY_POINT_CLASS.entryPointMethod(null, []); }\n"); 
			\:output (\[String]:as "class ENTRY_POINT_CLASS {\n");
			\:output (\[String]:as "   static OBJECT entryPointMethod(OBJECT caller, OBJECT[] parameters) {\n"); \:incrementTab; \:incrementTab;
			\:synthesizeMethodBodyContent entryPointMethod; 
			\:decrementTab; \:decrementTab; \:output (\[String]:as "   }\n}\n\n");
		} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
			\:output (\[String]:as "/* *** CLASS: ");
			\:output (\className:content);
			\:output (\[String]:as " *** */\n");
			\:output (\[String]:as "interface CLASSTYPE_");
			\:output (\className:content);
			\:output (\[String]:as " : OBJECT, LAMBDA");
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				\:output (\[String]:as ", ");
				\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
					\:output (\[String]:as "CLASSTYPE_");
					\:output (\parentTypeIdentifier:content);
				};
			};
			\:output (\[String]:as " {\n"); \:incrementTab;
			\classMethods:iterate :synthesizeClassMethodInterface;
			\:decrementTab; \:output (\[String]:as "}\n");
			\:output (\[String]:as "class CLASSIMPL_");
			\:output (\className:content);
			\:output (\[String]:as " : CLASSTYPE_");
			\:output (\className:content);
			\:output (\[String]:as " {\n"); \:incrementTab;
			\:outputTabbed (\[String]:as "override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n");
			[Variable<[Integer]>] parentNumber = \[Variable<[Integer]>]:as (\[Integer]:one);
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				[Integer] curr = \parentNumber:get;
				\:synthesizeParentObjectDeclaration curr parentType;
				\parentNumber:set (\curr:adding (\[Integer]:one));
			};
			\instanceObjects:iterate :synthesizeInstanceObjectDeclaration;
			\:iterateUnoverridenInstanceMethods class (:synthesizeParentUnoverridenMethod);
			\classMethods:iterate :synthesizeClassMethodImplementation;
			\:decrementTab; \:output (\[String]:as "}\n\n");
		};
	}

	- synthesizeInstanceObjectDeclaration *([DainaObjectDeclaration] instanceObject) {
		\:outputTabbed (\[String]:as "private OBJECT IOBJECT_");
		[DainaGeneralIdentifier] instanceObjectIdentifier = \instanceObject:identifier;
		\:output (\instanceObjectIdentifier:content);
		\:output (\[String]:as " = null;\n");
	}

	- synthesizeParentObjectDeclaration *([Integer] parentNumber, [DainaType] parentType) {
		\:outputTabbed (\[String]:as "private ");
		\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
			\:output (\[String]:as "CLASSTYPE_");
			\:output (\parentTypeIdentifier:content);
		};
		\:output (\[String]:as " ");
		\:output (\[String]:as "PARENT_");
		\:output (\[String]:stringRepresentationOfInteger parentNumber);
		\:output (\[String]:as " = null;\n");
	}

	- synthesizeParentUnoverridenMethod *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] unoverridenMethod) {
		\unoverridenMethod:isInstanceTypeOrConstructor *{
			[DainaGeneralIdentifier] unoverridenMethodIdentifier = \unoverridenMethod:identifier;
			\:outputTabbed (\[String]:as "override OBJECT IMETHOD_");
			\:output (\unoverridenMethodIdentifier:content);
			\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters) { return PARENT_");
			\:output (\[String]:stringRepresentationOfInteger parentNumber);
			\:output (\[String]:as ".IMETHOD_");
			\:output (\unoverridenMethodIdentifier:content);
			\:output (\[String]:as "(caller, parameters); }\n");
		} *{} *{};
	}


	- synthesizeClassMethodInterface *([DainaClassMethod<[DainaExpression]>] classMethod) {
		\classMethod:isInstanceTypeOrConstructor *{
			[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
			\classMethod:isInstanceTypeOrConstructor *{
				\:outputTabbed (\[String]:as "OBJECT IMETHOD_");
			} *{
				\:outputTabbed (\[String]:as "OBJECT TMETHOD_");
			} *{
				\:outputTabbed (\[String]:as "OBJECT CMETHOD_");
			};
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters);\n");
		} *{} *{};
	}

	- synthesizeClassMethodImplementation *([DainaClassMethod<[DainaExpression]>] classMethod) {
		[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
		\[O]:ifElse (\classMethod:isUnimplementedMethod) *{
			\:outputTabbed (\[String]:as "private LAMBDA ASSIGNIMETHOD_");
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as " = null;\n");
		} *{};
		\classMethod:isInstanceTypeOrConstructor *{
			\:outputTabbed (\[String]:as "override OBJECT IMETHOD_");
		} *{
			\:outputTabbed (\[String]:as "static OBJECT TMETHOD_");
		} *{
			\:outputTabbed (\[String]:as "static OBJECT CMETHOD_");
		};
		\:output (\classMethodIdentifier:content);
		\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters)");
		\:output (\[String]:as " {\n"); \:incrementTab;
		\[O]:ifElse (\classMethod:isUnimplementedMethod) *{
			\:outputTabbed (\[String]:as "return ASSIGNIMETHOD_");
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as ".method(caller, parameters);\n");
		} *{
			\:synthesizeMethodBodyContent (\classMethod:methodExpression);
		};
		\:decrementTab; \:outputTabbed (\[String]:as "}\n");
	}


	- pushScope *([List<[DainaObjectDeclaration]>] parameters) {

	}

	- popScope *{
		
	}

	- pushPrologueScope *{

	}

	- pushPrelogueScopeAfterPrologue *{

	}

	- popPrelogueAndPrologueScope *{

	}

	- addLocalObjectToScope *([DainaObjectDeclaration] localObject) {

	}


	- synthesizeMethodBodyContent *([DainaExpression] methodExpression) {
		\[O]:selectOrDefault *([->] select) {
			\methodExpression:ifMethodExpression *([List<[DainaObjectDeclaration]>] inputs, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
				\select;
				\:pushScope inputs; 
				\:synthesizeStatement body (\[Boolean]:true);
				\output:ifNothing *{
					\:outputTabbed (\[String]:as "return null;\n");
				};
				\output:ifIs *([DainaExpression] expression) {
					\:outputTabbed (\[String]:as "return ");
					\:synthesizeInPlaceExpression methodExpression;
					\:output (\[String]:as ";\n");
				};
				\:popScope;
			};
		} *{
			\:outputTabbed (\[String]:as "return ");
			\:synthesizeInPlaceExpression methodExpression;
			\:output (\[String]:as ".method(caller, parameters);\n");
		};
	}

	- synthesizeStatement *([DainaExpression] statement, [Boolean] baseStatement) {
		\[O]:selectOrDefault *([->] select) {
			\statement:ifStatementGroup *([List<[DainaExpression]>] statements) {
				\select;
				\[O]:ifElse baseStatement *{} *{
					\:pushScope (\[List<[DainaObjectDeclaration]>]:empty); 
					\:outputTabbed (\[String]:as "{\n");
					\:incrementTab;
				};
				\statements:iterate *([DainaExpression] subStatement) {
					\:synthesizeStatement subStatement (\[Boolean]:false);
				};
				\[O]:ifElse baseStatement *{} *{
					\:decrementTab;
					\:outputTabbed (\[String]:as "}\n");
					\:popScope;
				};
			};
			\statement:ifWithPrologueStatement *([DainaExpression] prelogueStatement, [DainaExpression] prologueStatement) {
				\select;
				\:pushPrologueScope;
				\:synthesizeStatement prologueStatement (\[Boolean]:true);
				\:pushPrelogueScopeAfterPrologue;
				\:synthesizeStatement prelogueStatement (baseStatement);
				\:popPrelogueAndPrologueScope;
			};
			@[[[DainaObjectDeclaration][DainaExpression]->]->] \statement:ifLocalObjectAssignment
			@[[[DainaExpression][List<[DainaExpression]>]->]->] \statement:ifInvocation
			@[[[Integer][Boolean][List<[DainaExpression]>]->]->] \statement:ifConstructorInvocation
			@[[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceMethodAssignment
			@[[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceObjectAssignment
		} *{
			\:outputTabbed (\[String]:as "INTERNAL STATEMENT ERROR!!!\n");
		};
	}

	- synthesizeInPlaceExpression *([DainaExpression] methodExpression) {
		\:output (\[String]:as "<expression>");
		@[[[DainaExpression][DainaExpression]->]->] ifWithPrologueStatement
		@[[[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->]->] ifMethodExpression
		@[[[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->]->] ifAnonymousClassObject
		@[[[DainaExpression][DainaGeneralIdentifier]->]->] ifInstanceMethod
		@[[[DainaType][DainaGeneralIdentifier]->]->] ifTypeMethod
		@[[[DainaExpression][List<[DainaExpression]>]->]->] ifInvocation
		@[[[DainaExpression]->]->] ifProxyObject
		@[[[DainaGeneralIdentifier]->]->] ifLocalObject
		@[[[Integer][DainaGeneralIdentifier]->]->] ifInternalInstanceMethod
		@[[[DainaGeneralIdentifier]->]->] ifInternalInstanceObject
		@[[->]->] ifSelfReference
		@[[->]->] ifMethodSelfReference
	}

	
}





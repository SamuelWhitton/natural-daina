

[DLangSynthesizer] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,
			OutputStream,
			DainaClass,
			Integer,
			DainaGeneralIdentifier
		)
	[OutputStream] output
	[Integer] tab
{
	~ to *([OutputStream] output) {
		.tab = \[Integer]:zero;
		.output = output;
	}

	- output *([String] string) {
		\.output:writeString string;
	}

	- outputTabbed *([String] string) {
		\[Loops]:repeatNTimes .tab *{
			\.output:writeString (\[String]:as "   ");
		};
		\.output:writeString string;
	}

	- incrementTab *{
		.tab = \.tab:integerByAdding (\[Integer]:one);
	}

	- decrementTab *{
		.tab = \.tab:integerBySubtracting (\[Integer]:one);
	}

	++ synthesizeClasses *([List<[DainaClass]>] classes) {
		\:output (\[String]:as "/* *** HEADER *** */\n");
		\:output (\[String]:as "interface OBJECT {}\n");
		\:output (\[String]:as "interface LAMBDA {\n   OBJECT method(OBJECT caller, OBJECT[] parameters);\n}\n\n");
		\classes:iterate :synthesizeClass;
	}

	- synthesizeClass *([DainaClass] class) {
		\class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
			\:output (\[String]:as "/* *** ENTRY POINT CLASS *** */\n");
			\:output (\[String]:as "void main() { ENTRY_POINT_CLASS.entryPointMethod(null, []); }\n"); 
			\:output (\[String]:as "class ENTRY_POINT_CLASS {\n");
			\:output (\[String]:as "   static OBJECT entryPointMethod(OBJECT caller, OBJECT[] parameters) {\n"); \:incrementTab; \:incrementTab;
			\:synthesizeMethodBodyContent entryPointMethod; 
			\:decrementTab; \:decrementTab; \:output (\[String]:as "   }\n}\n\n");
		} *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
			\:output (\[String]:as "/* *** CLASS: ");
			\:output (\className:content);
			\:output (\[String]:as " *** */\n");
			\:output (\[String]:as "interface CLASSTYPE_");
			\:output (\className:content);
			\:output (\[String]:as " : OBJECT, LAMBDA");
			\inheritedParentTypes:iterate *([DainaType] parentType) {
				\:output (\[String]:as ", ");
				\parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
					\:output (\[String]:as "CLASSTYPE_");
					\:output (\parentTypeIdentifier:content);
				};
			};
			\:output (\[String]:as " {\n"); \:incrementTab;
			\classMethods:iterate :synthesizeClassMethodInterface;
			\:decrementTab; \:output (\[String]:as "}\n");
			\:output (\[String]:as "class CLASSIMP_");
			\:output (\className:content);
			\:output (\[String]:as " : CLASSTYPE_");
			\:output (\className:content);
			\:output (\[String]:as " {\n"); \:incrementTab;
			\:outputTabbed (\[String]:as "override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n");
			\instanceObjects:iterate :synthesizeInstanceObjectDeclaration;
			@TODO parent objects
			@TODO parent methods

			@private OBJECT p = null;

			\classMethods:iterate :synthesizeClassMethodImplementation;
			\:decrementTab; \:output (\[String]:as "}\n\n");
		};
	}


	- synthesizeInstanceObjectDeclaration *([DainaObjectDeclaration] instanceObject) {
		\:outputTabbed (\[String]:as "private OBJECT IOBJECT_");
		[DainaGeneralIdentifier] instanceObjectIdentifier = \instanceObject:identifier;
		\:output (\instanceObjectIdentifier:content);
		\:output (\[String]:as " = null;\n");
	}


	- synthesizeClassMethodInterface *([DainaClassMethod<[DainaExpression]>] classMethod) {
		\classMethod:isInstanceTypeOrConstructor *{
			[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
			\classMethod:isInstanceTypeOrConstructor *{
				\:outputTabbed (\[String]:as "OBJECT IMETHOD_");
			} *{
				\:outputTabbed (\[String]:as "OBJECT TMETHOD_");
			} *{
				\:outputTabbed (\[String]:as "OBJECT CMETHOD_");
			};
			\:output (\classMethodIdentifier:content);
			\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters);\n");
		} *{} *{};
		
	}

	- synthesizeClassMethodImplementation *([DainaClassMethod<[DainaExpression]>] classMethod) {
		@TODO @isUnimplementedMethod and object
		
		[DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
		\classMethod:isInstanceTypeOrConstructor *{
			\:outputTabbed (\[String]:as "override OBJECT IMETHOD_");
		} *{
			\:outputTabbed (\[String]:as "static OBJECT TMETHOD_");
		} *{
			\:outputTabbed (\[String]:as "static OBJECT CMETHOD_");
		};
		\:output (\classMethodIdentifier:content);
		\:output (\[String]:as "(OBJECT caller, OBJECT[] parameters)");
		\:output (\[String]:as " {\n"); \:incrementTab;
		\:synthesizeMethodBodyContent (\classMethod:methodExpression);
		\:decrementTab; \:outputTabbed (\[String]:as "}\n");
	}


	- synthesizeMethodBodyContent *([DainaExpression] methodExpression) {
		@TODO
		\:outputTabbed (\[String]:as "return caller;\n");
	}

	
}




@@

void main()
{


    B b = new B();
    assert(b.foo() == 2);

    I i = new C();    // ok since B inherits A's I implementation
    assert(i.foo() == 3);


    OBJECT asdf1 = OBJECT.constr();
    OBJECT asdf = (cast(G)asdf1).PPP([OBJECT.constr()]);
    assert((cast(G)asdf).foo() == 3);
    
}


interface I
{
    int foo();
}

interface G
{
    int foo();
    OBJECT PPP(OBJECT[] asdf);
}

class OBJECT
{
    private OBJECT p = null;
    static OBJECT constr() {
        return new class OBJECT, I, G
        {
            override int foo() { return 3; }
            override OBJECT PPP(OBJECT[] asdf) { return asdf[0]; }
        };
    }
}@@



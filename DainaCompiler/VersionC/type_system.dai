
[DainaTypeEnum<E>] (List, DainaGeneralIdentifier, Natural) {
   :: default *([&E] default) -> [:[DainaTypeEnum<[&E]>]] {
      |++ root *->default
      |++ classAndGenerics *->default
      |++ method *->default
      |++ disjoint *->default
      |++ classGeneric *->default
      |++ methodGeneric *->default
      |++ dataSegment *->default
      |++ inferred *->default
      |++ inferredMethodContext *->default
      |++ inferredSelfContext *->default
      |++ inferredParentContext *->default
   }
   ++ root [->[&E]] @ []
   ++ classAndGenerics [[DainaGeneralIdentifier][List<[[DainaTypeEnum<['A]>]->['A]]>]->[&E]] @ [Array<[Bob]>] [Omp] [Transform<[A][B]>]
   ++ method [[List<[[DainaTypeEnum<['A]>]->['A]]>][[DainaTypeEnum<['A]>]->['A]]->[&E]] @ [[A]->[B]] [[G][H]->[]] [->[]]
   ++ disjoint [[List<[[DainaTypeEnum<['A]>]->['A]]>]->[&E]] @ [&BOB] [&B] [&M]
   ++ classGeneric [[DainaGeneralIdentifier]->[&E]] @ [&BOB] [&B] [&M]
   ++ methodGeneric [[Natural][DainaGeneralIdentifier]->[&E]] @ ["E] ["BOB] ['B] ['C] [''C] ['''C]
   ++ dataSegment [[DainaGeneralIdentifier]->[&E]] @ [%INTEGER] [%BLA_BLA] [%JSON]
   ++ inferred [->[&E]] @ [?]
   ++ inferredMethodContext [->[&E]] @ [?*]
   ++ inferredSelfContext [->[&E]] @ [?:]
   ++ inferredParentContext [[Natural]->[&E]] @ [?$] [?$$] [?$$$]
}

[DainaType] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Integer,
         Maybe,
         String,
         Error, M, O,
         Variable,
         DainaClassIdentifier,
         DainaGeneralIdentifier,
         DainaTypeEnum,

         Debug
      )
   [Variable<[[DainaTypeEnum<['A]>]->['A]]>] representedType
   @@[[[DainaClassIdentifier][List<[DainaType]>]->]->] ifClassNameAndGenericInstantiation

   [[[List<[DainaType]>][Maybe<[DainaType]>]->]->] ifMethodInputsAndOutput
   [[[List<[DainaType]>]->]->] ifDisjoint
   [[[DainaGeneralIdentifier]->]->] ifClassGeneric
   [[[Integer][DainaGeneralIdentifier]->]->] ifMethodGenericLevelAndIdentifier
   [[[DainaGeneralIdentifier]->]->] ifDataSegment
   [[->]->] ifInferredMethod
   [[->]->] ifInferredSelf
   [[->]->] ifInferred
   [[[Integer]->]->] ifInferredParent@@
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:squareBracketOpen)

   ~ root *{
      \:~as \[Variable<[?]>]:as *([DainaTypeEnum<["A]>] e) -> \e:root;
      @@.ifClassNameAndGenericInstantiation = *([]a){};

      .ifMethodInputsAndOutput = *([]a){};
      .ifDisjoint = *([]a){};
      .ifClassGeneric = *([]a){};
      .ifMethodGenericLevelAndIdentifier = *([]a){};
      .ifDataSegment = *([]a){};
      .ifInferredMethod = *([]a){};
      .ifInferredSelf = *([]a){};
      .ifInferredParent = *([]a){};
      .ifInferred = *([->]a){\a};@@

      @@[[DainaTypeEnum<['A]>]->['A]] rootType = *([DainaTypeEnum<["A]>] e) -> \e:root;
      \rootType [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ disjoint *{}
      };@@
   }

   ~ as *([[DainaTypeEnum<['A]>]->['A]] enum) {
      .representedType = enum;
   } 

   @++ set *([[DainaTypeEnum<['A]>]->['A]] representedType) \.representedType:set representedType
   @++ get *-> \.representedType:get

   ++ set .representedType:set
   ++ get .representedType:get

   ++ ifClassNameAndGenericInstantiation *([[DainaClassIdentifier][List<[[DainaTypeEnum<['A]>]->['A]]>]->] get) {
      \(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ classAndGenerics get
      };

      @@\(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[?:]:default _;
         |++ classAndGenerics get
      };@@
   }

   ++ ifMethodInputsAndOutput *([[List<[[DainaTypeEnum<['A]>]->['A]]>][[DainaTypeEnum<['A]>]->['A]]->] get) {
      @\.ifMethodInputsAndOutput get;
      \(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ method get
      };
   }

   ++ setAsMethodWithOutputType *([[DainaTypeEnum<['A]>]->['A]] outputType) {
      \:set *([DainaTypeEnum<["A]>] e) -> \e:method (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty) outputType;
      @.ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->]get){\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:as outputType)};
   }

   ++ setAsClassName *([DainaClassIdentifier] className) {
      \:set *([DainaTypeEnum<["A]>] e) -> \e:classAndGenerics className (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty);
      @.ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->]get){\get className (\[List<[DainaType]>]:empty)};
   }

   ++ parse *([Parser] parser) {
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
            [DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
            \className:parse parser;
            [List<[?]>] genericInstantiations = \[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty;
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
               \parser:gotoNextToken;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
                     [DainaType] genericInstantiation = \[DainaType]:root;
                     \genericInstantiation:parse parser;
                     \genericInstantiations:append \genericInstantiation:get;
                     \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{} stop;
                  } *{
                     \parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
                     \stop;
                  };
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
               };
            } *{};
            \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:classAndGenerics className genericInstantiations;
         } *{
            \[Loops]:until *([->] stop) {
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
                  [DainaType] subtype = \[DainaType]:root;
                  \subtype:parse parser;
                  \(\.representedType:get) [:[DainaTypeEnum<[]>]] {
                     \$~> \[DainaTypeEnum<[]>]:default _;
                     |++ method *([List<[[DainaTypeEnum<['A]>]->['A]]>] _a, [[DainaTypeEnum<['A]>]->['A]] _b) {
                        \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:method (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty) \subtype:get;
                     }
                  };
               } *{
                  \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow) *{
                     \parser:gotoNextToken;
                     \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:method (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty) \[DainaType]:root;
                  } *{
                     \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) stop *{
                        \parser:gotoNextToken;
                     };
                  };
               };
            };
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
         };
      } *{
         \parser:addError (\[Error]:expectingType (\parser:position));
      };
   }
}



      @[] _ = << dlang ##import std.stdio;writeln(IOBJECT_representedType);writeln(self);##;
@\[Debug]:log (\[String]:as ##D\n##);
@@\[Debug]:log instanceObjectIdentifierString;
                  \[Debug]:log (\[String]:as ##:##);
                  \[Debug]:log \.synthesizedExpressionType:description;
                  \[Debug]:log (\[String]:as ##\n##);@@


[DainaTypeEnum<E>] (List, DainaGeneralIdentifier, Natural) {
   :: default *([&E] default) -> [:[DainaTypeEnum<[&E]>]] {
      |++ root *->default
      |++ classAndGenerics *->default
      |++ method *->default
      |++ disjoint *->default
      |++ classGeneric *->default
      |++ methodGeneric *->default
      |++ dataSegment *->default
      |++ inferred *->default
      |++ inferredMethodContext *->default
      |++ inferredSelfContext *->default
      |++ inferredParentContext *->default
   }
   ++ root [->[&E]] @ []
   ++ classAndGenerics [[DainaClassIdentifier][List<[[DainaTypeEnum<['A]>]->['A]]>]->[&E]] @ [Array<[Bob]>] [Omp] [Transform<[A][B]>]
   ++ method [[List<[[DainaTypeEnum<['A]>]->['A]]>][[DainaTypeEnum<['A]>]->['A]]->[&E]] @ [[A]->[B]] [[G][H]->[]] [->[]]
   ++ disjoint [[List<[[DainaTypeEnum<['A]>]->['A]]>]->[&E]] @ [&BOB] [&B] [&M]
   ++ classGeneric [[DainaGeneralIdentifier]->[&E]] @ [&BOB] [&B] [&M]
   ++ methodGeneric [[Natural][DainaGeneralIdentifier]->[&E]] @ ["E] ["BOB] ['B] ['C] [''C] ['''C]
   ++ dataSegment [[DainaGeneralIdentifier]->[&E]] @ [%INTEGER] [%BLA_BLA] [%JSON]
   ++ inferred [->[&E]] @ [?]
   ++ inferredMethodContext [->[&E]] @ [?*]
   ++ inferredSelfContext [->[&E]] @ [?:]
   ++ inferredParentContext [[Natural]->[&E]] @ [?$] [?$$] [?$$$]
}

[DainaType] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Integer,
         Maybe,
         String,
         Error, M, O,
         Variable,
         DainaClassIdentifier,
         DainaGeneralIdentifier,
         DainaTypeEnum,

         Debug
      )
   [Variable<[[DainaTypeEnum<['A]>]->['A]]>] representedType
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:squareBracketOpen)

   ~ root *{
      \:~as *([DainaTypeEnum<["A]>] e) -> \e:root;
   }

   ~ as *([[DainaTypeEnum<['A]>]->['A]] enum) {
      .representedType = \[Variable<[?]>]:as enum;
   } 

   ++ description *-> [String] {
      [[List<[[DainaTypeEnum<['A]>]->['A]]>]->[String]] descriptionOfTypeList = *([List<[[DainaTypeEnum<['A]>]->['A]]>] typeList) -> [String] {
            [Variable<[String]>] description = \[Variable<[String]>]:as \[String]:as ####;
            \typeList:iterate *([[DainaTypeEnum<['A]>]->['A]] typeEnum) {
               [String] current = \description:get;
               [DainaType] type = \[DainaType]:as typeEnum;
               \description:set \current:appending \type:description;
            }
         } -> \description:get;
      [String] description = \(\.representedType:get) [:[DainaTypeEnum<[&E]>]] {
         |++ root *->\[String]:as ##[]##
         |++ classAndGenerics *([DainaClassIdentifier] id, [List<[[DainaTypeEnum<['A]>]->['A]]>] generics) -> [String] {
            [String] className = \id:content;
            [String] desc1 = \[String]:as ##[##;
            [String] desc2 = \desc1:appending className;
            [String] desc3 = \desc2:appending \[String]:as ##<##;
            [String] desc4 = \desc3:appending \descriptionOfTypeList generics;
            [String] desc5 = \desc4:appending \[String]:as ##>]##;
         } -> desc5
         |++ method *([List<[[DainaTypeEnum<['A]>]->['A]]>] inputs, [[DainaTypeEnum<['A]>]->['A]] outputEnum) -> [String] {
            [String] desc1 = \[String]:as ##[##;
            [String] desc2 = \desc1:appending \descriptionOfTypeList inputs;
            [String] desc3 = \desc2:appending \[String]:as ##->##;
            [DainaType] output = \[DainaType]:as outputEnum;
            [String] desc4 = \desc3:appending \output:description;
         } -> desc4
         |++ disjoint *([List<[[DainaTypeEnum<['A]>]->['A]]>] subtypes) -> [String] {
            [String] desc1 = \[String]:as ##[//##;
            [String] desc2 = \desc1:appending \descriptionOfTypeList subtypes;
            [String] desc3 = \desc2:appending \[String]:as ##]##;
         } -> desc3
         |++ classGeneric *->\[String]:as ##[&GEN*]##
         |++ methodGeneric *->\[String]:as ##['*GEN*]##
         |++ dataSegment *->\[String]:as ##[%SEG*]##
         |++ inferred *->\[String]:as ##[?]##
         |++ inferredMethodContext *->\[String]:as ##[?*]##
         |++ inferredSelfContext *->\[String]:as ##[?:]##
         |++ inferredParentContext *->\[String]:as ##[?$n]##
      }
   } -> description

   ++ set .representedType:set
   ++ get .representedType:get

   ++ ifClassNameAndGenericInstantiation *([[DainaClassIdentifier][List<[[DainaTypeEnum<['A]>]->['A]]>]->] get) {
      \(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ classAndGenerics get
      };
   }

   ++ ifMethodInputsAndOutput *([[List<[[DainaTypeEnum<['A]>]->['A]]>][[DainaTypeEnum<['A]>]->['A]]->] get) {
      \(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ method get
      };
   }

   ++ setAsMethodWithOutputType *([DainaType] outputType) {
      \:set *([DainaTypeEnum<["A]>] e) -> \e:method (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty) \outputType:get;
   }

   ++ setAsClassName *([DainaClassIdentifier] className) {
      \:set *([DainaTypeEnum<["A]>] e) -> \e:classAndGenerics className (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty);
   }

   ++ parse *([Parser] parser) {
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen)@@ifOrElse@@ *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
            [DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
            \className:parse parser;
            [List<[?]>] genericInstantiations = \[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty;
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen)@@ifOrElse@@ *{
               \parser:gotoNextToken;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
                     [DainaType] genericInstantiation = \[DainaType]:root;
                     \genericInstantiation:parse parser;
                     \genericInstantiations:append \genericInstantiation:get;
                     \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{} stop;
                  } *{
                     \parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
                     \stop;
                  };
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose)@@ifOrElse@@ *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
               };
            } *{};
            \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:classAndGenerics className genericInstantiations;
         } *\[O]:ifElse (\[Boolean]:or (\[DainaType]:isFirstToken (\parser:token)) (\[Token]:equals (\parser:token) \[Token]:arrow))@@ifOrElse@@ *{
            [List<[?]>] subtypeList = \[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty;
            \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaType] firstSubtype = \[DainaType]:root;
               \firstSubtype:parse parser;
               \subtypeList:append \firstSubtype:get;
            } *{};
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:forwardSlash) *{
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:forwardSlash)@@ifOrElse@@ *{
                     \parser:gotoNextToken;
                     [DainaType] subtype = \[DainaType]:root;
                     \subtype:parse parser;
                     \subtypeList:append \subtype:get;
                  } stop;
               };
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:disjoint subtypeList;
            } *{
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
                     [DainaType] subtype = \[DainaType]:root;
                     \subtype:parse parser;
                     \subtypeList:append \subtype:get;
                  } *{
                     \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow)@@ifOrElse@@ *{
                        \parser:gotoNextToken;
                        [DainaType] returnType = \[DainaType]:root;
                        \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
                           \returnType:parse parser;
                        } *{};
                        \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:method subtypeList \returnType:get;
                     } *{
                        \parser:addError (\[Error]:expectingTypeOrArrowForMethodType (\parser:position));
                     };
                     \stop;
                  };
               };
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:ampersand)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:classGeneric identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForClassGenericType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:percentSign)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:dataSegment identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForDataSegmentType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:doubleApostrophe)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:methodGeneric (\[Natural]:as ##0##) identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForMethodGenericType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:singleApostrophe)@@ifOrElse@@ *{
            [Natural] count = \parser:gotoNextSameTokens \[Token]:singleApostrophe;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:methodGeneric count identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForMethodGenericType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:questionMark)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:asterisk)@@ifOrElse@@ *{
               \parser:gotoNextToken;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferredMethodContext;
            } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:colon)@@ifOrElse@@ *{
               \parser:gotoNextToken;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferredSelfContext;
            } *\[O]:ifElse (\[Token]:isParentIdentifier (\parser:token))@@ifOrElse@@ *{
               [Token] parentIdentifierToken = (\parser:token);
               [Natural] parentIdentifierNumber = \parentIdentifierToken:secondId;
               \parser:gotoNextToken;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferredParentContext parentIdentifierNumber;
            } *{
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferred;
            };
         } *{};

         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose)@@ifOrElse@@ *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
         };
      } *{
         \parser:addError (\[Error]:expectingType (\parser:position));
      };
   }
}

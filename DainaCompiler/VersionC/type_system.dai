

      @[] _ = << dlang ##import std.stdio;writeln(IOBJECT_representedType);writeln(self);##;
@\[Debug]:log (\[String]:as ##D\n##);
@@\[Debug]:log instanceObjectIdentifierString;
                  \[Debug]:log (\[String]:as ##:##);
                  \[Debug]:log \.synthesizedExpressionType:description;
                  \[Debug]:log (\[String]:as ##\n##);@@


[DainaTypeEnum<E>] (List, DainaGeneralIdentifier, Natural) {
   :: default *([&E] default) -> [:[DainaTypeEnum<[&E]>]] {
      |++ root *->default
      |++ classAndGenerics *->default
      |++ method *->default
      |++ disjoint *->default
      |++ classGeneric *->default
      |++ methodGeneric *->default
      |++ dataSegment *->default
      |++ inferred *->default
      |++ inferredMethodContext *->default
      |++ inferredSelfContext *->default
      |++ inferredParentContext *->default
   }
   ++ root [->[&E]] @ []
   ++ classAndGenerics [[DainaClassIdentifier][List<[[DainaTypeEnum<['A]>]->['A]]>]->[&E]] @ [Array<[Bob]>] [Omp] [Transform<[A][B]>]
   ++ method [[List<[[DainaTypeEnum<['A]>]->['A]]>][[DainaTypeEnum<['A]>]->['A]]->[&E]] @ [[A]->[B]] [[G][H]->[]] [->[]]
   ++ disjoint [[List<[[DainaTypeEnum<['A]>]->['A]]>]->[&E]] @ [&BOB] [&B] [&M]
   ++ classGeneric [[DainaGeneralIdentifier]->[&E]] @ [&BOB] [&B] [&M]
   ++ methodGeneric [[Natural][DainaGeneralIdentifier]->[&E]] @ ["E] ["BOB] ['B] ['C] [''C] ['''C]
   ++ dataSegment [[DainaGeneralIdentifier]->[&E]] @ [%INTEGER] [%BLA_BLA] [%JSON]
   ++ inferred [->[&E]] @ [?]
   ++ inferredMethodContext [->[&E]] @ [?*]
   ++ inferredSelfContext [->[&E]] @ [?:]
   ++ inferredParentContext [[Natural]->[&E]] @ [?$] [?$$] [?$$$]
}


[DainaType] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Integer,
         Maybe,
         String,
         Error, M, O,
         Variable,
         DainaClassIdentifier,
         DainaGeneralIdentifier,
         DainaTypeEnum,

         Debug
      )
   [Variable<[[DainaTypeEnum<['A]>]->['A]]>] representedType
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:squareBracketOpen)

   ~ root *{
      \:~as *([DainaTypeEnum<["A]>] e) -> \e:root;
   }

   ~ as *([[DainaTypeEnum<['A]>]->['A]] enum) {
      .representedType = \[Variable<[?]>]:as enum;
   } 

   ++ description *-> [String] {
      [[List<[[DainaTypeEnum<['A]>]->['A]]>]->[String]] descriptionOfTypeList = *([List<[[DainaTypeEnum<['A]>]->['A]]>] typeList) -> [String] {
            [Variable<[String]>] description = \[Variable<[String]>]:as \[String]:as ####;
            \typeList:iterate *([[DainaTypeEnum<['A]>]->['A]] typeEnum) {
               [String] current = \description:get;
               [DainaType] type = \[DainaType]:as typeEnum;
               \description:set \current:appending \type:description;
            }
         } -> \description:get;
      [String] description = \(\.representedType:get) [:[DainaTypeEnum<[&E]>]] {
         |++ root *->\[String]:as ##[]##
         |++ classAndGenerics *([DainaClassIdentifier] id, [List<[[DainaTypeEnum<['A]>]->['A]]>] generics) -> [String] {
            [String] className = \id:content;
            [String] desc1 = \[String]:as ##[##;
            [String] desc2 = \desc1:appending className;
            [String] desc3 = \desc2:appending \[String]:as ##<##;
            [String] desc4 = \desc3:appending \descriptionOfTypeList generics;
            [String] desc5 = \desc4:appending \[String]:as ##>]##;
         } -> desc5
         |++ method *([List<[[DainaTypeEnum<['A]>]->['A]]>] inputs, [[DainaTypeEnum<['A]>]->['A]] outputEnum) -> [String] {
            [String] desc1 = \[String]:as ##[##;
            [String] desc2 = \desc1:appending \descriptionOfTypeList inputs;
            [String] desc3 = \desc2:appending \[String]:as ##->##;
            [DainaType] output = \[DainaType]:as outputEnum;
            [String] desc4 = \desc3:appending \output:description;
         } -> desc4
         |++ disjoint *([List<[[DainaTypeEnum<['A]>]->['A]]>] subtypes) -> [String] {
            [String] desc1 = \[String]:as ##[//##;
            [String] desc2 = \desc1:appending \descriptionOfTypeList subtypes;
            [String] desc3 = \desc2:appending \[String]:as ##]##;
         } -> desc3
         |++ classGeneric *->\[String]:as ##[&GEN*]##
         |++ methodGeneric *->\[String]:as ##['*GEN*]##
         |++ dataSegment *->\[String]:as ##[%SEG*]##
         |++ inferred *->\[String]:as ##[?]##
         |++ inferredMethodContext *->\[String]:as ##[?*]##
         |++ inferredSelfContext *->\[String]:as ##[?:]##
         |++ inferredParentContext *->\[String]:as ##[?$n]##
      }
   } -> description

   ++ set .representedType:set
   ++ get .representedType:get

   ++ ifClassNameAndGenericInstantiation *([[DainaClassIdentifier][List<[[DainaTypeEnum<['A]>]->['A]]>]->] get) {
      \(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ classAndGenerics get
      };
   }

   ++ ifMethodInputsAndOutput *([[List<[[DainaTypeEnum<['A]>]->['A]]>][[DainaTypeEnum<['A]>]->['A]]->] get) {
      \(\:get) [:[DainaTypeEnum<[]>]] {
         \$~> \[DainaTypeEnum<[]>]:default _;
         |++ method get
      };
   }

   ++ setAsMethodWithOutputType *([DainaType] outputType) {
      \:set *([DainaTypeEnum<["A]>] e) -> \e:method (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty) \outputType:get;
   }

   ++ setAsClassName *([DainaClassIdentifier] className) {
      \:set *([DainaTypeEnum<["A]>] e) -> \e:classAndGenerics className (\[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty);
   }

   ++ parse *([Parser] parser) {
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen)@@ifOrElse@@ *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
            [DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
            \className:parse parser;
            [List<[?]>] genericInstantiations = \[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty;
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen)@@ifOrElse@@ *{
               \parser:gotoNextToken;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
                     [DainaType] genericInstantiation = \[DainaType]:root;
                     \genericInstantiation:parse parser;
                     \genericInstantiations:append \genericInstantiation:get;
                     \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{} stop;
                  } *{
                     \parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
                     \stop;
                  };
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose)@@ifOrElse@@ *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
               };
            } *{};
            \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:classAndGenerics className genericInstantiations;
         } *\[O]:ifElse (\[Boolean]:or (\[DainaType]:isFirstToken (\parser:token)) (\[Token]:equals (\parser:token) \[Token]:arrow))@@ifOrElse@@ *{
            [List<[?]>] subtypeList = \[List<[[DainaTypeEnum<['A]>]->['A]]>]:empty;
            \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaType] firstSubtype = \[DainaType]:root;
               \firstSubtype:parse parser;
               \subtypeList:append \firstSubtype:get;
            } *{};
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:forwardSlash) *{
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:forwardSlash)@@ifOrElse@@ *{
                     \parser:gotoNextToken;
                     [DainaType] subtype = \[DainaType]:root;
                     \subtype:parse parser;
                     \subtypeList:append \subtype:get;
                  } stop;
               };
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:disjoint subtypeList;
            } *{
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
                     [DainaType] subtype = \[DainaType]:root;
                     \subtype:parse parser;
                     \subtypeList:append \subtype:get;
                  } *{
                     \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow)@@ifOrElse@@ *{
                        \parser:gotoNextToken;
                        [DainaType] returnType = \[DainaType]:root;
                        \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token))@@ifOrElse@@ *{
                           \returnType:parse parser;
                        } *{};
                        \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:method subtypeList \returnType:get;
                     } *{
                        \parser:addError (\[Error]:expectingTypeOrArrowForMethodType (\parser:position));
                     };
                     \stop;
                  };
               };
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:ampersand)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:classGeneric identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForClassGenericType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:percentSign)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:dataSegment identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForDataSegmentType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:doubleApostrophe)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:methodGeneric (\[Natural]:as ##0##) identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForMethodGenericType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:singleApostrophe)@@ifOrElse@@ *{
            [Natural] count = \parser:gotoNextSameTokens \[Token]:singleApostrophe;
            \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token))@@ifOrElse@@ *{
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \identifier:parse parser;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:methodGeneric count identifier;
            } *{
               \parser:addError (\[Error]:expectingIdentifierForMethodGenericType (\parser:position));
            };
         } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:questionMark)@@ifOrElse@@ *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:asterisk)@@ifOrElse@@ *{
               \parser:gotoNextToken;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferredMethodContext;
            } *\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:colon)@@ifOrElse@@ *{
               \parser:gotoNextToken;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferredSelfContext;
            } *\[O]:ifElse (\[Token]:isParentIdentifier (\parser:token))@@ifOrElse@@ *{
               [Token] parentIdentifierToken = (\parser:token);
               [Natural] parentIdentifierNumber = \parentIdentifierToken:secondId;
               \parser:gotoNextToken;
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferredParentContext parentIdentifierNumber;
            } *{
               \.representedType:set *([DainaTypeEnum<["A]>] e) -> \e:inferred;
            };
         } *{};

         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose)@@ifOrElse@@ *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
         };
      } *{
         \parser:addError (\[Error]:expectingType (\parser:position));
      };
   }
}


@[]{*{}}

@[DainaType]{}


[AnalyzerScope<ID,CLASS,OBJECT>] (
         String,
         Maybe,
         List,
         Error,
         Boolean
      ) {

   ++ hasErrors [->[Boolean]]
   ++ errors [->[List<[Error]>]]
   ++ addError [[Error]->]
   @++ findClass []
}

[DainaAnalyzerScope :[AnalyzerScope<[String][DainaClass][DainaObjectDeclaration]>]] (AnalyzerScope) {}

[DainaAnalyzer :[DainaAnalyzerScope]] (
         DainaAnalyzerScope,
         String,
         Maybe,
         List,
         Error,
         Character,
         Byte,
         Token,
         SourcePosition,
         Boolean,
         Variable,
         Loops,
         Data,
         Integer,
         DainaClass,
         Index,
         Analyzer
      ) 
   [List<[Error]>] errors
   [Variable<[Maybe<[DainaClass]>]>] entryPoint
   [Index<[DainaClass]>] classIndex
{
   ~ new *{
      .errors = \[List<[Error]>]:empty;
      .entryPoint = \[Variable<[?]>]:as \[Maybe<[DainaClass]>]:nothing;
      .classIndex = \[Index<[DainaClass]>]:empty;
   }

   |++ hasErrors *-> [Boolean] {} -> (\[Boolean]:not (\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)})

   |++ errors *-> [List<[Error]>] {} -> .errors

   |++ addError *([Error] error) {
      \.errors:append error;
   }
@@
   [Dependancy] {
   ++
}@@
@@
   - checkForCircularDependancies *([SourcePosition] dependancyOrigin, [DainaClass] class, [List<[SourcePosition]>] currentPathList, [Index<[DainaClass]>] currentPathIndex, [Index<[DainaClass]>] visited) {
      [Maybe<[String]>] maybeClassName = \[Maybe<[String]>]:if *([[String]->] find) {
         \class:isEntryPointOrRegularClass *{} *([DainaClassIdentifier] classId, [] _, [] __, [] ___, [] ____) {
            \find \classId:content;
         };
      };
      [String] className = \maybeClassName:isOrElse (*([?]a)->a) (*->\[String]:as ####);
      [Maybe<[DainaClass]>] inCurrentPath = \currentPathIndex:get className;
      \inCurrentPath:isOrElse *{
         \addErrorDependancyRecursion dependancyOrigin currentPathList;
      } *{
         [Maybe<[DainaClass]>] inVisited = \visited:get className;
         \inVisited:isOrElse *{} *{
            \visited:set className \[Maybe<[?]>]:as class;
            \currentPathIndex:set className \[Maybe<[?]>]:as class;
            \currentPathList:append dependancyOrigin;
            [DainaDependancyStructure] dependancyStructure = \class:dependancyStructure;
            \dependancyStructure:iterateDependancies *([DainaClassIdentifier] dependancyID) {
               [Maybe<[DainaClass]>] maybeDependancy = \.classIndex:get \dependancyID:content;
               \maybeDependancy:isOrElse *([DainaClass] dependancy) {
                  \:checkForCircularDependancies (\dependancyID:position) dependancy currentPathList currentPathIndex visited;
               } *{
                  \:addError (\[Error]:missingClass (\class:position));
               };
            };
            \currentPathIndex:set className \[Maybe<[?]>]:nothing;
            [] _ = \currentPathList:removeLast;
         };
      };
   } !{
         [[List<[DainaClass]>]->] addErrorDependancyRecursion = *([SourcePosition] dependancyOrigin, [List<[SourcePosition]>] pathList) {
            [List<[?]>] circularDependanciesPath = \[List<[?]>]:as pathList;
            \circularDependanciesPath:append dependancyOrigin;
            \:addError \[Error]:foundDependancyRecursion circularDependanciesPath;
         };
      }@@

   ++ analyze *([List<[DainaClass]>] classes) {

      [Index<[DainaClass]>] visited = \[Index<[DainaClass]>]:empty;
      \classes:iterate *([DainaClass] class) {
         \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
            [Maybe<[DainaClass]>] entryPoint = \.entryPoint:get;
            \entryPoint:isOrElse 
               *([DainaClass] original){\:addError (\[Error]:duplicateEntryPointClass (\class:position) (\original:position))} 
               *{\.entryPoint:set \[Maybe<[DainaClass]>]:as class};
         } *([DainaClassIdentifier] classId, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
            [String] className = \classId:content;
            [Maybe<[?]>] existingClass = \.classIndex:get className;
            \existingClass:isOrElse
               *([DainaClass] original){\:addError (\[Error]:duplicateClassName (\class:position) (\original:position))} 
               *{\.classIndex:set className \[Maybe<[?]>]:as class};
         };
      };
      @@\classes:iterate *([DainaClass] class) {
         \:checkForCircularDependancies (\class:position) class (\[List<[DainaClassIdentifier]>]:empty) (\[Index<[DainaClassIdentifier]>]:empty) visited;
      };@@


      \classes:iterate *([DainaClass] class) {
         \class:analyze ^;
      };



@@

      \classes:iterate *([DainaClass] class) {
         \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
            [Maybe<[DainaClass]>] entryPoint = \.entryPoint:get;
            \entryPoint:isOrElse 
               *([DainaClass] original){\:addError (\[Error]:duplicateEntryPointClass (\class:position) (\original:position))} 
               *{\.entryPoint:set \[Maybe<[DainaClass]>]:as class};
         } *([DainaClassIdentifier] classId, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
            [String] className = \classId:content;
            [Maybe<[?]>] existingClass = \.classIndex:get className;
            \existingClass:isOrElse
               *([DainaClass] original){\:addError (\[Error]:duplicateClassName (\class:position) (\original:position))} 
               *{\.classIndex:set className \[Maybe<[?]>]:as class};
         };
      };



   [List<[DainaClassIdentifier]>] dependancies
   [List<[DainaClassIdentifier]>] dependanciesWithDerivatives
   [List<[DainaClassIdentifier]>] reverseDependancies@@
      
      
   @duplicates check in parser

      @ dependancies, with derivatives, reverse dependancies, prevent looped structure

      @ananlyze each class individualy

   }
}








[Debug] (OutputStream, String, SystemInputOutput){
   :: log *([String] s){
      [[Data]->] out = [StandardIO]:stdout;
      \out \s:ascii;
   }
}




[] (StandardIO, File, String, Byte, Data, List, Integer, Natural, Sequence, Boolean, Loops, Variable, Mapping, Maybe, SourcePosition, Error) {
   *{
      \[Daina]:run \[Configuration]:init;

      @[Maybe<[String]>] y1 = \[Maybe<[String]>]:nothing;
      @[Maybe<[String]>] y2 = \[Maybe<[String]>]:as \[String]:as ##Hello Worl!##;
      
      @\[SystemIO]:log \y1:isOrElse (*([String] s)->s) (*->nothingStr);
      @\[SystemIO]:log \y2:isOrElse (*([String] s)->s) (*->nothingStr);


      @@[Sequence<[Number]>] 5Times = [:[Sequence<[Number]>]] {
         |++ length *->\[Natural]:as ##5##
         |++ atIndex *(n)->\[Maybe<[?]>]:as n
      };
      \[Loops]:iterate 5Times *{
         \[SystemIO]:stdout \(\[String]:as ##Hello World!!\n##):ascii;
         \[SystemIO]:stdout \(\[String]:asASCII \[SystemIO]:stdin):ascii;
      };@@
      @@@@@@@@
      @@[SourcePosition] asdf = \[SourcePosition]:initialPositionIn (\[String]:as ##sadf/asdf/filenametest.h##) (\[String]:as ##This is a line....##);
      [SourcePosition] asdf2 = \asdf:startOfNextLine (\[String]:as ##This is a line2....##);
      [SourcePosition] asdf3 = \asdf2:startOfNextLine (\[String]:as ##This is a line3....##);
      [SourcePosition] asdf4 = \asdf3:nextColumn;


      \[StandardIO]:stdout \(\(\[Error]:expectingSecondHashForDataSegmentAnchor asdf4):description):ascii;
      \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;

      \[Loops]:iterate ([:[Sequence<[Natural]>]] {
         |++ length *->\[Natural]:as ##10##
         |++ atIndex *([Natural] n)->\[Maybe<[?]>]:as \n:adding \[Natural]:as ##300000238974289438900234##
      }) *([Natural] index, [Natural]value){
         \[StandardIO]:stdout \(\[String]:stringFormatOf value):ascii;
         \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;
      };
      @@
      
      @\(\[File]:atPath \[String]:as ##TestFiles/dlang_compiler_bootstrap_test.dai##):readContents (\[Natural]:as ##1000##) [StandardIO]:stdout;
      @[File] outputFile = (\[File]:atPath \[String]:as ##TestFiles/testwrite.txt##);
      @\outputFile:clearContents;
@@
      [List<[Byte]>] bytes = \[List<[Byte]>]:empty;
      \bytes:append \[Byte]:0x01;
      \bytes:append \[Byte]:0x21;
      \bytes:append \[Byte]:0xFF;
      [Data] dat = \[Data]:copy bytes;
      @\[StandardIO]:stdout \(\[String]:stringFormatOf (\bytes:length)):ascii;
      \outputFile:appendContents dat;
      @\outputFile:appendContents \(\[String]:as ##1000##):ascii;
      \(\outputFile:exists):ifOrElse *{
         \[StandardIO]:stdout \(\[String]:as ##Exists\n##):ascii;
      } *{
         \[StandardIO]:stdout \(\[String]:as ##NotExists\n##):ascii;
      };

      \outputFile:close;@@

      @ link source file to group, export from group, import group to group@@@@

   } @!{[String] nothingStr = \[String]:as ##<NOTHING>##}
}





@ DAINA COMPILER -------



[DainaASTComponent] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         Maybe,

         Debug
      ) 
   [Variable<[SourcePosition]>] startPosition
{

   ~ base *{
      .startPosition = \[Variable<[SourcePosition]>]:as \[SourcePosition]:initialPositionIn (\[String]:as ##< UNKNOWN SOURCE >##) (\[String]:as ####)
   }

   ++ position .startPosition:get

   ++ parse *([Parser] parser) {
      \.startPosition:set (\parser:position);
   }

   ++ analyze *([Analyzer] analyzer) {}
}





[SourcePosition] (
         Natural,
         String,
         Variable,
         Object,
         Loops
      )
   [String] sourceName
   [Natural] line
   [Natural] column
   [String] lineContent
{
   ~ initialPositionIn *([String] sourceName, [String] lineContent) {
      \:~lineAndColumnIn (\[Natural]:as ##0##) (\[Natural]:as ##0##) sourceName lineContent;
   }

   ~ -+- lineAndColumnIn *([Natural] line, [Natural] column, [String] sourceName, [String] lineContent) {
      .sourceName = sourceName;
      .column = column;
      .line = line;
      .lineContent = lineContent;
   }

   ++ description *-> [String] {
      [String] colon = \[String]:as ##:##;
      [String] pos = \[String]:as ## pos ##;
      [String] line = \[String]:stringFormatOf (\.line:adding (\[Natural]:as ##1##));
      [String] column = \[String]:stringFormatOf (\.column:adding (\[Natural]:as ##1##));
      [String] tabulation = \[String]:as ##\n    ##;
      [Variable<[String]>] linePositionArrow = \[Variable<[String]>]:as (\[String]:as ####);
      \[Loops]:iterate ([:[Sequence<[Natural]>]] { 
         |++ length *->.column
         |++ atIndex *(i)->\[Maybe<[?]>]:as i
      }) *{
         [String] curr = \linePositionArrow:get;
         \linePositionArrow:set (\curr:appending (\[String]:as ## ##));
      };
      [String] curr = \linePositionArrow:get;
      \linePositionArrow:set (\curr:appending (\[String]:as ##^##));
   } -> (\.sourceName:appending (\colon:appending (\line:appending (\pos:appending (\column:appending \colon:appending (\tabulation:appending (\.lineContent:appending (\tabulation:appending (\linePositionArrow:get)))))))))

   ++ nextColumn *-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Natural]:as ##1##)) (.sourceName) (.lineContent)

   ++ startOfNextLine *([String] lineContent)-> [SourcePosition] {
   } -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Natural]:as ##1##)) (\[Natural]:as ##0##) (.sourceName) lineContent
}



[Error] (Object, String, SourcePosition, List, Variable)
   [String] errorString
{
   ++ description *-> [String] {
      [String] errorPrefix = \[String]:as ##ERROR; ##;
   } -> (\errorPrefix:appending .errorString)

   ~ -+- as *([String] errorString) {
      .errorString = errorString;
   }

   ~ -+- errorWithContext *([String] errorString, [List<[SourcePosition]>] context) {
      [Variable<[String]>] errorWithContext = \[Variable<[String]>]:as errorString;
      \[Loops]:iterate context *([] _, [SourcePosition] sourcePosition) {
         \errorWithContext:set (\prefix:appending \[String]:as ##\n##) !{
            [String] prefix = \errorWithContext:get;
         };
         [String] addedContext = (\prefix:appending (\sourcePosition:description)) !{
               [String] prefix = \[String]:as ## - ##;
            };
         \errorWithContext:set (\prefix:appending addedContext) !{
               [String] prefix = \errorWithContext:get;
            };

      };
      .errorString = \errorWithContext:get;
   }

   :: sourceFileNotAccessible *([String] fileName) -> [Error] {
      [String] prefix = \[String]:as ##Source file not accessible: ##;
   } -> (\[Error]:as (\prefix:appending fileName))

   :: unrecognisedToken *([String] token, [SourcePosition] position) -> [Error] {
      [String] prefix = \[String]:as ##Unrecognised token: ##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext (\prefix:appending token) context)

   :: invalidVisibilityIndicator *([SourcePosition] position) -> [Error] {
      [String] error = \[String]:as ##Invalid visibility indicator##;
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
      \context:append position;
   } -> (\[Error]:errorWithContext error context)

    :: expectingSecondHashForDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second hash for data segment anchor##) context)

   :: expectingSecondDataSegmentAnchor *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting second data segment anchor##) context)

   :: expectingClassAtTopLevel *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class at top level##) context)

   :: expectingBodyOfClass *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting body of class##) context)

   :: expectingEntryPointMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting entry point method##) context)

   :: expectingClosingBracketForClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class body##) context)

   :: expectingClassName *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class name##) context)

   :: expectingParentType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type##) context)

   :: expectingClosingSquareBracketAfterClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after class header##) context)

   :: expectingGenericIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting generic identifier##) context)

   :: expectingClosingBracketForGenericDeclarationList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for generic declaration list##) context)

   :: expectingDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting dependancy##) context)

   :: expectingReverseDependancy *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy##) context)

   :: expectingClosingBracketForDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy list##) context)

   :: expectingReverseDependancyList *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting reverse dependancy list##) context)

   :: expectingType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting type##) context)

   :: expectingOneOrMoreTypesForClassGenericInstantiation *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting one or more types for class generic instantiation##) context)

   :: expectingClosingBracketForClassGenericInstantiations *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for class generic instantiations##) context)

   :: expectingClosingBracketForType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for type##) context)

   :: expectingClosingBracketForDependancyWithDerivatives *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for dependancy with derivatives##) context)

   :: expectingIdentifierForObjectDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for object declaration##) context)

   :: expectingVisibilityIndicatorForInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting visibility indicator for instance method##) context)

   :: expectingIdentifierForClassMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for class method##) context)

   :: expectingClassMethodExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting class method expression##) context)

   :: expectingIdentifierForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for compiler injection##) context)

   :: expectingDataSegmentForCompilerInjection *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting data segment for compiler injection##) context)

   :: expectingPrologueStatement *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting prologue statement##) context)

   :: expectingMethodInput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method input##) context)

   :: expectingClosingBracketForMethodInputs *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for method inputs##) context)

   :: expectingMethodBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method body##) context)

   :: expectingMethodOutput *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method output##) context)

   :: expectingClosingBracketForStatementGroup *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for statement group##) context)

   :: expectingParentTypeForAnonymousClassObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting parent type for anonymous class object##) context)

   :: expectingClosingSquareBracketAfterAnonymousClassHeader *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing square bracket after anonymous class header##) context)

   :: expectingAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting anonymous class body##) context)

   :: expectingClosingBracketForAnonymousClassBody *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for anonymous class body##) context)

   :: unexpectedTokenAfterType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token after type##) context)

   :: expectingInstanceMethodIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance method identifier##) context)

   :: expectingExpressionToBeCast *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to be cast##) context)

   :: expectingClosingBracketForCastExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for cast expression##) context)

   :: expectingIdentifierForTypeMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for type method##) context)

   :: expectingEqualsToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting equals to assign local declaration##) context)

   :: expectingExpressionToAssignLocalDeclaration *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign local declaration##) context)

   :: expectingExpressionToAssignInstanceMethod *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance method##) context)

   :: expectingExpressionToAssignInstanceObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression to assign instance object##) context)

   :: expectingInstanceObjectIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting instance object identifier##) context)

   :: unexpectedTokenBeforeTilde *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Unexpected token before tilde##) context)

   :: expectingMethodToInvoke *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting method to invoke##) context)

   :: expectingProxyObject *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting proxy object##) context)

   :: expectingCompilerInjectionIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection identifier##) context)

   :: expectingCompilerInjectionDataSegment *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting compiler injection data segment##) context)

   :: expectingExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting expression##) context)

   :: expectingClosingBracketForExpression *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting closing bracket for expression##) context)

   :: expectingConstructorIdentifier *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting constructor identifier##) context)

   :: expectingTypeOrArrowForMethodType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting type or arrow for method type##) context)

   :: expectingIdentifierForClassGenericType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for class generic type##) context)

   :: expectingIdentifierForMethodGenericType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for method generic type##) context)

   :: expectingIdentifierForDataSegmentType *([SourcePosition] position) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
   } -> (\[Error]:errorWithContext (\[String]:as ##Expecting identifier for data segment type##) context)





   @ analyzer errors

   :: duplicateEntryPointClass *([SourcePosition] position1, [SourcePosition] position2) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position1; \context:append position2;
   } -> (\[Error]:errorWithContext (\[String]:as ##Duplicate entry point class##) context)

   :: duplicateClassName *([SourcePosition] position1, [SourcePosition] position2) -> [Error] {
      [List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position1; \context:append position2;
   } -> (\[Error]:errorWithContext (\[String]:as ##Duplicate class name##) context)

}


[CommandReader] (String) 
{
   ++ exit [->]
   ++ parseSourceFile [[String]->]
   ++ compileToFile [[String]->]
   ++ invalidCommand [->]
}



[Character] (Byte, Boolean, String, Data)
   [Byte] asciiByte
{
   ~ fromASCII *([Byte] asciiByte) {
      .asciiByte = asciiByte;
   }

   ~ space *{
      .asciiByte = \[Byte]:0x20;
   }

   ++ asASCII *->.asciiByte

   ++ description *-> (\[String]:asASCII \[Data]:copy [:[Sequence<[Byte]>]] { 
      |++ length *->\[Natural]:as ##1## 
      |++ atIndex *->\[Maybe<[Byte]>]:as .asciiByte
   })

   ++ isNULL *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x00))

   ++ isSemicolon *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3B))
   ++ isPlus *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2B))
   ++ isUnderscore *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5F))
   ++ isBackslash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5C))
   ++ isForwardslash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2F))
   ++ isFullstop *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2E))
   ++ isColon *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3A))
   ++ isTilde *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7E))
   ++ isHash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x23))
   ++ isDollarSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x24))
   ++ isBacktick *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x60))
   ++ isAmpersand *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x26))
   ++ isSingleApostrophe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x27))
   ++ isDash *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2D))
   ++ isArrowBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3C))
   ++ isArrowBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3E))
   ++ isAsterisk *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2A))
   ++ isCaret *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5E))
   ++ isComma *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x2C))
   ++ isCurlyBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7B))
   ++ isCurlyBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7D))
   ++ isDoubleApostrophe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x22))
   ++ isPipe *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x7C))
   ++ isStrudel *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x40))
   ++ isEqualsSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3D))
   ++ isExclamationMark *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x21))
   ++ isPercentSign *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x25))
   ++ isQuestionMark *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x3F))
   ++ isRoundBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x28))
   ++ isRoundBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x29))
   ++ isSquareBracketOpen *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5B))
   ++ isSquareBracketClose *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x5D))

   ++ isTab *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x09))
   ++ isNewline *->[Boolean]{}->(\.asciiByte:isEqualTo (\[Byte]:0x0A))

   ++ isAlphanumeric *->[Boolean] {
   } -> \[Boolean]:or (\[Boolean]:or (\.asciiByte:inclusiveBetween (\[Byte]:0x30) (\[Byte]:0x39)) (\.asciiByte:inclusiveBetween (\[Byte]:0x41) (\[Byte]:0x5A))) (\.asciiByte:inclusiveBetween (\[Byte]:0x61) (\[Byte]:0x7A))

   ++ isWhitespace *->[Boolean] {
      [Byte] b = (\[Byte]:0x09);
      [Boolean] thing = (\.asciiByte:inclusiveBetween b (\[Byte]:0x0D));
   } -> \[Boolean]:or thing (\.asciiByte:isEqualTo (\[Byte]:0x20))
}


[Configuration] (Maybe, Error, String, StandardIO) {
   
   ~ init *{}

   ++ outputError *([Error] error) {
      \[StandardIO]:stdout \(\error:description):ascii;
      \[StandardIO]:stdout \(\[String]:as ##\n##):ascii;
   }

   ++ commandInput *->[Maybe<[Data]>] {
      [Data] input = \[StandardIO]:stdin;
      [Boolean] emptyInput = (\0:isEqualTo (\input:length)) !{[Natural] 0 = (\[Natural]:as ##0##)};
   } -> \emptyInput:ifOrElse (\[Maybe<[[Data]->]>]:nothing) (*->\[Maybe<[Data]>]:as input)


   
   ++ compilationFileOutput *([String] filePath)-> [Maybe<[[Data]->]>] {
         [File] file = \[File]:atPath filePath;
         \file:clearContents;
         [Boolean] fileExists = \file:exists;
      } -> \fileExists:ifOrElse (*->\[Maybe<[[Data]->]>]:as (file:appendContents)) (\[Maybe<[[Data]->]>]:nothing)
   

   ++ sourceFileInput *([String] filePath)-> [Maybe<[->[Maybe<[Byte]>]]>] {
         [File] file = \[File]:atPath filePath;
         [Boolean] fileExists = \file:exists;
      } -> \fileExists:ifOrElse (*->[Maybe<[->[Maybe<[Byte]>]]>]{
            [Data] data = \file:readContents (\[Natural]:as ##1000000##);
            [Variable<[Natural]>] pos = \[Variable<[Natural]>]:as \[Natural]:as ##0##;
         }->\[Maybe<[->[Maybe<[Byte]>]]>]:as (
            *-> [Maybe<[Byte]>] {
               [Natural] thisPos = \pos:get;
               [Maybe<[Byte]>] bbite = (\data:atIndex thisPos);
               \pos:set \thisPos:adding \[Natural]:as ##1##;
               \bbite:isOrElse *([Byte] bbbbite) {
@\[Debug]:log (\[String]:as ##B::\n##);
                  } *{
@\[Debug]:log (\[String]:as ##B::nil\n##);
                  };
               @@

import std.stdio;writeln("B::");
            writeln(LOBJECT_bbite);
            writeln((cast(CLASSIMPL_Byte)LOBJECT_bbite).value.it);

               @@
            } -> bbite
         )) (*->\[Maybe<[[Data]->]>]:nothing)
}



[Token] (
         Natural,
         String,
         Boolean,
         Variable
      )
   [Natural] id
   [Natural] secondId
   [String] content
{
   ~ -+- basicToken *([Natural] id) {
      .id = id;
      .content = \[String]:as ####;
      .secondId = \[Natural]:as ##0##;
   }

   ~ -+- secondIdToken *([Natural] id, [Natural] secondId) {
      .id = id;
      .content = \[String]:as ####;
      .secondId = secondId;
   }

   ~ -+- contentToken *([Natural] id, [String] content) {
      .id = id;
      .content = content;
      .secondId = \[Natural]:as ##0##;
   }

   -+- id *->[Natural] {} -> .id
   -+- content *->[String] {} -> .content
   -+- secondId *->[Natural] {} -> .secondId
@@
   ++ asDebugString *->[String] {
      [String] idString = \[String]:stringRepresentationOfNatural .id;
      [String] seperator = \[String]:as "~";
      [String] secondIDString = \[String]:stringRepresentationOfNatural .secondId;
   } -> (\idString:appending (\seperator:appending (\secondIDString:appending (\seperator:appending .content))))
@@
   ++ ifIdentifier *([[String]->] ifIdentifier) {
      [Token] idToken = \[Token]:identifier (\[String]:as ####);
      [Boolean] isIdentifier = \.id:isEqualTo (\idToken:id);
      \isIdentifier:ifOrElse *{
         \ifIdentifier .content;
      } *{};
   }

   :: isVisibilityIndicator *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##1##))

   :: isDataSegment *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##4##))

   :: isIdentifier *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##3##))

   :: isParentIdentifier *([Token]t) -> [Boolean] {
      [Natural] id = \t:id;
   } -> (\id:isEqualTo (\[Natural]:as ##2##))

   @++ equals *([Token] t) -> [Boolean] {
   @} -> (\[Boolean]:and (\[Boolean]:and (\.content:isEqualTo (\t:content)) (\.secondId:isEqualTo (\t:secondId))) (\.id:isEqualTo (\t:id)))

   :: equals *([Token] t, [Token] t2) -> [Boolean] {
      [String] content = \t2:content;
      [Natural] id = \t2:id;
      [Natural] secondId = \t2:secondId;
   } -> (\[Boolean]:and (\[Boolean]:and (\content:isEqualTo (\t:content)) (\secondId:isEqualTo (\t:secondId))) (\id:isEqualTo (\t:id)))

   :: visibilityIndicator *([Boolean] externalVisibility, [Boolean] classVisibility, [Boolean] inheritedVisibility) -> [Token] {
      [Variable<[Natural]>] visibility = \[Variable<[Natural]>]:as (\[Natural]:as ##0##);
      \externalVisibility:ifOrElse (*{
            \visibility:set (\one:adding (\visibility:get));
         } !{[Natural] one = \[Natural]:as ##1##;}) *{};
      \classVisibility:ifOrElse (*{
            \visibility:set (\ten:adding (\visibility:get));
         } !{[Natural] ten = \[Natural]:as ##10##;}) *{};
      \inheritedVisibility:ifOrElse (*{
            \visibility:set (\hundred:adding (\visibility:get));
         } !{[Natural] hundred = \[Natural]:as ##100##;}) *{};
   } -> (\[Token]:secondIdToken (\[Natural]:as ##1##) (\visibility:get))

   :: parentIdentifier *([Natural] repetitionCount) -> (\[Token]:secondIdToken (\[Natural]:as ##2##) repetitionCount)
   :: identifier *([String] identifierString) -> (\[Token]:contentToken (\[Natural]:as ##3##) identifierString)
   :: dataSegment *([String] content) -> (\[Token]:contentToken (\[Natural]:as ##4##) content)
   
   :: ampersand *-> (\[Token]:basicToken \[Natural]:as ##5##)
   :: singleApostrophe *-> (\[Token]:basicToken \[Natural]:as ##6##)
   :: arrow *-> (\[Token]:basicToken \[Natural]:as ##7##)
   :: arrowBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##8##)
   :: arrowBracketClose *-> (\[Token]:basicToken \[Natural]:as ##9##)
   :: asterisk *-> (\[Token]:basicToken \[Natural]:as ##10##)
   :: asteriskCaret *-> (\[Token]:basicToken \[Natural]:as ##11##)
   :: asteriskArrow *-> (\[Token]:basicToken \[Natural]:as ##12##)
   :: backslash *-> (\[Token]:basicToken \[Natural]:as ##13##)
   :: caret *-> (\[Token]:basicToken \[Natural]:as ##14##)
   :: colon *-> (\[Token]:basicToken \[Natural]:as ##15##)
   :: comma *-> (\[Token]:basicToken \[Natural]:as ##16##)
   :: curlyBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##17##)
   :: curlyBracketClose *-> (\[Token]:basicToken \[Natural]:as ##18##)
   :: doubleApostrophe *-> (\[Token]:basicToken \[Natural]:as ##19##)
   :: doubleColon *-> (\[Token]:basicToken \[Natural]:as ##20##)
   :: equalsSign *-> (\[Token]:basicToken \[Natural]:as ##23##)
   :: exclamationMark *-> (\[Token]:basicToken \[Natural]:as ##24##)
   :: forwardSlash *-> (\[Token]:basicToken \[Natural]:as ##25##)
   :: fullStop *-> (\[Token]:basicToken \[Natural]:as ##26##)
   :: percentSign *-> (\[Token]:basicToken \[Natural]:as ##27##)
   :: pipe *-> (\[Token]:basicToken \[Natural]:as ##28##)
   :: questionMark *-> (\[Token]:basicToken \[Natural]:as ##29##)
   :: roundBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##30##)
   :: roundBracketClose *-> (\[Token]:basicToken \[Natural]:as ##31##)
   :: semicolon *-> (\[Token]:basicToken \[Natural]:as ##32##)
   :: squareBracketOpen *-> (\[Token]:basicToken \[Natural]:as ##33##)
   :: squareBracketClose *-> (\[Token]:basicToken \[Natural]:as ##34##)
   :: tilde *-> (\[Token]:basicToken \[Natural]:as ##36##)
   :: doubleLessThan *-> (\[Token]:basicToken \[Natural]:as ##37##)
   :: EOF *-> (\[Token]:basicToken \[Natural]:as ##38##)
}







[Parser] (
         String,
         Maybe,
         List,
         Error,
         Character,
         Byte,
         Token,
         SourcePosition,
         Boolean,
         Variable,
         Loops,
         Data,
         Integer
      ) 
   [->[Maybe<[Byte]>]] inputStream
   [List<[Error]>] errors
   [Variable<[Maybe<[Token]>]>] currentToken
   [Variable<[SourcePosition]>] currentTokenPosition
   [[[Maybe<[Token]>][SourcePosition]->][->]->] ifNextTokenOrElse
   [Variable<[Maybe<[Character]>]>] currentCharacter
   [SourcePosition] currentCharacterPosition
   [List<[Character]>] buffer
{
   ~ withSourceNameAndInput *([String] sourceName, [->[Maybe<[Byte]>]] inputStream) {
      .inputStream = inputStream;
      .errors = \[List<[Error]>]:empty;
      .currentToken = \[Variable<[?]>]:as (\[Maybe<[Token]>]:nothing);
      .buffer = \[List<[Character]>]:empty;
      .currentCharacter = \[Maybe<[Character]>]:nothing;
      [SourcePosition] initialPosition = \[SourcePosition]:initialPositionIn sourceName (\:getCopyOfNextLine);
      .currentCharacterPosition = initialPosition;
      .currentTokenPosition = \[Variable<[?]>]:as initialPosition;
      .ifNextTokenOrElse = *([]a,[->]else){\else};
      \:gotoNextCharacterTrue;
      \:gotoNextToken;
   }

   - getCopyOfNextLine *->[String] {
      [String] line = \:stringFromCharacters *([[Character]->] useCharacter) {
         \[Loops]:until *([->] stop) {
            [Maybe<[Character]>] nextChar = \(\.inputStream):isOrElse (*([Byte] b) -> [Maybe<[Character]>] {} -> \[Maybe<[Character]>]:as \[Character]:fromASCII b) ([Maybe<[Character]>]:nothing);
            \nextChar:isOrElse *([Character] c) {
               \.buffer:append c;
               [Boolean] notEndOfLine = \[Boolean]:not (\c:isNewline);
               \notEndOfLine:ifOrElse *{
                  [Boolean] cIsTab = \c:isTab;
                  \cIsTab:ifOrElse *{
                     \useCharacter (\[Character]:space);
                  } *{
                     \useCharacter c;
                  };
               } stop;
            } stop;
         };
      };
   } -> line

   - stringFromCharacters *([[[Character]->]->] getCharacters) -> [String] {
            [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
            \getCharacters *([Character] character) {
               \asciiString:append (\character:asASCII);
            };
         } -> \[String]:asASCII \[Data]:copy asciiString

    - gotoNextCharacter *{
      [Maybe<[Character]>] currentCharacter = .currentCharacter;
      \currentCharacter:isOrElse *([Character] t) {
         \(\t:isNULL):ifOrElse *{} *{\:gotoNextCharacterTrue;};
      } *{};
    }

   - gotoNextCharacterTrue *{
      [Maybe<[Character]>] currentCharacter = .currentCharacter;
      [Boolean] isNewline = \currentCharacter:isOrElse (*([Character] c) -> [Boolean] {
         } -> \c:isNewline) (*->\[Boolean]:false);
      [SourcePosition] currentCharacterPosition = .currentCharacterPosition;
      \isNewline:ifOrElse *{
         .currentCharacterPosition = \currentCharacterPosition:startOfNextLine (\:getCopyOfNextLine);
      } *{
         .currentCharacterPosition = \currentCharacterPosition:nextColumn;
      };
      [Maybe<[Character]>] bufferedChar = \.buffer:removeFirst;
      \bufferedChar:isOrElse *([Character] chaa){
         @\[Debug]:log (\[String]:as ##aChar: ##);
         @\[Debug]:log (\chaa:description);
         @\[Debug]:log (\[String]:as ##\n##);
      } *{
         @\[Debug]:log (\[String]:as ##nilChar\n##);
      };
      .currentCharacter = bufferedChar;
      @\bufferedChar:isOrElse *{} *{
         @.currentCharacter = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
      @};
   }

   - eatWhitespaceCharacters *{
      \[Loops]:while (*->[Boolean]{
         [Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
         [Maybe<[Character]>] currentCharacter = .currentCharacter;
         \currentCharacter:isOrElse *([Character] character) {
            \isWhitespace:set (\character:isWhitespace);
         } *{};
      } -> \isWhitespace:get) (:gotoNextCharacter);
   }

   ++ hasErrors *-> [Boolean] {} -> (\[Boolean]:not (\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)})

    ++ errors *-> [List<[Error]>] {} -> .errors

    ++ addError *([Error] error) {
      \.errors:append error;
    }

   ++ token *->[Token] {
      [Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
      [Maybe<[Token]>] m = \.currentToken:get;
      \m:isOrElse *([Token] t) {\token:set t} *{};
   } -> \token:get

   ++ position *->[SourcePosition] {} -> \.currentTokenPosition:get

   ++ peekAtNextToken *->[Token] {
      [Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
      \.ifNextTokenOrElse *([Maybe<[Token]>] t, [SourcePosition] p) {} *{
         [Maybe<[Token]>] currT = \.currentToken:get;
         [SourcePosition] currS = \.currentTokenPosition:get;
         \:gotoNextToken;
         [Maybe<[Token]>] nextT = \.currentToken:get;
         [SourcePosition] nextS = \.currentTokenPosition:get;
         \.currentToken:set currT;
         \.currentTokenPosition:set currS;
         .ifNextTokenOrElse = *([[Maybe<[Token]>][SourcePosition]->]get,[]e){
            \get nextT nextS;
         };
      };
      \.ifNextTokenOrElse *([Maybe<[Token]>] m, [SourcePosition] p) {
         \m:isOrElse *([Token] t) {\token:set t} *{};
      } *{};
   } -> \token:get

   ++ gotoNextSameTokens *([Token] token) -> [Natural] {
      [Variable<[Natural]>] number = \[Variable<[Natural]>]:as \[Natural]:as ##0##;
      [Natural] 1 = \[Natural]:as ##1##;
      \[Loops]:until *([->] stop) {
         [Boolean] nextTokenIsSame = \[Token]:equals (\:token) token;
         \nextTokenIsSame:ifOrElse *{
            \:gotoNextToken;
            \number:set \1:adding \number:get;
         } stop;
      };
   } -> \number:get

   ++ gotoNextToken *{
      \.ifNextTokenOrElse *([Maybe<[Token]>] m, [SourcePosition] p) {
         \m:isOrElse *([Token] t) {\setToken p t;} *{};
         .ifNextTokenOrElse = *([]a,[->]else){\else};
      } *{

      \.currentToken:set (\[Maybe<[Token]>]:nothing);
      \:eatWhitespaceCharacters;

      \ifStrudelOrElse *{
         \[Loops]:while (*->[Boolean]{
                  [Maybe<[Character]>] currentCharacter = .currentCharacter;
               }->\currentCharacter:isOrElse (*([Character] c)->\c:isStrudel) (*->\[Boolean]:false)) *{
            \:gotoNextCharacter;
            \ifStrudelOrElse *{
                     \:gotoNextCharacter;
                  [Variable<[Boolean]>] lastCharacterWasStrudel = \[Variable<[Boolean]>]:as (\[Boolean]:false);
                     \scanToken *([Character] thisCharacter, [->] continueScanning) {
                        \ifElse (thisCharacter:isStrudel) *{
                           \ifElse (lastCharacterWasStrudel:get) *{
                              \lastCharacterWasStrudel:set (\[Boolean]:false);
                              \:gotoNextCharacter;
                              \:eatWhitespaceCharacters;
                           } *{
                              \lastCharacterWasStrudel:set (\[Boolean]:true);
                              \continueScanning;
                           };
                        } *{
                           \lastCharacterWasStrudel:set (\[Boolean]:false);
                           \continueScanning;
                        };
               };
                  } *{
                     \scanToken *([Character] thisCharacter, [->] continueScanning) {
                        \ifElse (thisCharacter:isNewline) *{
                           \:eatWhitespaceCharacters;
                        } *{
                           \continueScanning;
                        };
               };
                  };
            };
        } *{};

        \ifHashOrElse *{
            [SourcePosition] position1 = .currentCharacterPosition;
         \:gotoNextCharacter;
         \ifHashOrElse *{
            \:gotoNextCharacter;
            [String] dataSegmentString = \stringFromCharacters *([[Character]->] useCharacter) {
               [Variable<[Character]>] variablePreviousCharacter = \[Variable<[Character]>]:as (\[Character]:space);
               \[Loops]:until *([->] stop) {
                  [Character] previousCharacter = \variablePreviousCharacter:get;
                  [Maybe<[Character]>] currentCharacter = .currentCharacter;
                  \currentCharacter:isOrElse *([Character] char) {\variablePreviousCharacter:set char} *{};
                  \ifElse (previousCharacter:isHash) *{
                     \ifHashOrElse stop *{
                        \useCharacter previousCharacter;
                        \currentCharacter:isOrElse *([Character] char) {\useCharacter char} *{
                           \:addError (\[Error]:expectingSecondDataSegmentAnchor position1);
                           \stop;
                        };
                     };
                  } *{
                     \ifHashOrElse *{} *{
                        \currentCharacter:isOrElse *([Character] char) {\useCharacter char} *{\:addError (
                           \[Error]:expectingSecondDataSegmentAnchor position1);
                           \stop;
                        };
                     };
                  };
                  \:gotoNextCharacter;
               } 
            };
            \ifElse ((\0:isEqualTo (\.errors:length)) !{[Natural] 0 = (\[Natural]:as ##0##)}) *{
               \setToken position1 (\[Token]:dataSegment dataSegmentString);
            } *{};            
         } *{
            \:addError (\[Error]:expectingSecondHashForDataSegmentAnchor position1);
         }; 
        } *{
         [Maybe<[Character]>] currentCharacter = .currentCharacter;
         \currentCharacter:isOrElse *([Character] character1) {
         [SourcePosition] position1 = .currentCharacterPosition;
         \:gotoNextCharacter;
         [Boolean] isIdentifier = \[Boolean]:or (\character1:isAlphanumeric) (\character1:isUnderscore);
         \isIdentifier:ifOrElse *{
            [String] identifierString = \stringFromCharacters *([[Character]->] useCharacter) {
               \useCharacter character1;
               \scanToken *([Character] thisCharacter, [->] continueScanning) {
                  [Boolean] thisCharacterIsForIdentifier = \[Boolean]:or (\thisCharacter:isAlphanumeric) (\thisCharacter:isUnderscore);
                  \thisCharacterIsForIdentifier:ifOrElse *{\useCharacter thisCharacter;\continueScanning;} *{};
               };
            };
            \setToken position1 (\[Token]:identifier identifierString);
         } *{};
         \if (character1:isDollarSign) *{
                  [Variable<[Integer]>] repetitionCount = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
                  \scanToken *([Character] thisCharacter, [->] continueScanning) {
                     \ifElse (thisCharacter:isDollarSign) *{
                        \repetitionCount:set (\x:adding (\[Integer]:as ##1##)) !{[Integer] x = \repetitionCount:get};
                        \continueScanning;
                     } *{};
                  };
                  \setToken position1 (\[Token]:parentIdentifier (\repetitionCount:get));
            };
            \if (*->\[Boolean]:or (\character1:isDash) (\character1:isPlus)) *{
                  \ifPlusOrDashOrElse (\[Maybe<[Character]>]:as character1) *{
                     \ifPlusOrDashOrElse .currentCharacter *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:false));
                        } *{
                           \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
                        };
                     } *{
                       
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{

                        \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
                     };
                  } *{
                     \ifPlusOrDashOrElse .currentCharacter *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \:gotoNextCharacter;
                        \ifPlusOrDashOrElse .currentCharacter *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
                        } *{
                           \:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
                        } *{
                           \:addError (\[Error]:invalidVisibilityIndicator position1);
                        };
                     } *{
                        \setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
                     };
                     
                  } *{
                  };
            };
         [Maybe<[Character]>] currentCharacter2 = .currentCharacter;
         \currentCharacter2:isOrElse *([Character] character2) {
            [SourcePosition] position2 = .currentCharacterPosition;
                \if (character1:isDash) *{
                     \if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:arrow)};
                  };
                \if (character1:isAsterisk) *{
                     \if (character2:isCaret) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskCaret)};
                     \if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskArrow)};
                  };
                   \if (character1:isColon) *{
                     \if (character2:isColon) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleColon)};
                  };
                \if (character1:isArrowBracketOpen) *{
                     \if (character2:isArrowBracketOpen) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleLessThan)};
                     };
         } *{}; 

         \ifNoToken *{
            \if (character1:isAmpersand) *{\setToken position1 (\[Token]:ampersand)};
            \if (character1:isSingleApostrophe) *{\setToken position1 (\[Token]:singleApostrophe)};
            \if (character1:isArrowBracketOpen) *{\setToken position1 (\[Token]:arrowBracketOpen)};
            \if (character1:isArrowBracketClose) *{\setToken position1 (\[Token]:arrowBracketClose)};
            \if (character1:isAsterisk) *{\setToken position1 (\[Token]:asterisk)};
            \if (character1:isBackslash) *{\setToken position1 (\[Token]:backslash)};
            \if (character1:isCaret) *{\setToken position1 (\[Token]:caret)};
            \if (character1:isColon) *{\setToken position1 (\[Token]:colon)};
            \if (character1:isComma) *{\setToken position1 (\[Token]:comma)};
            \if (character1:isCurlyBracketOpen) *{\setToken position1 (\[Token]:curlyBracketOpen)};
            \if (character1:isCurlyBracketClose) *{\setToken position1 (\[Token]:curlyBracketClose)};
            \if (character1:isDoubleApostrophe) *{\setToken position1 (\[Token]:doubleApostrophe)};
            \if (character1:isEqualsSign) *{\setToken position1 (\[Token]:equalsSign)};
            \if (character1:isExclamationMark) *{\setToken position1 (\[Token]:exclamationMark)};
            \if (character1:isForwardslash) *{\setToken position1 (\[Token]:forwardSlash)};
            \if (character1:isFullstop) *{\setToken position1 (\[Token]:fullStop)};
            \if (character1:isPercentSign) *{\setToken position1 (\[Token]:percentSign)};
            \if (character1:isPipe) *{\setToken position1 (\[Token]:pipe)};
            \if (character1:isQuestionMark) *{\setToken position1 (\[Token]:questionMark)};
            \if (character1:isRoundBracketOpen) *{\setToken position1 (\[Token]:roundBracketOpen)};
            \if (character1:isRoundBracketClose) *{\setToken position1 (\[Token]:roundBracketClose)};
            \if (character1:isSemicolon) *{\setToken position1 (\[Token]:semicolon)};
            \if (character1:isSquareBracketOpen) *{\setToken position1 (\[Token]:squareBracketOpen)};
            \if (character1:isSquareBracketClose) *{\setToken position1 (\[Token]:squareBracketClose)};
            \if (character1:isTilde) *{\setToken position1 (\[Token]:tilde)};
         };
         
         \ifNoToken *{
            \:addError (\[Error]:unrecognisedToken (\character1:description) position1);
         };
      } *{} };   
      }; 
   }  !{
         [[SourcePosition][Token]->] setToken = *([SourcePosition] position, [Token] token) {
            \.currentToken:set (\[Maybe<[Token]>]:as token);
            \.currentTokenPosition:set position;
         };
         [[->]->] ifNoToken = *([->] noToken) {
            (\currentToken:isOrElse *{} noToken) !{[Maybe<[Token]>] currentToken = \.currentToken:get};
         };
         [[->[Boolean]][->]->] if = *([->[Boolean]] condition, [->] action) {
            [Boolean] result = \condition;
            \result:ifOrElse action *{};
         };
         [[->[Boolean]][->][->]->] ifElse = *([->[Boolean]] condition, [->] action, [->] else) {
            [Boolean] result = \condition;
            \result:ifOrElse action else;
         };
         [[[Character][->]->]->] scanToken = *([[Character][->]->] provideCharacterAndContinueScannning) {
            [Variable<[Boolean]>] continuing = \[Variable<[Boolean]>]:as (\[Boolean]:true);
            \[Loops]:while (continuing:get) *{
               \continuing:set (\[Boolean]:false);
               [Maybe<[Character]>] maybeCurrentCharacter = .currentCharacter;
               \maybeCurrentCharacter:isOrElse *([Character] character) {
                  \provideCharacterAndContinueScannning character *{
                     \continuing:set (\[Boolean]:true);
                     \:gotoNextCharacter;
                  };
               } *{};
            };
         };
         [[[[Character]->]->]->[String]] stringFromCharacters = *([[[Character]->]->] getCharacters) -> [String] {
            [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
            \getCharacters *([Character] character) {
               \asciiString:append (\character:asASCII);
            };
         } -> \[String]:asASCII \[Data]:copy asciiString;
         [[->][->]->] ifStrudelOrElse = *([->] action, [->] else) {
            [Maybe<[Character]>] maybeCurrentCharacter = .currentCharacter;
            \maybeCurrentCharacter:isOrElse *([Character] currentCharacter) {
               \ifElse (currentCharacter:isStrudel) action else;
            } else;
         };
         [[->][->]->] ifHashOrElse = *([->] action, [->] else) {
            [Maybe<[Character]>] maybeCurrentCharacter = .currentCharacter;
            \maybeCurrentCharacter:isOrElse *([Character] currentCharacter) {
               \ifElse (currentCharacter:isHash) action else;
            } else;
         };
         [[Maybe<[Character]>][->][->][->]->] ifPlusOrDashOrElse = *([Maybe<[Character]>] maybeChar, [->] plus, [->] dash, [->] else) {
            \maybeChar:isOrElse *([Character] char) {
               \ifElse (char:isPlus) plus *{
                  \ifElse (char:isDash) dash else;
               };
            } else;
         };
      }
}



[Commands] (InputStream, CommandReader, Maybe, Byte, Debug, Boolean, String, Character, Loops, Variable, Data) 
   [->[Maybe<[Byte]>]] inputStream
   [Maybe<[Character]>] currentCharacter
{
   ~ from *([->[Maybe<[Data]>]] dataInputStream) {
      [Variable<[Maybe<[Data]>]>] varCurrentData = \[Variable<[Maybe<[Data]>]>]:as \[Maybe<[Data]>]:nothing;
      [Variable<[Natural]>] currentIndex = \[Variable<[Natural]>]:as \[Natural]:as ##0##;
      [Natural] 1 = \[Natural]:as ##1##;
      [Natural] 0 = \[Natural]:as ##0##;
      .inputStream = * -> [Maybe<[Byte]>] {
         [Variable<[Maybe<[Byte]>]>] nextByte = \[Variable<[Maybe<[Byte]>]>]:as \[Maybe<[Byte]>]:nothing;
         [Maybe<[Data]>] maybeCurrentData = (\varCurrentData:get);
         [->] gotoNextData = *{
            \varCurrentData:set \dataInputStream;
            \currentIndex:set 0;
         };
         \maybeCurrentData:isOrElse *([Data] currentData){
            [Maybe<[Byte]>] inCurrentData = \currentData:atIndex \currentIndex:get;
            \inCurrentData:isOrElse (*([Byte] b) {
            }) gotoNextData;
         } gotoNextData;
         [Maybe<[Data]>] maybeCurrentData2 = (\varCurrentData:get);
         \maybeCurrentData2:isOrElse *([Data] currentData){
         
            [Maybe<[Byte]>] inCurrentData = \currentData:atIndex \currentIndex:get;
            \inCurrentData:isOrElse (*([Byte] b) {
               \nextByte:set \[Maybe<[Byte]>]:as b;
               \currentIndex:set \1:adding \currentIndex:get;
            }) *{};

         } *{};
            
         
      } -> \nextByte:get;

      .currentCharacter = \[Maybe<[Character]>]:nothing;
      \:readNextCharacter;
   }

   ++ readNext *([CommandReader] reader) {
      \:eatWhitespaceCharacters;
      \.currentCharacter:isOrElse *([Character] character) {
         [Boolean] exit = (\character:isSemicolon);
         \exit:ifOrElse reader:exit *{};
         [Variable<[Boolean]>] validCommand = \[Variable<[Boolean]>]:as exit;
         [Boolean] parseSourceFile = (\character:isPlus);
         \parseSourceFile:ifOrElse *{
            \reader:parseSourceFile (\:readNextFilePath);
            \validCommand:set (\[Boolean]:true);
         } *{};
         [Boolean] compileToFile = (\character:isTilde);
         \compileToFile:ifOrElse *{
            [String] compilationMethod = \:readNextString (*([Character]c)->\c:isAlphanumeric);
            \:eatWhitespaceCharacters;
            [Boolean] colonPresent = (\.currentCharacter:isOrElse (*([Character]c)->\c:isColon) (*->\[Boolean]:false));
            \colonPresent:ifOrElse *{
               \reader:compileToFile (\:readNextFilePath);
               \validCommand:set (\[Boolean]:true);
            } *{};
         } *{};
         [Boolean] invalidCommand = \[Boolean]:not (\validCommand:get);
         \invalidCommand:ifOrElse *{
            \reader:invalidCommand;
            \:readNextCharacter;
         } *{};
      } (reader:exit);
   }

   - readNextCharacter *{
      [Maybe<[Byte]>] input = (\.inputStream);
      .currentCharacter = \input:isOrElse (*([Byte] b)->(\[Maybe<[Character]>]:as (\[Character]:fromASCII b))) ([Maybe<[Character]>]:nothing);
   }

   - readNextString *([[Character]->[Boolean]] inString) -> [String] {
      \:eatWhitespaceCharacters;
      [List<[Byte]>] asciiString = \[List<[Byte]>]:empty;
      \[Loops]:while (*->[Boolean]{
            [Variable<[Boolean]>] charcterInString = \[Variable<[Boolean]>]:as (\[Boolean]:false);
            \:readNextCharacter;
            \.currentCharacter:isOrElse *([Character] character) {
               \charcterInString:set (\inString character);
            } *{};
         } -> \charcterInString:get) *{
            \.currentCharacter:isOrElse *([Character] character) {
               \asciiString:append (\character:asASCII);
            } *{};
         };
   } -> \[String]:asASCII \[Data]:copy asciiString

   - readNextFilePath *-> [String] {
   } -> \:readNextString *([Character] c) ->[Boolean] {
      } -> \[Boolean]:or (\[Boolean]:or (\[Boolean]:or (\[Boolean]:or (\c:isAlphanumeric) (\c:isFullstop)) (\c:isForwardslash)) (\c:isBackslash)) (\c:isUnderscore)

   - eatWhitespaceCharacters *{
      \[Loops]:while (*->[Boolean]{
         [Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
         \.currentCharacter:isOrElse *([Character] character) {
            \isWhitespace:set (\character:isWhitespace);
         } *{
         };
      } -> \isWhitespace:get) (:readNextCharacter);
   }
}



[DainaGeneralIdentifier] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String, Variable,
         Error, M, O,

         Debug
      )
   @[Variable<[Maybe<[String]>]>]
      [String] content

{
   :: isFirstToken *([Token] token) -> [Boolean] {
      [Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
      \token:ifIdentifier *([String] s) {
         \isIdentifier:set \[Boolean]:true;
      };
   } -> (\isIdentifier:get)

   ~ base *{
      .content = \[String]:as ####;
   }

   ++ content *->.content

   ++ isVoidIdentifier *-> \.content:isEqualTo \[String]:as ##_##

   ++ parse *([Parser] parser) {
      [Token] identifierToken = \parser:token;
      \identifierToken:ifIdentifier *([String] s) {
      .content = s;
         @\isIdentifier:set \[Boolean]:true;
      };
      \parser:gotoNextToken;
   }
}


[DainaGenericDeclarationList] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,

         Debug
      )
   [List<[DainaGeneralIdentifier]>] generics
{
   ~ base *{
      .generics = \[List<[DainaGeneralIdentifier]>]:empty;
   }

   ++ parse *([Parser] parser) {
      \(\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen):ifOrElse *{
         \parser:gotoNextToken;
         \[Loops]:until *([->] stop) {
            \(\[DainaGeneralIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
               [DainaGeneralIdentifier] generic = \[DainaGeneralIdentifier]:base;
               \generic:parse parser;
               \.generics:append generic;
               \(\[Token]:equals (\parser:token) \[Token]:comma):ifOrElse *{
                  \parser:gotoNextToken;
               } stop;
            } *{
               \parser:addError (\[Error]:expectingGenericIdentifier (\parser:position));
               \stop;
            };
         };
         \(\[Token]:equals (\parser:token) \[Token]:arrowBracketClose):ifOrElse *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForGenericDeclarationList (\parser:position));
         };
      } *{};
   }
}


[DainaDependancyStructure] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,
         SourcePosition,
         DainaClassIdentifier,

         Debug
      )
   [List<[DainaClassIdentifier]>] dependancies
   [List<[DainaClassIdentifier]>] dependanciesWithDerivatives
   [List<[DainaClassIdentifier]>] reverseDependancies
{
   ~ base *{
      .dependancies = \[List<[DainaClassIdentifier]>]:empty;
      .reverseDependancies = \[List<[DainaClassIdentifier]>]:empty;
      .dependanciesWithDerivatives = \[List<[DainaClassIdentifier]>]:empty;
   }

   ++ parse *([Parser] parser) {{
      \(\[Token]:equals (\parser:token) \[Token]:roundBracketOpen):ifOrElse *{
         \parseIDList .dependancies ([Error]:expectingDependancy) (\[Maybe<[List<[DainaClassIdentifier]>]>]:as .dependanciesWithDerivatives);
         \(\[Token]:equals (\parser:token) (\[Token]:arrow)):ifOrElse *{
            \parser:gotoNextToken;
            \(\[Token]:equals (\parser:token) \[Token]:roundBracketOpen):ifOrElse *{
               \parseIDList .reverseDependancies ([Error]:expectingReverseDependancy) (\[Maybe<[List<[DainaClassIdentifier]>]>]:nothing);
            } *{
               \parser:addError (\[Error]:expectingReverseDependancyList (\parser:position));
            };
         } *{};
      } *{};
   }  !{
         [[List<[DainaClassIdentifier]>][[SourcePosition]->[Error]][Maybe<[List<[DainaClassIdentifier]>]>]->] parseIDList = *([List<[DainaClassIdentifier]>] list, [[SourcePosition]->[Error]] missingIDError, [Maybe<[List<[DainaClassIdentifier]>]>] maybeDerivativeList) {
            \parser:gotoNextToken;
            \(\[DainaClassIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
               \[Loops]:until *([->] stop) {
                  \(\[DainaClassIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
                     [DainaClassIdentifier] id = \[DainaClassIdentifier]:base;
                     \id:parse parser;
                     \list:append id;
                     \(\[Token]:equals (\parser:token) \[Token]:comma):ifOrElse *{
                        \parser:gotoNextToken;
                     } stop;
                  } *{
                     \maybeDerivativeList:isOrElse *([List<[DainaClassIdentifier]>] derivativeList) {
                        \(\[Token]:equals (\parser:token) \[Token]:roundBracketOpen):ifOrElse *{
                           \parser:gotoNextToken;
                           \(\[DainaClassIdentifier]:isFirstToken (\parser:token)):ifOrElse *{
                              [DainaClassIdentifier] id = \[DainaClassIdentifier]:base;
                              \id:parse parser;
                              \list:append id;
                              \derivativeList:append id;
                              \(\[Token]:equals (\parser:token) \[Token]:roundBracketClose):ifOrElse *{
                                 \parser:gotoNextToken;
                                 \(\[Token]:equals (\parser:token) \[Token]:comma):ifOrElse *{
                                    \parser:gotoNextToken;
                                 } stop;
                              } *{
                                 \parser:addError (\[Error]:expectingClosingBracketForDependancyWithDerivatives (\parser:position));
                                 \stop;
                              };
                           } missingId;
                        } missingId;
                     } missingId;
                  }  !{ 
                        [->] missingId = *{
                           \parser:addError (\missingIDError (\parser:position));
                           \stop;
                        }
                     };
               };
            } *{};
            \(\[Token]:equals (\parser:token) \[Token]:roundBracketClose):ifOrElse *{
               \parser:gotoNextToken;
            } *{
               \parser:addError (\[Error]:expectingClosingBracketForDependancyList (\parser:position));
            };
         };
         }}
}



[DainaClassIdentifier] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String, Variable,
         Error, M, O,

         Debug
      )
   @[Variable<[Maybe<[String]>]>]
   [String] content
{
   :: isFirstToken *([Token] token) -> [Boolean] {
      [Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
      \token:ifIdentifier *([String] s) {
         [Boolean] usingVoidIdentifier = \s:isEqualTo \[String]:as ##_##;
         \usingVoidIdentifier:ifOrElse *{} *\isIdentifier:set \[Boolean]:true;
      };
   } -> (\isIdentifier:get)

   ~ base *{
      .content = \[String]:as ####;
   }

   ++ content *->.content

   ++ parse *([Parser] parser) {
      [Token] identifierToken = \parser:token;
      \identifierToken:ifIdentifier *([String] s) {
      .content = s;
         @\isIdentifier:set \[Boolean]:true;
      };
      \parser:gotoNextToken;
   }
}




[DainaObjectDeclaration] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaType,
         DainaGeneralIdentifier,

         Debug
      )
   [DainaType] type
   [DainaGeneralIdentifier] identifier
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Boolean]:or (\[DainaType]:isFirstToken token) (\[DainaGeneralIdentifier]:isFirstToken token))

   ++ type*->.type
   ++ identifier*->.identifier

   ~ base *{
      .type = \[DainaType]:root;
      .identifier = \[DainaGeneralIdentifier]:base;
   }

   ~ as *([DainaType] type, [DainaGeneralIdentifier] identifier){
      .type = type;
      .identifier = identifier;
   }

   ++ parse *([Parser] parser) {
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
         \.identifier:parse parser;
      } *{
         \.type:parse parser;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            \.identifier:parse parser;
         } *{
            \parser:addError (\[Error]:expectingIdentifierForObjectDeclaration (\parser:position));
         };
      };
   }
}


@class-method-classification identifier ( type | expression )

@    class-method-classification: ( ( | | || )? method-visibility-indicator ) | ( ( ~ | :: ) ( | )? ( method-visibility-indicator )? )


[DainaClassMethod<DainaExpression>] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,
         Variable,
         DainaType,

         Debug
      )
   [Variable<[Boolean]>] unimplementedMethod
   [DainaGeneralIdentifier] identifier
   [&DainaExpression] methodExpression
   [[->][->][->]->] isInstanceTypeOrConstructor
   [[Parser][&DainaExpression]->] parseExpression
   [[Token]->[Boolean]] isExpressionFirstToken
   [DainaType] unimplementedType
   [Boolean] overriding
{
   ++ isInstanceTypeOrConstructor *([->] isInstance,[->] isType,[->] isConstructor) {
      \.isInstanceTypeOrConstructor isInstance isType isConstructor;
   }

   ++ isUnimplementedMethod *->(\.unimplementedMethod:get)

   ++ isOverridingMethod *->(.overriding)

   ++ unimplementedType *->(.unimplementedType)

   ++ methodExpression *->.methodExpression

   ++ identifier*-> .identifier

   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Boolean]:or (\[Boolean]:or (\[Token]:isVisibilityIndicator token) (\[Token]:equals token (\[Token]:pipe))) (\[Boolean]:or (\[Token]:equals token (\[Token]:doubleColon)) (\[Token]:equals token (\[Token]:tilde))))

   ~ base *([->[&DainaExpression]] getBase, [[Parser][&DainaExpression]->] parseExpression, [[Token]->[Boolean]] isExpressionFirstToken){
      .isInstanceTypeOrConstructor = *([->]a,[]b,[]c){};
      .methodExpression = \getBase;
      .identifier = \[DainaGeneralIdentifier]:base;
      .unimplementedMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      .parseExpression = parseExpression;
      .isExpressionFirstToken = isExpressionFirstToken;
      .unimplementedType = \[DainaType]:root;
      .overriding = \[Boolean]:false;
   }

   ++ parse *([Parser] parser) {
      .isInstanceTypeOrConstructor = *([->]a,[]b,[]c){\a};
      \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:tilde)) *{
         \parser:gotoNextToken;
         .isInstanceTypeOrConstructor = *([]a,[]b,[->]c){\c};
      } *{
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:doubleColon)) *{
            \parser:gotoNextToken;
            .isInstanceTypeOrConstructor = *([]a,[->]b,[]c){\b};
         } *{};
      };
      \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:pipe)) *{
         .overriding = \[Boolean]:true;
         \parser:gotoNextToken;
      } *{};
      \.isInstanceTypeOrConstructor *{
         \[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingVisibilityIndicatorForInstanceMethod (\parser:position));
         };
      } *{
         \[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
            \parser:gotoNextToken;
         } *{};
      } *{
         \[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
            \parser:gotoNextToken;
         } *{};
      };
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
         \.identifier:parse parser;
         \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
            \.unimplementedMethod:set (\[Boolean]:true); 
            [DainaType] typeForUnimplemented = \[DainaType]:root;
            \.unimplementedType:parse parser;
         } *{
            \[O]:ifElse (\.isExpressionFirstToken (\parser:token)) *{
               \.parseExpression parser (.methodExpression);
            } *{
               \parser:addError (\[Error]:expectingClassMethodExpression (\parser:position));
            };
         };
      } *{
         \parser:addError (\[Error]:expectingIdentifierForClassMethod (\parser:position));
      };
   }
}



[DainaCompilerInjection] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaGeneralIdentifier,

         Debug
      )
   [DainaGeneralIdentifier] identifier
   [String] dataSegment
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:doubleLessThan)

   ~ base *{
      .identifier = \[DainaGeneralIdentifier]:base;
      .dataSegment = \[String]:as ####;
   }

   ++ identifierString *->\.identifier:content

   ++ dataSegment *->.dataSegment

   ++ parse *([Parser] parser) {
      \parser:gotoNextToken;
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
         \.identifier:parse parser;
         \[O]:ifElse (\[Token]:isDataSegment (\parser:token)) *{
            [Token] token = (\parser:token);
            .dataSegment = \token:content;
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingDataSegmentForCompilerInjection (\parser:position));
         };
      } *{
         \parser:addError (\[Error]:expectingIdentifierForCompilerInjection (\parser:position));
      };
   }
}



[DainaExpression] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaObjectDeclaration,
         DainaType,
         Variable,
         DainaClassMethod,
         DainaGeneralIdentifier,
         Integer,
         DainaCompilerInjection,

         Debug
      )
   [DainaType] outputType
   [[[List<[DainaExpression]>]->]->] ifStatementGroup
   [[[String]->]->] ifDataSegment
   [[[DainaExpression][DainaExpression]->]->] ifWithPrologueStatement
   [[[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->]->] ifMethodExpression
   [[[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->]->] ifAnonymousClassObject
   [[[DainaExpression][DainaGeneralIdentifier]->]->] ifInstanceMethod
   [[[DainaObjectDeclaration][DainaExpression]->]->] ifLocalObjectAssignment
   [[[DainaType][DainaGeneralIdentifier]->]->] ifTypeMethod

   [[[DainaExpression][List<[DainaExpression]>]->]->] ifInvocation
   [[[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->]->] ifConstructorInvocation @ parentnum, identifier, ispointerconsturcotr, params
   [[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceMethodAssignment
   [[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceObjectAssignment
   [[[DainaExpression]->]->] ifProxyObject
   [[[DainaCompilerInjection]->]->] ifCompilerInjection
   [[[DainaGeneralIdentifier]->]->] ifLocalObject
   [[[Integer][DainaGeneralIdentifier]->]->] ifInternalInstanceMethod @ prentnum, id
   [[[DainaGeneralIdentifier]->]->] ifInternalInstanceObject
   [[->]->] ifSelfReference
   [[->]->] ifMethodSelfReference
   
{
   :: isFirstToken *([Token] token) -> [Boolean] {
   } ->  

(\[Boolean]:or (\[Token]:equals token (\[Token]:backslash))
(\[Boolean]:or (\[Token]:equals token (\[Token]:fullStop))
(\[Boolean]:or (\[Token]:equals token (\[Token]:colon))
(\[Boolean]:or (\[Token]:equals token (\[Token]:asteriskCaret))
(\[Boolean]:or (\[Token]:equals token (\[Token]:asteriskArrow))
(\[Boolean]:or (\[Token]:equals token (\[Token]:caret))
(\[Boolean]:or (\[Token]:equals token (\[Token]:doubleLessThan))
(\[Boolean]:or (\[Token]:equals token (\[Token]:roundBracketOpen))
(\[Boolean]:or (\[Token]:isIdentifier token)
(\[Boolean]:or (\[Token]:isParentIdentifier token)

   (\[Boolean]:or (\[Token]:equals token (\[Token]:squareBracketOpen)) (\[Boolean]:or (\[Token]:equals token (\[Token]:curlyBracketOpen)) (\[Boolean]:or (\[Token]:isDataSegment token) (\[Token]:equals token (\[Token]:asterisk))))) ))))))))))


   ~ base *{
      .ifStatementGroup = *([[List<[DainaExpression]>]->]get){};
      .ifDataSegment = *([]a){};
      .ifWithPrologueStatement = *([]a){};
      .ifMethodExpression = *([]a){};
      .ifAnonymousClassObject = *([]a){};
      .ifInstanceMethod = *([]a){};
      .ifLocalObjectAssignment = *([]a){};
      .ifTypeMethod = *([]a){};
      .outputType = \[DainaType]:root;

      .ifInvocation = *([]a){};
      .ifConstructorInvocation = *([]a){};
      .ifInstanceMethodAssignment = *([]a){};
      .ifInstanceObjectAssignment = *([]a){};
      .ifProxyObject = *([]a){};
      .ifCompilerInjection = *([]a){};
      .ifLocalObject = *([]a){};
      .ifInternalInstanceMethod = *([]a){};
      .ifInternalInstanceObject = *([]a){};
      .ifSelfReference = *([]a){};
      .ifMethodSelfReference = *([]a){};
   }

   ++ toBase *{
      .ifStatementGroup = *([[List<[DainaExpression]>]->]get){};
      .ifDataSegment = *([]a){};
      .ifWithPrologueStatement = *([]a){};
      .ifMethodExpression = *([]a){};
      .ifAnonymousClassObject = *([]a){};
      .ifInstanceMethod = *([]a){};
      .ifLocalObjectAssignment = *([]a){};
      .ifTypeMethod = *([]a){};
      .outputType = \[DainaType]:root;

      .ifInvocation = *([]a){};
      .ifConstructorInvocation = *([]a){};
      .ifInstanceMethodAssignment = *([]a){};
      .ifInstanceObjectAssignment = *([]a){};
      .ifProxyObject = *([]a){};
      .ifCompilerInjection = *([]a){};
      .ifLocalObject = *([]a){};
      .ifInternalInstanceMethod = *([]a){};
      .ifInternalInstanceObject = *([]a){};
      .ifSelfReference = *([]a){};
      .ifMethodSelfReference = *([]a){};
   }

   ++ outputType *->[DainaType]{}->.outputType
   ++ setOutputType *([DainaType] outputType) {.outputType = outputType}

   ++ ifInvocation *([[DainaExpression][List<[DainaExpression]>]->] get) {\.ifInvocation get}
   ++ ifConstructorInvocation *([[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->] get) {\.ifConstructorInvocation get}
   ++ ifInstanceMethodAssignment *([[DainaGeneralIdentifier][DainaExpression]->] get) {\.ifInstanceMethodAssignment get}
   ++ ifInstanceObjectAssignment *([[DainaGeneralIdentifier][DainaExpression]->] get) {\.ifInstanceObjectAssignment get}
   ++ ifProxyObject *([[DainaExpression]->] get) {\.ifProxyObject get}
   ++ ifCompilerInjection *([[DainaCompilerInjection]->] get) {\.ifCompilerInjection get}
   ++ ifLocalObject *([[DainaGeneralIdentifier]->] get) {\.ifLocalObject get}
   ++ ifInternalInstanceMethod *([[Integer][DainaGeneralIdentifier]->] get) {\.ifInternalInstanceMethod get}
   ++ ifInternalInstanceObject *([[DainaGeneralIdentifier]->] get) {\.ifInternalInstanceObject get}
   ++ ifSelfReference *([->] get) {\.ifSelfReference get}
   ++ ifMethodSelfReference *([->] get) {\.ifMethodSelfReference get}

   ++ ifStatementGroup *([[List<[DainaExpression]>]->] get) {\.ifStatementGroup get}
   ++ ifDataSegment *([[String]->] get) {\.ifDataSegment get}
   ++ ifWithPrologueStatement *([[DainaExpression][DainaExpression]->] get) {\.ifWithPrologueStatement get}
   ++ ifMethodExpression *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {\.ifMethodExpression get}
   ++ ifAnonymousClassObject *([[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->] get) {\.ifAnonymousClassObject get}
   ++ ifInstanceMethod *([[DainaExpression][DainaGeneralIdentifier]->] get) {\.ifInstanceMethod get}
   ++ ifLocalObjectAssignment *([[DainaObjectDeclaration][DainaExpression]->] get) {\.ifLocalObjectAssignment get}
   ++ ifTypeMethod *([[DainaType][DainaGeneralIdentifier]->] get) {\.ifTypeMethod get}

   -+- copy *([DainaExpression] other) {
      .ifStatementGroup = other:ifStatementGroup;
      .ifDataSegment = other:ifDataSegment;
      .ifWithPrologueStatement = other:ifWithPrologueStatement;
      .ifMethodExpression = other:ifMethodExpression;
      .ifAnonymousClassObject = other:ifAnonymousClassObject;
      .ifInstanceMethod = other:ifInstanceMethod;
      .ifLocalObjectAssignment = other:ifLocalObjectAssignment;
      .ifTypeMethod = other:ifTypeMethod;
      .outputType = \other:outputType;

      .ifInvocation = other:ifInvocation;
      .ifConstructorInvocation = other:ifConstructorInvocation;
      .ifInstanceMethodAssignment = other:ifInstanceMethodAssignment;
      .ifInstanceObjectAssignment = other:ifInstanceObjectAssignment;
      .ifProxyObject = other:ifProxyObject;
      .ifCompilerInjection = other:ifCompilerInjection;
      .ifLocalObject = other:ifLocalObject;
      .ifInternalInstanceMethod = other:ifInternalInstanceMethod;
      .ifInternalInstanceObject = other:ifInternalInstanceObject;
      .ifSelfReference = other:ifSelfReference;
      .ifMethodSelfReference = other:ifMethodSelfReference;
   }
@@
   - copyTo *([DainaExpression] it) {
      @[DainaExpression] me = \[DainaExpression]:base;
      <instant
      ##
         //Z_local_me = Z_self;
      ##;
      @\it:copy me;
      <instant
      ##

      void* Z_temporary_9 = ((void *)(0));
           //ASSIGN temporary_9 = Z_self
/*C*/      Z_temporary_9 = Z_self;
           //CREATE STATIC_OBJECT temporary_11 WITH METHOD classmethod_DainaExpression_copy
/*C*/      void* Z_temporary_11 = &Z_classmethod_DainaExpression_copy;
           //CREATE DYNAMIC_OBJECT temporary_10 WITH METHOD[STATIC_OBJECT] temporary_11 FRAME{STATIC(),DYNAMIC(local_it)}
/*C*/      void* Z_temporary_10 = allocateDynamicLambda(1,1,Z_temporary_11);
/*C*/      *(((void* *)(Z_temporary_10+sizeof(DynamicLambda)+sizeof(void*)*0))) = Z_local_it;
           //CREATE OBJECT temporary_8 = INVOKE temporary_10(temporary_9)
/*C*/      void* Z_temporary_8 = ((void*(*)(void*,void*))(((DynamicLambda *)(Z_temporary_10))->method))(Z_temporary_10+sizeof(DynamicLambda), Z_temporary_9);


         //Z_local_me = Z_self;
      ##;
   }@@

   ++ makeEmptyStatement *{.ifStatementGroup = *([[List<[DainaExpression]>]->] get){\get (\[List<[DainaExpression]>]:empty)}}

   ++ parse *([Parser] parser) {
      [DainaExpression] left = \[DainaExpression]:base;
      \left:parseStrongBinding parser;
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:exclamationMark) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
            [DainaExpression] right = \[DainaExpression]:base;
            \right:parse parser;
            .ifWithPrologueStatement = *([[DainaExpression][DainaExpression]->] get) {\get left right};
         } *{
            \parser:addError (\[Error]:expectingPrologueStatement (\parser:position));
         };
      } *{
         \:copy left;
      };
   }

   

   -+- parseStrongBinding *([Parser] parser) {
      [DainaExpression] left = \[DainaExpression]:base;
      \left:parseStrongestBinding parser;
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:colon) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] right = \[DainaGeneralIdentifier]:base;
            \right:parse parser;
            .ifInstanceMethod = *([[DainaExpression][DainaGeneralIdentifier]->] get) {\get left right};
         } *{
            \parser:addError (\[Error]:expectingInstanceMethodIdentifier (\parser:position));
         };
      } *{
         \:copy left;
      };
   }

   -+- parseStrongestBinding *([Parser] parser) {
      [Token] token1 = (\parser:token);
      [Token] token2 = (\parser:peekAtNextToken);
      \[O]:ifElse (\[Token]:isDataSegment token1) *{
         .ifDataSegment = *([[String]->] get) {\get (\token1:content)};
         \parser:gotoNextToken;
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:asterisk)) *{
         \parser:gotoNextToken;
         [List<[DainaObjectDeclaration]>] parameters = \[List<[DainaObjectDeclaration]>]:empty;
         [DainaExpression] body = (\[DainaExpression]:base);
         [Variable<[Maybe<[DainaExpression]>]>] output = \[Variable<[Maybe<[DainaExpression]>]>]:as (\[Maybe<[DainaExpression]>]:nothing);
         .ifMethodExpression = *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {
            \get parameters body (\output:get);
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
            \parser:gotoNextToken;
            \[Loops]:until *([->] stop) {
               \[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
                  [DainaObjectDeclaration] parameter = \[DainaObjectDeclaration]:base;
                  \parameter:parse parser;
                  \parameters:append parameter;
               } *{
                  \parser:addError (\[Error]:expectingMethodInput (\parser:position));
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:comma)) (parser:gotoNextToken) stop;
            };
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
               \parser:gotoNextToken;
            } *{
               \parser:addError (\[Error]:expectingClosingBracketForMethodInputs (\parser:position));
            };
         } *{};
         \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
            \body:parseStrongBinding parser;
         } *{
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[Boolean]:and (\[DainaType]:isFirstToken (\parser:token)) (\[Boolean]:not (\[Token]:equals (\parser:peekAtNextToken) (\[Token]:colon)))) *{
                  [DainaType] outputType = \[DainaType]:root;
                  \outputType:parse parser;
                  .outputType = outputType;
                  \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                     \body:parseStrongBinding parser;
                  } *{
                     \parser:addError (\[Error]:expectingMethodBody (\parser:position));
                  };
                  \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
                     \parser:gotoNextToken;
                  } *{
                     \parser:addError (\[Error]:expectingMethodOutput (\parser:position));
                  };
               } *{
                  \body:makeEmptyStatement;
               };
               \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                  [DainaExpression] outputExpression = \[DainaExpression]:base;
                  \outputExpression:parseStrongBinding parser;
                  \output:set (\[Maybe<[DainaExpression]>]:as outputExpression);
               } *{
                  \parser:addError (\[Error]:expectingMethodOutput (\parser:position));
               };
            } *{
               \body:makeEmptyStatement;
            };
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:curlyBracketOpen)) *{
         \parser:gotoNextToken;
         [List<[DainaExpression]>] statements = \[List<[DainaExpression]>]:empty;
         .ifStatementGroup = *([[List<[DainaExpression]>]->] get) {\get statements};
         \[Loops]:until *([->] stop) {
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] statement = \[DainaExpression]:base;
               \statement:parse parser;
               \statements:append statement;
            } *{};
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:semicolon)) (parser:gotoNextToken) stop;
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketClose)) *{
            \parser:gotoNextToken;
         } *{
            \parser:addError (\[Error]:expectingClosingBracketForStatementGroup (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Boolean]:and (\[Token]:equals token1 (\[Token]:squareBracketOpen)) (\[Token]:equals token2 (\[Token]:colon))) *{
         @anonymous-class-object
         \parser:gotoNextToken;
         \parser:gotoNextToken;
         [List<[DainaType]>] parents = \[List<[DainaType]>]:empty;
         [List<[DainaExpression]>] constructor = \[List<[DainaExpression]>]:empty;
         [List<[DainaClassMethod<[DainaExpression]>]>] classMethods = \[List<[DainaClassMethod<[DainaExpression]>]>]:empty;
         .ifAnonymousClassObject = *([[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->] get)  {
            \get parents constructor classMethods;
         };
         \[Loops]:until *([->] stop) {
            \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
               [DainaType] parent = \[DainaType]:root;
               \parent:parse parser;
               \parents:append parent;
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) (parser:gotoNextToken) stop;
            } *{
               \parser:addError (\[Error]:expectingParentTypeForAnonymousClassObject (\parser:position));
               \stop;
            }
         };
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:squareBracketClose)) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketOpen)) *{
               \parser:gotoNextToken;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                     [DainaExpression] constructorStatement = \[DainaExpression]:base;
                     \constructorStatement:parse parser;
                     \constructor:append constructorStatement;
                  } *{};
                  \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:semicolon)) (parser:gotoNextToken) stop;
               };
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaClassMethod<[DainaExpression]>]:isFirstToken (\parser:token)) *{
                     [DainaClassMethod<[DainaExpression]>] classMethod = \[DainaClassMethod<[DainaExpression]>]:base ([DainaExpression]:base) (*([Parser] parser, [DainaExpression] e){\e:parse parser}) ([DainaExpression]:isFirstToken);
                     \classMethod:parse parser;
                     \classMethods:append classMethod;
                  } stop;
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketClose)) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForAnonymousClassBody (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingAnonymousClassBody (\parser:position));
            };
         } *{
            \parser:addError (\[Error]:expectingClosingSquareBracketAfterAnonymousClassHeader (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Boolean]:and (\[DainaType]:isFirstToken token1) (\[Boolean]:not (\[Token]:equals token2 (\[Token]:colon)))) *{
         [DainaType] type = \[DainaType]:root;
         \type:parse parser;
         \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] expr = \[DainaExpression]:base;
               \expr:parse parser;
               \:copy expr;
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForCastExpression (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingExpressionToBeCast (\parser:position));
            };
         } *{
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
                  [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
                  \identifier:parse parser;
                  .ifTypeMethod = *([[DainaType][DainaGeneralIdentifier]->] get) {\get type identifier};
               } *{
                  \parser:addError (\[Error]:expectingIdentifierForTypeMethod (\parser:position));
               };
            } *{
               \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
                  [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
                  \identifier:parse parser;
                  [DainaObjectDeclaration] localDeclaration = \[DainaObjectDeclaration]:as type identifier;
                  \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
                     \parser:gotoNextToken;
                     \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                        [DainaExpression] expr = \[DainaExpression]:base;
                        \expr:parse parser;
                        .ifLocalObjectAssignment = *([[DainaObjectDeclaration][DainaExpression]->] get) {\get localDeclaration expr};
                     } *{
                        \parser:addError (\[Error]:expectingExpressionToAssignLocalDeclaration (\parser:position));  
                     };
                  } *{
                     \parser:addError (\[Error]:expectingEqualsToAssignLocalDeclaration (\parser:position));   
                  };
               } *{
                  \parser:addError (\[Error]:unexpectedTokenAfterType (\parser:position));
               };
            };
         };
      } *{};

      \[O]:ifElse (\[Token]:equals token1 (\[Token]:colon)) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
            \identifier:parse parser;
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                  [DainaExpression] expr = \[DainaExpression]:base;
                  \expr:parse parser;
                  .ifInstanceMethodAssignment = *([[DainaGeneralIdentifier][DainaExpression]->] get) {\get identifier expr};
               } *{
                  \parser:addError (\[Error]:expectingExpressionToAssignInstanceMethod (\parser:position)); 
               };
            } *{
               .ifInternalInstanceMethod = *([[Integer][DainaGeneralIdentifier]->] get) {\get (\[Integer]:as ##0##) identifier};
            };
         } *{
            \parser:addError (\[Error]:expectingInstanceMethodIdentifier (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:fullStop)) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
            \identifier:parse parser;
            \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
               \parser:gotoNextToken;
               \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
                  [DainaExpression] expr = \[DainaExpression]:base;
                  \expr:parse parser;
                  .ifInstanceObjectAssignment = *([[DainaGeneralIdentifier][DainaExpression]->] get) {\get identifier expr};
               } *{
                  \parser:addError (\[Error]:expectingExpressionToAssignInstanceObject (\parser:position)); 
               };
            } *{
               .ifInternalInstanceObject = *([[DainaGeneralIdentifier]->] get) {\get identifier};
            };
         } *{
            \parser:addError (\[Error]:expectingInstanceObjectIdentifier (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Token]:isParentIdentifier token1) *{
         [Integer] parentNum = \token1:secondId;
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
            [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
            \identifier:parse parser;
            .ifInternalInstanceMethod = *([[Integer][DainaGeneralIdentifier]->] get) {\get parentNum identifier};
         } *{
            \parser:addError (\[Error]:expectingInstanceObjectIdentifier (\parser:position));
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:backslash)) *{
         [->[List<[DainaExpression]>]] parseParameterList = *->[List<[DainaExpression]>] {
            [List<[DainaExpression]>] paramList = \[List<[DainaExpression]>]:empty;
            \[Loops]:while (*->(\[DainaExpression]:isFirstToken (\parser:token))) *{
               [DainaExpression] expr = \[DainaExpression]:base;
               \expr:parse parser;
               \paramList:append expr;
            };
         } -> paramList;
         \parser:gotoNextToken;
         \[O]:ifElse (\[Token]:equals (\parser:peekAtNextToken) (\[Token]:tilde)) *{
            [Token] idToken = (\parser:token);
            [Variable<[Maybe<[Integer]>]>] parentNum = \[Variable<[Maybe<[Integer]>]>]:as (\[Maybe<[Integer]>]:nothing);
            \[O]:ifElse (\[Token]:isParentIdentifier idToken) *{
               \parentNum:set (\[Maybe<[Integer]>]:as (\idToken:secondId));
            } *{
               \[O]:ifElse (\[Token]:equals idToken (\[Token]:colon)) *{
                  \parentNum:set (\[Maybe<[Integer]>]:as (\[Integer]:as ##0##));
               } *{
                  \parser:addError (\[Error]:unexpectedTokenBeforeTilde (\parser:position));
               };
            };
            [Maybe<[Integer]>] m = \parentNum:get;
            \m:isOrElse *([Integer] parentNumber) {
               \parser:gotoNextToken;
               \parser:gotoNextToken;
               [Boolean] isPointerConstructor = (\[Token]:equals (\parser:token) (\[Token]:arrowBracketClose));
               [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
               \[O]:ifElse isPointerConstructor (parser:gotoNextToken) *{
                  \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
                     \identifier:parse parser;
                  } *{
                     \parser:addError (\[Error]:expectingConstructorIdentifier (\parser:position));   
                  };
               };
               [List<[DainaExpression]>] paramList = \parseParameterList;
               .ifConstructorInvocation = *([[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->] get) {\get parentNumber identifier isPointerConstructor paramList};
            } *{};
         } *{
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] methodExpr = \[DainaExpression]:base;
               \methodExpr:parse parser;
               [List<[DainaExpression]>] paramList = \parseParameterList;
               .ifInvocation = *([[DainaExpression][List<[DainaExpression]>]->] get) {\get methodExpr paramList};
            } *{
               \parser:addError (\[Error]:expectingMethodToInvoke (\parser:position)); 
            };
         };
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:asteriskArrow)) *{
         \parser:gotoNextToken;
         \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
            [DainaExpression] expr = \[DainaExpression]:base;
            \expr:parse parser;
            .ifProxyObject = *([[DainaExpression]->] get) {\get expr};
         } *{
            \parser:addError (\[Error]:expectingProxyObject (\parser:position)); 
         };
      } *{};
      \[O]:ifElse (\[DainaCompilerInjection]:isFirstToken token1) *{
         [DainaCompilerInjection] inj = \[DainaCompilerInjection]:base;
         \inj:parse parser;
         .ifCompilerInjection = *([[DainaCompilerInjection]->] get) {\get inj};
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:roundBracketOpen)) *{
         \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] expr = \[DainaExpression]:base;
               \expr:parse parser;
               \:copy expr;
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
                  \parser:gotoNextToken;
               } *{
                  \parser:addError (\[Error]:expectingClosingBracketForExpression (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingExpression (\parser:position));
            };
      } *{};
      \[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken token1) *{
         [DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
         \identifier:parse parser;
         .ifLocalObject = *([[DainaGeneralIdentifier]->] get) {\get identifier};
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:caret)) *{
         \parser:gotoNextToken;
         .ifSelfReference = *([->] get) {\get};
      } *{};
      \[O]:ifElse (\[Token]:equals token1 (\[Token]:asteriskCaret)) *{
         \parser:gotoNextToken;
         .ifMethodSelfReference = *([->] get) {\get};
      } *{};

      @@\[O]:ifElse (\parser:hasErrors) *{} *{
         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:exclamationMark) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               [DainaExpression] left = \[DainaExpression]:base;
               \:copyTo left;
               [DainaExpression] right = \[DainaExpression]:base;
               \right:parse parser;
               \:toBase;
               .ifWithPrologueStatement = *([[DainaExpression][DainaExpression]->] get) {\get left right};
            } *{
               \parser:addError (\[Error]:expectingPrologueStatement (\parser:position));
            };
         } *{};
      };@@
   }
}




[DainaClass :[DainaASTComponent]] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaDependancyStructure,
         DainaExpression,
         Variable,
         DainaClassIdentifier,
         DainaGenericDeclarationList,
         DainaType,
         DainaObjectDeclaration,
         DainaClassMethod,
         DainaCompilerInjection,
         DainaASTComponent,

         Debug
      )
   [Variable<[Boolean]>] isEntryPointClass
   [DainaDependancyStructure] dependancyStructure
   [DainaExpression] entryPointMethod
   [DainaClassIdentifier] className
   [DainaGenericDeclarationList] genericDeclarationList
   [List<[DainaType]>] inheritedParentTypes
   [List<[DainaObjectDeclaration]>] instanceObjects
   [List<[DainaClassMethod<[DainaExpression]>]>] classMethods
   [List<[DainaCompilerInjection]>] compilerInjections
{
   :: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
      [List<[DainaClass]>] classes = \[List<[DainaClass]>]:empty;
      \[Loops]:until *([->] stop) {
         \[O]:ifElse (\[DainaClass]:isFirstToken (\parser:token)) *{
            [DainaClass] class = \[DainaClass]:base;
            \class:parse parser;
            \classes:append class;
            @\[O]:ifElse (\parser:hasErrors) stop *{};
         } *{  
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:EOF) *{} *{
               \parser:addError (\[Error]:expectingClassAtTopLevel (\parser:position));
            };
            \stop;
         };
      };

      @@\[Loops]:while (*->[Boolean]{[Token] token = \parser:token;}->\[Boolean]:not (\[Token]:equals token (\[Token]:EOF))) *{
         [Token] token = \parser:token;
         \[Debug]:log (\token:asDebugString);
         \[Debug]:log (\[String]:as ##\n##);
         \parser:gotoNextToken;
      }@@
   } -> classes

   ++ isEntryPointOrRegularClass *([[DainaDependancyStructure][DainaExpression]->] getEntryPoint, [[DainaClassIdentifier][List<[DainaType]>][List<[DainaObjectDeclaration]>][List<[DainaClassMethod<[DainaExpression]>]>][List<[DainaCompilerInjection]>]->] getRegularClass) {
      \[O]:ifElse (\.isEntryPointClass:get) *{
         \getEntryPoint .dependancyStructure .entryPointMethod;
      } *{
         \getRegularClass .className .inheritedParentTypes .instanceObjects .classMethods .compilerInjections;
      };
   }

   :: isFirstToken *([Token] token) -> [Boolean] {
   } -> (\[Token]:equals token \[Token]:squareBracketOpen)

   ~ base *{
      \$~base;
      .isEntryPointClass = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      .dependancyStructure = \[DainaDependancyStructure]:base;
      .entryPointMethod = \[DainaExpression]:base;
      .className = \[DainaClassIdentifier]:base;
      .genericDeclarationList = \[DainaGenericDeclarationList]:base;
      .inheritedParentTypes = \[List<[DainaType]>]:empty;
      .instanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
      .classMethods = \[List<[DainaClassMethod<[DainaExpression]>]>]:empty;
      .compilerInjections = \[List<[DainaCompilerInjection]>]:empty;
   }

   |++ parse *([Parser] parser) {
      \$parse parser;
      \parser:gotoNextToken;
      \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
         \.isEntryPointClass:set (\[Boolean]:true);
         \parser:gotoNextToken;
         \.dependancyStructure:parse parser;
         \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
            \parser:gotoNextToken;
            \[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
               \.entryPointMethod:parse parser;
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
                  \parser:gotoNextToken;
               } *{  
                  \parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
               };
            } *{
               \parser:addError (\[Error]:expectingEntryPointMethod (\parser:position));  
            };
         } *{
            \parser:addError (\[Error]:expectingBodyOfClass (\parser:position)); 
         };
      } *{  
         \[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
            \.className:parse parser;
            \.genericDeclarationList:parse parser;
            \[Loops]:until *([->] stop) {
               \[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
                  \parser:gotoNextToken;
                  \[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
                     [DainaType] parentType = \[DainaType]:root;
                     \parentType:parse parser;
                     \.inheritedParentTypes:append parentType;
                  } *{  
                     \parser:addError (\[Error]:expectingParentType (\parser:position));
                     \stop;
                  };
               } stop;
            };
            \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
               \parser:gotoNextToken;
               \.dependancyStructure:parse parser;
               \[Loops]:until *([->] stop) {
                  \[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
                     [DainaObjectDeclaration] instanceObject = \[DainaObjectDeclaration]:base;
                     \instanceObject:parse parser;
                     \.instanceObjects:append instanceObject;
                  } stop;
               };
               \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
                  \parser:gotoNextToken;
                  \[Loops]:until *([->] stop) {
                     \[O]:ifElse (\[DainaClassMethod<[DainaExpression]>]:isFirstToken (\parser:token)) *{
                        [DainaClassMethod<[DainaExpression]>] classMethod = \[DainaClassMethod<[DainaExpression]>]:base ([DainaExpression]:base) (*([Parser] parser, [DainaExpression] e){\e:parse parser}) ([DainaExpression]:isFirstToken);
                        \classMethod:parse parser;
                        \classMethod:isInstanceTypeOrConstructor *{} *{} *{
                           [DainaType] classType = \[DainaType]:root;
                           \classType:setAsClassName .className;
                           [DainaExpression] methodExpression = \classMethod:methodExpression;
                           \methodExpression:setOutputType classType;
                        };
                        \.classMethods:append classMethod;
                     } *{
                        \[O]:ifElse (\[DainaCompilerInjection]:isFirstToken (\parser:token)) *{
                           [DainaCompilerInjection] compilerInjection = \[DainaCompilerInjection]:base;
                           \compilerInjection:parse parser;
                           \.compilerInjections:append compilerInjection;
                        } stop;
                     };
                  };
                  \[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
                     \parser:gotoNextToken;
                  } *{  
                     \parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
                  };
               } *{
                  \parser:addError (\[Error]:expectingBodyOfClass (\parser:position));
               };
            } *{  
               \parser:addError (\[Error]:expectingClosingSquareBracketAfterClassHeader (\parser:position));
            };
         } *{
            \parser:addError (\[Error]:expectingClassName (\parser:position));   
         }; 
      };
   }
}






[DLangSynthesizer] (
         Object, 
         Parser, 
         List,
         Loops,
         Token,
         Boolean,
         Maybe,
         String,
         Error, M, O,
         DainaDependancyStructure,
         DainaExpression,
         Variable,
         DainaClassIdentifier,
         DainaGenericDeclarationList,
         DainaType,
         DainaObjectDeclaration,
         DainaClassMethod,
         DainaCompilerInjection,
         DainaClass,
         Integer,
         DainaGeneralIdentifier,
         Mapping,
         Debug
      )
   [[Data]->] output
   [Integer] tab
   [Boolean] blockOutput
   [Mapping<[String][DainaClass]>] mappedClasses
   [Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>] mappedClassMethods
   [DainaClassIdentifier] selfClassName
   [List<[DainaObjectDeclaration]>] selfInstanceObjects
   [Integer] temporaryNumber
   [DainaType] synthesizedExpressionType
   [Mapping<[String][DainaType]>] localObjectScope
{
   ~ to *([[Data]->] output) {
      .tab = \[Integer]:as ##0##;
      .output = output;
      .mappedClasses = \[Mapping<[String][DainaClass]>]:empty;
      .mappedClassMethods = \[Mapping<[String][Mapping<[String][DainaClassMethod<[DainaExpression]>]>]>]:empty;
      .temporaryNumber = \[Integer]:as ##0##;
      .selfClassName = \[DainaClassIdentifier]:base;
      .synthesizedExpressionType = \[DainaType]:root;
      .selfInstanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
      .localObjectScope = \[Mapping<[String][DainaType]>]:empty;
      .blockOutput = \[Boolean]:false;
   }

   - outputNextTemporaryVariableName *{
      .temporaryNumber = \.temporaryNumber:adding (\[Integer]:as ##1##);
      \:output (\[String]:as ##temp##);
      \:output (\[String]:stringFormatOf .temporaryNumber);
   }

   - output *([String] string) {
      \[O]:ifElse .blockOutput *{} *{
         \.output \string:ascii;
      };
   }

   - outputTabbed *([String] string) {
      \[O]:ifElse .blockOutput *{} *{
         \[Loops]:iterate ([:[Sequence<[Natural]>]] { 
            |++ length *->(\[Natural]:magnitudeOf .tab)
            |++ atIndex *(i)->\[Maybe<[?]>]:as i
         }) *{
            [String] tab = (\[String]:as ##   ##);
            \.output \tab:ascii;
         };
         \.output \string:ascii;
      };
   }

   - incrementTab *{
      .tab = \.tab:adding (\[Integer]:as ##1##);
   }

   - decrementTab *{
      .tab = \.tab:subtracting (\[Integer]:as ##1##);
   }

   - iterateUnoverridenInstanceMethods *([DainaClass] class, [[Integer][DainaClassMethod<[DainaExpression]>]->] get) {
      \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
      } *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {{
         [Variable<[Integer]>] varParentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
         \[Loops]:iterate inheritedParentTypes *([] _, [DainaType] parentType) {
            [Integer] parentNumber = \varParentNumber:get;
            \varParentNumber:set (\parentNumber:adding (\[Integer]:as ##1##));
            \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
               [String] parentID = (\parentTypeIdentifier:content);
               \.mappedClasses:retriveMappedValueWithKey parentID *([DainaClass] parentClass) {
                  \:iterateUnoverridenInstanceMethods parentClass *([Integer] i, [DainaClassMethod<[DainaExpression]>]c) {
                     \getIfNotOverriden parentNumber c;
                  };
                  \parentClass:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
                  } *([DainaClassIdentifier] a1, [List<[DainaType]>] a2, [List<[DainaObjectDeclaration]>] a3, [List<[DainaClassMethod<[DainaExpression]>]>] parentClassMethods, [List<[DainaCompilerInjection]>] a5) {
                     \[Loops]:iterate parentClassMethods *([] _, [DainaClassMethod<[DainaExpression]>] parentClassMethod) {
                        \getIfNotOverriden parentNumber parentClassMethod;
                     };
                  };
               };    
            };
         };

      } !{
            [[Integer][DainaClassMethod<[DainaExpression]>]->] getIfNotOverriden = *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] parentMethod) {
               [DainaGeneralIdentifier] parentMethodIdentifier = \parentMethod:identifier;
               \.mappedClassMethods:retriveMappedValueWithKey (\className:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] ownClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] ifOverriden = \ownClassMethods:maybeRetriveMappedValueWithKey (\parentMethodIdentifier:content);
                  \ifOverriden:isOrElse *{} *{
                     \get parentNumber parentMethod;
                  };
               };
            };
         }};
   }

   - iterateUnoverridenInstanceMethodsAnon *([List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaType]>] inheritedParentTypes, [[Integer][DainaClassMethod<[DainaExpression]>]->] get) {{
      
         [Variable<[Integer]>] varParentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            [Integer] parentNumber = \varParentNumber:get;
            \varParentNumber:set (\parentNumber:adding (\[Integer]:as ##1##));
            \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
               [String] parentID = (\parentTypeIdentifier:content);
               \.mappedClasses:retriveMappedValueWithKey parentID *([DainaClass] parentClass) {
                  \:iterateUnoverridenInstanceMethods parentClass *([Integer] i, [DainaClassMethod<[DainaExpression]>]c) {
                     \getIfNotOverriden parentNumber c;
                  };
                  \parentClass:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
                  } *([DainaClassIdentifier] a1, [List<[DainaType]>] a2, [List<[DainaObjectDeclaration]>] a3, [List<[DainaClassMethod<[DainaExpression]>]>] parentClassMethods, [List<[DainaCompilerInjection]>] a5) {
                     \parentClassMethods:iterate *([DainaClassMethod<[DainaExpression]>] parentClassMethod) {
                        \getIfNotOverriden parentNumber parentClassMethod;
                     };
                  };
               };    
            };
         };

      
   }  !{
            [Mapping<[String][DainaClassMethod<[DainaExpression]>]>] ownClassMethods = \[Mapping<[String][DainaClassMethod<[DainaExpression]>]>]:empty;
            \classMethods:iterate *([DainaClassMethod<[DainaExpression]>] classMethod) {
               [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
               \ownClassMethods:mapKeyToValue (\classMethodIdentifier:content) classMethod;
            };
            [[Integer][DainaClassMethod<[DainaExpression]>]->] getIfNotOverriden = *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] parentMethod) {
               [DainaGeneralIdentifier] parentMethodIdentifier = \parentMethod:identifier;
               [Maybe<[DainaClassMethod<[DainaExpression]>]>] ifOverriden = \ownClassMethods:maybeRetriveMappedValueWithKey (\parentMethodIdentifier:content);
               \ifOverriden:isOrElse *{} *{
                  \get parentNumber parentMethod;
               };
            };
         }  }


   

   ++ synthesizeClasses *([List<[DainaClass]>] classes) {
      \classes:iterate *([DainaClass] class) {
         \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
         } *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
            \.mappedClasses:mapKeyToValue (\className:content) class;
            [Mapping<[String][DainaClassMethod<[DainaExpression]>]>] classMethodsMapping = \[Mapping<[String][DainaClassMethod<[DainaExpression]>]>]:empty;
            \classMethods:iterate *([DainaClassMethod<[DainaExpression]>] classMethod) {
               [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
               \classMethodsMapping:mapKeyToValue (\classMethodIdentifier:content) classMethod;
            };
            \.mappedClassMethods:mapKeyToValue (\className:content) classMethodsMapping;
         }; 
      };
      \:output (\[String]:as ##/* *** HEADER *** */\n##);
      \:output (\[String]:as ##interface OBJECT {}\n##);
      \:output (\[String]:as ##class WRAP(E) : OBJECT { E it; this(E v) {this.it = v;} }\n##);
      \:output (\[String]:as ##interface LAMBDA {\n   OBJECT method(OBJECT caller, OBJECT[] parameters);\n}\n\n##);
      \classes:iterate :synthesizeClass;
   }

   - synthesizeClass *([DainaClass] class) {
      \class:isEntryPointOrRegularClass *([DainaDependancyStructure] dependancyStructure, [DainaExpression] entryPointMethod) {
         \:output (\[String]:as ##/* *** ENTRY POINT CLASS *** */\n##);
         \:output (\[String]:as ##void main() { ENTRY_POINT_CLASS.entryPointMethod(null, []); }\n##); 
         \:output (\[String]:as ##class ENTRY_POINT_CLASS {\n##);
         \:output (\[String]:as ##   static OBJECT entryPointMethod(OBJECT caller, OBJECT[] parameters) {\n##); \:incrementTab; \:incrementTab;
         \:synthesizeMethodBodyContent entryPointMethod; 
         \:decrementTab; \:decrementTab; \:output (\[String]:as ##   }\n}\n\n##);
      } *([DainaClassIdentifier] className, [List<[DainaType]>] inheritedParentTypes, [List<[DainaObjectDeclaration]>] instanceObjects, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods, [List<[DainaCompilerInjection]>] compilerInjections) {
         .selfClassName = className;
         .selfInstanceObjects = instanceObjects;
         \:output (\[String]:as ##/* *** CLASS: ##);
         \:output (\className:content);
         \:output (\[String]:as ## *** */\n##);
         \:output (\[String]:as ##interface CLASSTYPE_##);
         \:output (\className:content);
         \:output (\[String]:as ## : OBJECT, LAMBDA##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            \:output (\[String]:as ##, ##);
            \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
               \:output (\[String]:as ##CLASSTYPE_##);
               \:output (\parentTypeIdentifier:content);
            };
         };
         \:output (\[String]:as ## {\n##); \:incrementTab;
         \classMethods:iterate :synthesizeClassMethodInterface;
         \:decrementTab; \:output (\[String]:as ##}\n##);
         \:output (\[String]:as ##class CLASSIMPL_##);
         \:output (\className:content);
         \:output (\[String]:as ## : CLASSTYPE_##);
         \:output (\className:content);
         \:output (\[String]:as ## {\n##); \:incrementTab;
         \compilerInjections:iterate *([DainaCompilerInjection] compilerInjection) {
            [String] dlang = \[String]:as ##dlang##;
            \[O]:ifElse (\dlang:isEqualTo (\compilerInjection:identifierString)) *{
               \:output (\[String]:as ##/* dlang injection start */##);
               \:output (\compilerInjection:dataSegment);
               \:output (\[String]:as ##/* dlang injection end */\n##);
            } *{
               \:outputTabbed (\[String]:as ##ERROR UNKNOWN INJECTION!!!\n##);
            };
         };
         \:outputTabbed (\[String]:as ##override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n##);
         [Variable<[Integer]>] parentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            [Integer] curr = \parentNumber:get;
            \:synthesizeParentObjectDeclaration curr parentType \[Boolean]:false;
            \parentNumber:set (\curr:adding (\[Integer]:as ##1##));
         };
         \:outputTabbed (\[String]:as ##this() {\n##); \:incrementTab;
         \parentNumber:set (\[Integer]:as ##1##);
         \inheritedParentTypes:iterate *([DainaType] parentType) {
            [Integer] curr = \parentNumber:get;
            \:synthesizeParentObjectAssignment curr parentType;
            \parentNumber:set (\curr:adding (\[Integer]:as ##1##));
         };
         \:decrementTab; \:outputTabbed (\[String]:as ##}\n##);
         \instanceObjects:iterate :synthesizeInstanceObjectDeclaration;
         \:iterateUnoverridenInstanceMethods class (:synthesizeParentUnoverridenMethod);
         \classMethods:iterate *([List<[DainaClassMethod<[DainaExpression]>]>] classMethod) {
            \:synthesizeClassMethodImplementation classMethod (\[Boolean]:false);
         };
         \:decrementTab; \:output (\[String]:as ##}\n\n##);
      };
   }

   - synthesizeInstanceObjectDeclaration *([DainaObjectDeclaration] instanceObject) {
      \:outputTabbed (\[String]:as ##private OBJECT IOBJECT_##);
      [DainaGeneralIdentifier] instanceObjectIdentifier = \instanceObject:identifier;
      \:output (\instanceObjectIdentifier:content);
      \:output (\[String]:as ## = null;\n##);
   }

   - synthesizeParentObjectDeclaration *([Integer] parentNumber, [DainaType] parentType, [Boolean] includeAssignment) {
      \:outputTabbed (\[String]:as ####);
      \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
         \:output (\[String]:as ##CLASSTYPE_##);
         \:output (\parentTypeIdentifier:content);
      };
      \:output (\[String]:as ## ##);
      \:output (\[String]:as ##PARENT_##);
      \:output (\[String]:stringFormatOf parentNumber);
      \includeAssignment:ifOrElse *{
         \:output (\[String]:as ## = new ##);
         \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
            \:output (\[String]:as ##CLASSIMPL_##);
            \:output (\parentTypeIdentifier:content);
         };
         \:output (\[String]:as ##();\n##);
      } *{
         \:output (\[String]:as ##;\n##);
      };
      \:outputTabbed (\[String]:as ##void PARENT_##);
      \:output (\[String]:stringFormatOf parentNumber);
      \:output (\[String]:as ##_SET(OBJECT parent) { ##);
      \:output (\[String]:as ##PARENT_##);
      \:output (\[String]:stringFormatOf parentNumber);
      \:output (\[String]:as ## = cast(##);
      \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
         \:output (\[String]:as ##CLASSTYPE_##);
         \:output (\parentTypeIdentifier:content);
      };
      \:output (\[String]:as ##)parent; }\n##);
   }

   - synthesizeParentObjectAssignment *([Integer] parentNumber, [DainaType] parentType) {
      \:outputTabbed (\[String]:as ##PARENT_##);
      \:output (\[String]:stringFormatOf parentNumber);
      \:output (\[String]:as ## = new ##);
      \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\parentTypeIdentifier:content);
      };
      \:output (\[String]:as ##();\n##);
   }

   - synthesizeParentUnoverridenMethod *([Integer] parentNumber, [DainaClassMethod<[DainaExpression]>] unoverridenMethod) {
      \unoverridenMethod:isInstanceTypeOrConstructor *{
         [DainaGeneralIdentifier] unoverridenMethodIdentifier = \unoverridenMethod:identifier;
         \:outputTabbed (\[String]:as ##override OBJECT IMETHOD_##);
         \:output (\unoverridenMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters) { return PARENT_##);
         \:output (\[String]:stringFormatOf parentNumber);
         \:output (\[String]:as ##.IMETHOD_##);
         \:output (\unoverridenMethodIdentifier:content);
         \:output (\[String]:as ##(caller, parameters); }\n##);
      } *{} *{};
   }

   - synthesizeClassMethodInterface *([DainaClassMethod<[DainaExpression]>] classMethod) {
      [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
      \classMethod:isInstanceTypeOrConstructor *{
         \:outputTabbed (\[String]:as ##OBJECT IMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters);\n##);
      } *{
      } *{
         \:outputTabbed (\[String]:as ##OBJECT CMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters);\n##);
      };
   }

   - synthesizeClassMethodImplementation *([DainaClassMethod<[DainaExpression]>] classMethod, [Boolean] anonymousClass) {
      [DainaGeneralIdentifier] classMethodIdentifier = \classMethod:identifier;
      \[O]:ifElse (\classMethod:isUnimplementedMethod) *{
         \:outputTabbed (\[String]:as ##private LAMBDA ASSIGNIMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ## = null;\n##);
      } *{};
      \classMethod:isInstanceTypeOrConstructor *{
         \anonymousClass:ifOrElse *{
            [Boolean] overriding = \classMethod:isOverridingMethod;
            \overriding:ifOrElse *{
               \:outputTabbed (\[String]:as ##override OBJECT IMETHOD_##);
            } *{
               \:outputTabbed (\[String]:as ##OBJECT IMETHOD_##);
            };
         } *{
            \:outputTabbed (\[String]:as ##override OBJECT IMETHOD_##);
         };
      } *{
         \:outputTabbed (\[String]:as ##static OBJECT TMETHOD_##);
      } *{
         \:outputTabbed (\[String]:as ##static OBJECT TMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters) { ##);
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\.selfClassName:content);
         \:output (\[String]:as ## newInstance = new ##);
         \:output (\[String]:as ##CLASSIMPL_##);
         \:output (\.selfClassName:content);
         \:output (\[String]:as ##(); return newInstance.CMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##(newInstance, parameters); }\n##);
         \:outputTabbed (\[String]:as ##override OBJECT CMETHOD_##);
      };
      \:output (\classMethodIdentifier:content);
      \:output (\[String]:as ##(OBJECT caller, OBJECT[] parameters)##);
      \:output (\[String]:as ## {\n##); \:incrementTab;
      \:outputTabbed (\[String]:as ##CLASSTYPE_##);
      \:output (\.selfClassName:content);
      \:output (\[String]:as ## self = ##);
      \:output (\[String]:as ##cast(##);
      \:output (\[String]:as ##CLASSTYPE_##);
      \:output (\.selfClassName:content);
      \:output (\[String]:as ##)caller##);
      \:output (\[String]:as ##;\n##);
      \[O]:ifElse (\classMethod:isUnimplementedMethod) *{
         \:outputTabbed (\[String]:as ##return ASSIGNIMETHOD_##);
         \:output (\classMethodIdentifier:content);
         \:output (\[String]:as ##.method(caller, parameters);\n##);
      } *{
         \:synthesizeMethodBodyContent (\classMethod:methodExpression);
      };
      \:decrementTab; \:outputTabbed (\[String]:as ##}\n##);
   }


   - pushScope *([List<[DainaObjectDeclaration]>] parameters) {
      [Variable<[Integer]>] paramNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##0##);
      [Integer] one = \[Integer]:as ##1##;
      \parameters:iterate *([DainaObjectDeclaration] parameter) {
         \:addLocalObjectToScope parameter;
         [DainaGeneralIdentifier] id = \parameter:identifier;
         \:outputTabbed (\[String]:as ##OBJECT LOBJECT_##);
         \:output (\id:content);
         \:output (\[String]:as ## = parameters.length > ##);
         \:output (\[String]:stringFormatOf (\paramNumber:get));
         \:output (\[String]:as ## ? parameters[##);
         \:output (\[String]:stringFormatOf (\paramNumber:get));
         \:output (\[String]:as ##] : null;\n##);
         \paramNumber:set (\one:adding (\paramNumber:get));
      };
   }

   - popScope *{
      
   }

   - pushPrologueScope *{

   }

   - pushPrelogueScopeAfterPrologue *{

   }

   - popPrelogueAndPrologueScope *{

   }

   - addLocalObjectToScope *([DainaObjectDeclaration] localObject) {
      [DainaGeneralIdentifier] id = \localObject:identifier;
      \.localObjectScope:mapKeyToValue (\id:content) (\localObject:type);
   }

   - getLocalObjectType *([DainaGeneralIdentifier] localObjectIdentifier) -> [DainaType] {
      [Variable<[DainaType]>] ret = \[Variable<[DainaType]>]:as (\[DainaType]:root);
      \.localObjectScope:retriveMappedValueWithKey (\localObjectIdentifier:content) (ret:set);
   } -> \ret:get


   - synthesizeMethodBodyContent *([DainaExpression] methodExpression) {
      \[O]:selectOrDefault *([->] select) {
         \methodExpression:ifMethodExpression *([List<[DainaObjectDeclaration]>] inputs, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
            \select;
            \:pushScope inputs; 
            \:synthesizeStatement body (\[Boolean]:true);
            \output:isOrElse *{} *{
               \:outputTabbed (\[String]:as ##return caller;\n##);
            };
            \output:isOrElse *([DainaExpression] outputExpression) {
               \:outputTabbed (\[String]:as ##return ##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  outputExpression;
               \:output (\[String]:as ##;\n##);
            } *{};
            \:popScope;
         };
      } *{
         \:outputTabbed (\[String]:as ##return (cast(LAMBDA)##);
         \:synthesizeInPlaceExpression (\[Boolean]:false)  methodExpression;
         \:output (\[String]:as ##).method(caller, parameters);\n##);
      };
   }

   - synthesizeStatement *([DainaExpression] statement, [Boolean] baseStatement) {
      \[O]:selectOrDefault *([->] select) {
         \statement:ifStatementGroup *([List<[DainaExpression]>] statements) {
            \select;
            \[O]:ifElse baseStatement *{} *{
               \:pushScope (\[List<[DainaObjectDeclaration]>]:empty); 
               \:outputTabbed (\[String]:as ##{\n##);
               \:incrementTab;
            };
            \statements:iterate *([DainaExpression] subStatement) {
               \:synthesizeStatement subStatement (\[Boolean]:false);
            };
            \[O]:ifElse baseStatement *{} *{
               \:decrementTab;
               \:outputTabbed (\[String]:as ##}\n##);
               \:popScope;
            };
         };
         \statement:ifWithPrologueStatement *([DainaExpression] prelogueStatement, [DainaExpression] prologueStatement) {
            \select;
            \:pushPrologueScope;
            \:synthesizeStatement prologueStatement (\[Boolean]:true);
            \:pushPrelogueScopeAfterPrologue;
            \:synthesizeStatement prelogueStatement (baseStatement);
            \:popPrelogueAndPrologueScope;
         };
         \statement:ifLocalObjectAssignment *([DainaObjectDeclaration] declaration, [DainaExpression] assginedExpression) {
            \select;
            \[O]:selectOrDefault *([->] _select) {
               \assginedExpression:ifCompilerInjection *([DainaCompilerInjection] compilerInjection) {
                  \_select;
                  [String] dlang = \[String]:as ##dlang##;
                  \[O]:ifElse (\dlang:isEqualTo (\compilerInjection:identifierString)) *{
                     \:output (\[String]:as ##/* dlang injection start */##);
                     \:output (\compilerInjection:dataSegment);
                     \:output (\[String]:as ##/* dlang injection end */\n##);
                  } *{
                     \:outputTabbed (\[String]:as ##ERROR UNKNOWN INJECTION!!!\n##);
                  };
               };
            } *{
               [String] nothing = \[String]:as ####;
               [DainaGeneralIdentifier] identifier = \declaration:identifier;
               \:outputTabbed (\[String]:as ####);
               \[O]:ifElse (\nothing:isEqualTo (\identifier:content)) *{} *{
                  \:addLocalObjectToScope declaration;
                  \:output (\[String]:as ##OBJECT LOBJECT_##);
                  \:output (\identifier:content);
                  \:output (\[String]:as ## = ##);
               };
               \:synthesizeInPlaceExpression (\[Boolean]:false)  assginedExpression;
               \:output (\[String]:as ##;\n##);
            };
         };
         \statement:ifInvocation *([] a, [] b) {
            \select;
            \:outputTabbed (\[String]:as ####);
            \:synthesizeInPlaceExpression (\[Boolean]:false)  statement;
            \:output (\[String]:as ##;\n##);
         };
         \statement:ifInstanceMethodAssignment *([DainaGeneralIdentifier] identifier, [DainaExpression] assignedExpression) {
            \select;
            \:outputTabbed (\[String]:as ##ASSIGNIMETHOD_##);
            \:output (\identifier:content);
            \:output (\[String]:as ## = cast(LAMBDA)##);
            \:synthesizeInPlaceExpression (\[Boolean]:false)  assignedExpression;
            \:output (\[String]:as ##;\n##);
         };
         \statement:ifInstanceObjectAssignment *([DainaGeneralIdentifier] identifier, [DainaExpression] assignedExpression) {
            \select;
            \:outputTabbed (\[String]:as ##IOBJECT_##);
            \:output (\identifier:content);
            \:output (\[String]:as ## = ##);
            \:synthesizeInPlaceExpression (\[Boolean]:false)  assignedExpression;
            \:output (\[String]:as ##;\n##);
         };
         \statement:ifConstructorInvocation *([Integer] parentNumber, [DainaGeneralIdentifier] identifier, [Boolean] isPointerConstructor, [List<[DainaExpression]>] inputs) {
            \select;
            \[O]:ifElse (\parentNumber:isEqualTo (\[Integer]:as ##0##)) *{
               \[O]:ifElse isPointerConstructor *{
                  \:outputTabbed (\[String]:as ##caller = ##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##;\n##);
               } *{
                  \:outputTabbed (\[String]:as ##(cast(##);
                  \:output (\[String]:as ##CLASSIMPL_##);
                  \:output (\.selfClassName:content);
                  \:output (\[String]:as ##)##);
                  \:output (\[String]:as ##self).CMETHOD_##);
                  \:output (\identifier:content);
                  \:output (\[String]:as ##(this##);
                  \:output (\[String]:as ##, [##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##]);\n##);
               };
            } *{
               \:outputTabbed (\[String]:as ##PARENT_##);
               \:output (\[String]:stringFormatOf parentNumber);
               \[O]:ifElse isPointerConstructor *{
                  \:output (\[String]:as ##_SET(##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##);\n##);
               } *{
                  \:output (\[String]:as ##.CMETHOD_##);
                  \:output (\identifier:content);
                  \:output (\[String]:as ##(PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##, [##);
                  \:synthesizeMethodInputs inputs;
                  \:output (\[String]:as ##]);\n##);
               };
            };
         };
      } *{
         \:outputTabbed (\[String]:as ##INTERNAL STATEMENT ERROR!!!\n##);
      };
   }

   - synthesizeMethodInputs *([List<[DainaExpression]>] inputs) {
      [Variable<[String]>] seperator = \[Variable<[String]>]:as (\[String]:as ####);
      \inputs:iterate *([DainaExpression] input) {
         \:output (\seperator:get);
         \:synthesizeInPlaceExpression (\[Boolean]:false)  input;
         \seperator:set (\[String]:as ##, ##);
      };
   }

   - synthesizeInPlaceExpression *([Boolean] usedAsInstantMethod, [DainaExpression] expression) {
      .synthesizedExpressionType = \[DainaType]:root;
      \[O]:selectOrDefault *([->] select) {
         \expression:ifWithPrologueStatement *([DainaExpression] prelogue, [DainaExpression] prologue) {
            \select;
            \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
            \:incrementTab;
            \:synthesizeStatement prologue (\[Boolean]:true);
            \[O]:selectOrDefault *([->] selectInner) {
               \prelogue:ifStatementGroup *([] a) {
                  \selectInner;
                  \:synthesizeStatement prelogue (\[Boolean]:true);
                  \:outputTabbed (\[String]:as ##return caller;\n##);
               };
            } *{
               \:outputTabbed (\[String]:as ##return ##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  prelogue;
               \:output (\[String]:as ##;\n##);
            };
            \:decrementTab;
            \:outputTabbed (\[String]:as ##} }).method(caller, [])##);
         };
         \expression:ifLocalObject *([DainaGeneralIdentifier] identifier) {
            \select;
            [Boolean] isVoidIdentifier = \identifier:isVoidIdentifier;
            \isVoidIdentifier:ifOrElse *{
               \:output (\[String]:as ##new class OBJECT {}##);
            } *{
               \:output (\[String]:as ##LOBJECT_##);
               \:output (\identifier:content);
            };
            .synthesizedExpressionType = \:getLocalObjectType identifier;
         };
         \expression:ifMethodExpression *([List<[DainaObjectDeclaration]>] params, [DainaExpression] body, [Maybe<[DainaExpression]>] output) {
            \select;
            \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
            \:incrementTab;
            \:synthesizeMethodBodyContent expression;
            \:decrementTab;
            \:outputTabbed (\[String]:as ##} })##);
            [DainaType] outputType = .synthesizedExpressionType;
            .synthesizedExpressionType = \[DainaType]:root;
            \.synthesizedExpressionType:setAsMethodWithOutputType (\expression:outputType);
         };
         \expression:ifInstanceMethod *([DainaExpression] instanceExpression, [DainaGeneralIdentifier] identifier) {
            \select;
            [Variable<[DainaType]>] instanceExpressionType = \[Variable<[DainaType]>]:as .synthesizedExpressionType;
            \[O]:ifElse (usedAsInstantMethod) *{
               \:output (\[String]:as ##(cast(##);
               .blockOutput = \[Boolean]:true;
               \:synthesizeInPlaceExpression (\[Boolean]:false)  instanceExpression;
               .blockOutput = \[Boolean]:false;
               \instanceExpressionType:set .synthesizedExpressionType;
               \.synthesizedExpressionType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] instanceExpressionClassName, [List<[DainaType]>] insta) {
                  \:output (\[String]:as ##CLASSTYPE_##);
                  \:output (\instanceExpressionClassName:content);
               };
               \:output (\[String]:as ##)##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  instanceExpression;
               \:output (\[String]:as ##).IMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(caller##);
            } *{
               \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
               \:incrementTab;
               \:outputTabbed (\[String]:as ##OBJECT instance = ##);
               \:synthesizeInPlaceExpression (\[Boolean]:false)  instanceExpression;
               \:output (\[String]:as ##;\n##);
               \:outputTabbed (\[String]:as ##return (cast(##);
               \instanceExpressionType:set .synthesizedExpressionType;
               \.synthesizedExpressionType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] instanceExpressionClassName, [List<[DainaType]>] insta) {
                  \:output (\[String]:as ##CLASSTYPE_##);
                  \:output (\instanceExpressionClassName:content);
               };
               \:output (\[String]:as ##)instance).IMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(instance, parameters);\n##);
               \:decrementTab;
               \:outputTabbed (\[String]:as ##} })##);
            };
            [DainaType] theinstanceExpressionType = \instanceExpressionType:get;
            \theinstanceExpressionType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] instanceExpressionClassName, [List<[DainaType]>] insta) {
               \.mappedClassMethods:retriveMappedValueWithKey (\instanceExpressionClassName:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] instanceExpressionClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] mInvokedMethod = \instanceExpressionClassMethods:maybeRetriveMappedValueWithKey (\identifier:content);
                  \mInvokedMethod:isOrElse *([DainaClassMethod<[DainaExpression]>] invokedMethod) {
                     \[O]:ifElse (\invokedMethod:isUnimplementedMethod) *{
                        .synthesizedExpressionType = \invokedMethod:unimplementedType;
                     } *{
                        [DainaExpression] methodExpression = \invokedMethod:methodExpression;
                        .synthesizedExpressionType = \[DainaType]:root;
                        \.synthesizedExpressionType:setAsMethodWithOutputType (\methodExpression:outputType);
                     };
                  } *{};
               };
            };
         };
         \expression:ifTypeMethod *([DainaType] type, [DainaGeneralIdentifier] identifier) {
            \select;
            \[O]:ifElse (usedAsInstantMethod) *{
               \type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
                  \:output (\[String]:as ##CLASSIMPL_##);
                  \:output (\typeIdentifier:content);
                  \:output (\[String]:as ##.##);
               };
               \:output (\[String]:as ##TMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(caller##);
            } *{
               \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
               \:incrementTab;
               \:outputTabbed (\[String]:as ##return ##);
               \type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
                  \:output (\[String]:as ##CLASSIMPL_##);
                  \:output (\typeIdentifier:content);
                  \:output (\[String]:as ##.##);
               };
               \:output (\[String]:as ##TMETHOD_##);
               \:output (\identifier:content);
               \:output (\[String]:as ##(caller, parameters);\n##);
               \:decrementTab;
               \:outputTabbed (\[String]:as ##} })##);
            };
            \type:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] typeIdentifier, [List<[DainaType]>] genericInstantiation) {
               \.mappedClassMethods:retriveMappedValueWithKey (\typeIdentifier:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] typeExpressionClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] mInvokedMethod = \typeExpressionClassMethods:maybeRetriveMappedValueWithKey (\identifier:content);
                  \mInvokedMethod:isOrElse *([DainaClassMethod<[DainaExpression]>] invokedMethod) {
                     [DainaExpression] methodExpression = \invokedMethod:methodExpression;
                     .synthesizedExpressionType = \[DainaType]:root;
                     \.synthesizedExpressionType:setAsMethodWithOutputType (\methodExpression:outputType);
                  } *{};
               };
            };
         };
         \expression:ifInvocation *([DainaExpression] method, [List<[DainaExpression]>] params) {
            \select;
            [Variable<[Boolean]>] isInstantMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
            \method:ifTypeMethod *([DainaType] a, [DainaGeneralIdentifier] b) {\isInstantMethod:set (\[Boolean]:true)};
            \method:ifInternalInstanceMethod *([Integer] a, [DainaGeneralIdentifier] b) {\isInstantMethod:set (\[Boolean]:true)};
            @\method:ifInstanceMethod *([DainaExpression] a, [DainaGeneralIdentifier] b) {\isInstantMethod:set (\[Boolean]:true)};
            [Variable<[DainaType]>] invokedExpressionType = \[Variable<[DainaType]>]:as .synthesizedExpressionType;
            \[O]:ifElse (\isInstantMethod:get) *{
               \:synthesizeInPlaceExpression (\[Boolean]:true) method;
               \invokedExpressionType:set .synthesizedExpressionType;
               \:output (\[String]:as ##, cast(OBJECT[])[##);
               \:synthesizeMethodInputs params;
               \:output (\[String]:as ##])##);
            } *{
               \:output (\[String]:as ##(cast(LAMBDA)##);
               \:synthesizeInPlaceExpression (\[Boolean]:false) method;
               \invokedExpressionType:set .synthesizedExpressionType;
               \:output (\[String]:as ##).method(caller, cast(OBJECT[])[##);
               \:synthesizeMethodInputs params;
               \:output (\[String]:as ##])##);
            };
            [DainaType] _invokedExpressionType = \invokedExpressionType:get;
            \_invokedExpressionType:ifMethodInputsAndOutput *([] _, [[DainaTypeEnum<['A]>]->['A]] MoutputType) {
               .synthesizedExpressionType = \[DainaType]:as MoutputType;
            };
         };
         \expression:ifProxyObject *([DainaExpression] object) {
            \select;
            \:synthesizeInPlaceExpression (\[Boolean]:false)  object;
         };
         \expression:ifInternalInstanceMethod *([Integer] parentNumber, [DainaGeneralIdentifier] identifier) {
            \select;
            \[O]:ifElse (usedAsInstantMethod) *{
               \[O]:ifElse (\parentNumber:isEqualTo (\[Integer]:as ##0##)) *{
                  \:output (\[String]:as ##self.IMETHOD_##);
               } *{
                  \:output (\[String]:as ##PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##.IMETHOD_##);
               };
               \:output (\identifier:content);
               \:output (\[String]:as ##(self##);
            } *{
               \:output (\[String]:as ##(new class OBJECT, LAMBDA { override OBJECT method(OBJECT caller, OBJECT[] parameters) {\n##);
               \:incrementTab;
               \[O]:ifElse (\parentNumber:isEqualTo (\[Integer]:as ##0##)) *{
                  \:outputTabbed (\[String]:as ##OBJECT instance = self;\n##);
                  \:outputTabbed (\[String]:as ##return self.IMETHOD_##);
               } *{
                  \:outputTabbed (\[String]:as ##OBJECT instance = PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##;\n##);
                  \:outputTabbed (\[String]:as ##return PARENT_##);
                  \:output (\[String]:stringFormatOf parentNumber);
                  \:output (\[String]:as ##.IMETHOD_##);
               };
               \:output (\identifier:content);
               \:output (\[String]:as ##(instance, parameters);\n##);
               \:decrementTab;
               \:outputTabbed (\[String]:as ##} })##);
            };
            \.mappedClassMethods:retriveMappedValueWithKey (\.selfClassName:content) *([Mapping<[String][DainaClassMethod<[DainaExpression]>]>] typeExpressionClassMethods) {
                  [Maybe<[DainaClassMethod<[DainaExpression]>]>] mInvokedMethod = \typeExpressionClassMethods:maybeRetriveMappedValueWithKey (\identifier:content);
                  \mInvokedMethod:isOrElse *([DainaClassMethod<[DainaExpression]>] invokedMethod) {
                     \[O]:ifElse (\invokedMethod:isUnimplementedMethod) *{
                        .synthesizedExpressionType = \invokedMethod:unimplementedType;
                     } *{
                        [DainaExpression] methodExpression = \invokedMethod:methodExpression;
                        .synthesizedExpressionType = \[DainaType]:root;
                        \.synthesizedExpressionType:setAsMethodWithOutputType (\methodExpression:outputType);
                     };
                  } *{};
               };
         };
         \expression:ifInternalInstanceObject *([DainaGeneralIdentifier] instanceObjectIdentifier) {
            \select;
            \:output (\[String]:as ##IOBJECT_##);
            \:output (\instanceObjectIdentifier:content);
            [String] instanceObjectIdentifierString = \instanceObjectIdentifier:content;
            \.selfInstanceObjects:iterate *([DainaObjectDeclaration] decl) {
               [DainaGeneralIdentifier] thisId = \decl:identifier;
               \[O]:ifElse (\instanceObjectIdentifierString:isEqualTo (\thisId:content)) *{
                  .synthesizedExpressionType = \decl:type; 
               } *{};
            };
         };
         \expression:ifSelfReference * {
            \select;
            \:output (\[String]:as ##caller##);
         };
         \expression:ifDataSegment *([String] dataSegmentContent) {
            \select;
            \:output (\[String]:as ##new WRAP!(string)(\"##);
            \:output (dataSegmentContent);
            \:output (\[String]:as ##\")##);
         };
         \expression:ifAnonymousClassObject *([List<[DainaType]>] parents, [List<[DainaExpression]>] constructor, [List<[DainaClassMethod<[DainaExpression]>]>] classMethods) {
            \select;
            [DainaClassIdentifier] originalClassName = .selfClassName;
            \:output (\[String]:as ##((){\n##);
            \:incrementTab;
            [Variable<[Integer]>] parentNumber = \[Variable<[Integer]>]:as (\[Integer]:as ##1##);
            \parents:iterate *([DainaType] parentType) {
               [Integer] curr = \parentNumber:get;
               \:synthesizeParentObjectDeclaration curr parentType \[Boolean]:true;
               \parentNumber:set (\curr:adding (\[Integer]:as ##1##));
               \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] a) {
                  .selfClassName = parentTypeIdentifier;
               };
            };

            \:outputTabbed (\[String]:as ##OBJECT caller;\n##);
            \:outputTabbed (\[String]:as ##OBJECT anonymousClassObject = ##);
            \:output (\[String]:as ##new class OBJECT, LAMBDA##);
            \parents:iterate *([DainaType] parentType) {
               \:output (\[String]:as ##, ##);
               \parentType:ifClassNameAndGenericInstantiation *([DainaClassIdentifier] parentTypeIdentifier, [List<[DainaType]>] genericInstantiation) {
                  \:output (\[String]:as ##CLASSTYPE_##);
                  \:output (\parentTypeIdentifier:content);
               };
            };
            \:output (\[String]:as ## {\n##); \:incrementTab;
            \:outputTabbed (\[String]:as ##override OBJECT method(OBJECT caller, OBJECT[] parameters) { return caller; }\n##);
            \:iterateUnoverridenInstanceMethodsAnon classMethods parents (:synthesizeParentUnoverridenMethod);
            \classMethods:iterate *([List<[DainaClassMethod<[DainaExpression]>]>] classMethod) {
               \:synthesizeClassMethodImplementation classMethod (\[Boolean]:true);
            };
            \:decrementTab; \:outputTabbed (\[String]:as ##};\n##);

            
            \:outputTabbed (\[String]:as ##caller = anonymousClassObject;\n##);
            \:outputTabbed (\[String]:as ##CLASSTYPE_##);
            \:output (\.selfClassName:content);
            \:output (\[String]:as ## self = ##);
            \:output (\[String]:as ##cast(##);
            \:output (\[String]:as ##CLASSTYPE_##);
            \:output (\.selfClassName:content);
            \:output (\[String]:as ##)caller##);
            \:output (\[String]:as ##;\n##);
            \constructor:iterate *([DainaExpression] constructorStatement) {
               \:synthesizeStatement constructorStatement (\[Boolean]:false);
            };
            \:outputTabbed (\[String]:as ##return anonymousClassObject;\n##);
            \:decrementTab;
            \:outputTabbed (\[String]:as ##})()##);
            .selfClassName = originalClassName;
         };
      } *{
         \:output (\[String]:as ##<INTERNAL EXPRESSION ERROR!!!>##);
      };

      @[[->]->] ifMethodSelfReference
   }

   
}



[Daina :[CommandReader]] (
         Configuration, 
         OutputStream, 
         InputStream, 
         Loops, 
         Variable, 
         Boolean, 
         CommandReader, 
         String,
         Commands,
         Parser,
         Error,
         DainaClass,
         List,
         Maybe,
         DLangSynthesizer,

         Debug
      ) 
   [Configuration] configuration
   [Variable<[Boolean]>] exitReached
   [List<[DainaClass]>] parsedClasses
{

   :: run *([Configuration] configuration) {
      [Daina] daina = \[Daina]:init configuration;
      [Commands] commands = \[Commands]:from (configuration:commandInput);
      \[Loops]:while (*->(\[Boolean]:not \daina:exitReached)) *{
         \commands:readNext daina;
      };
   }
   
   ~ -+- init *([Configuration] configuration) {
      .exitReached = \[Variable<[Boolean]>]:as (\[Boolean]:false);
      .configuration = configuration;
      .parsedClasses = \[List<[DainaClass]>]:empty;
   }

   -+- exitReached *->[Boolean]{}-> \.exitReached:get

   |++ exit *{
      \.exitReached:set (\[Boolean]:true);
      \[Debug]:log (\[String]:as ##Exit\n##);
   }

   |++ parseSourceFile *([String] path) {
      \[Debug]:log (\[String]:as ##parse from ##);
      \[Debug]:log path;
      \[Debug]:log (\[String]:as ##...\n##);
@[->[Maybe<[Byte]>]] == [InputStream]
      [Maybe<[InputStream]>] maybeSourceInput = \.configuration:sourceFileInput path;
      [Boolean] sourceFileSuccess = \maybeSourceInput:isOrElse (*([InputStream] sourceInput) -> [Boolean] {
         [Parser] parser = \[Parser]:withSourceNameAndInput path sourceInput;
         [List<[DainaClass]>] parsedClasses = \[DainaClass]:parseClasses parser;
         [List<[Error]>] errors = \parser:errors;
         [Boolean] parseSuccess = \(\[Integer]:as ##0##):isEqualTo (\errors:length);
         \parseSuccess:ifOrElse *{
            \parsedClasses:iterate *([DainaClass] parsedClass) {
               \.parsedClasses:append parsedClass;
            };
         } *{
            \errors:iterate *([Error] error) {
               \.configuration:outputError error;
            };
         };
      } -> \[Boolean]:true) (*->\[Boolean]:false);
      \sourceFileSuccess:ifOrElse *{} *{
         \.configuration:outputError (\[Error]:sourceFileNotAccessible path);
      };
   }

   |++ compileToFile *([String] path) {
      \[Debug]:log (\[String]:as ##starting analysis...\n##);
      [Analyzer] analyzer = \[Analyzer]:new;
      \analyzer:analyze .parsedClasses;
      [List<[Error]>] errors = \analyzer:errors;
      [Boolean] analysisSuccess = \(\[Integer]:as ##0##):isEqualTo (\errors:length);
      \analysisSuccess:ifOrElse *{
         \[Debug]:log (\[String]:as ##analysis succeeded :)\n##);
         \[Debug]:log (\[String]:as ##compile to ##);
         \[Debug]:log path;
         \[Debug]:log (\[String]:as ##...\n##);
         [Maybe<[OutputStream]>] maybeOutputFile = \.configuration:compilationFileOutput path;
         \maybeOutputFile:isOrElse *([OutputStream] outputFile) {
            [DLangSynthesizer] dlang = \[DLangSynthesizer]:to outputFile;
            \dlang:synthesizeClasses .parsedClasses;
            \[Debug]:log (\[String]:as ##Done!\n##);
         } *{
            \[Debug]:log (\[String]:as ##Can't output to file.\n##);
         };
      } *{
         \errors:iterate *([Error] error) {
            \.configuration:outputError error;
         };
         \[Debug]:log (\[String]:as ##analysis failed :(\n##);
      };
   }

   |++ invalidCommand *{
      \[Debug]:log (\[String]:as ##Invalid command\n##);
   }

}




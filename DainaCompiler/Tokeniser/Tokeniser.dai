
[Tokeniser<PARTICLE [Object], TOKEN [Object]> : [Object]] (
		Object, 
		Sequence, 
		TokenisingRule,
		Or,
		ParticleSequenceProcessor
	)
		[Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>] sequenceOfTokenisingRulesInDecendingOrderOfGreedyness
{
	~ tokeniserWithSequenceOfTokenisingRulesInDecendingOrderOfGreedyness *([Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>] sequenceOfTokenisingRulesInDecendingOrderOfGreedyness){
		\::newObject;
		.sequenceOfTokenisingRulesInDecendingOrderOfGreedyness = sequenceOfTokenisingRulesInDecendingOrderOfGreedyness;
	}

	++ tokeniseParticlesIntoTokensAndRemainingUntokenisedParticles *([Sequence<[&PARTICLE]>] givenParticleSequence) -> [Sequence<[Or<[&TOKEN][&PARTICLE]>]>] { 
		[ParticleSequenceProcessor<[&PARTICLE][&TOKEN]>] processorForGivenParticleSequence = \[ParticleSequenceProcessor<[&PARTICLE][&TOKEN]>]:newProcessorOfParticleSequenceWithTokenisingRulesInDecendingOrderOfGreedyness givenParticleSequence (.sequenceOfTokenisingRulesInDecendingOrderOfGreedyness);
		[Sequence<[Or<[&TOKEN][&PARTICLE]>]>] tokensAndRemainingUntokenisedParticles = \[ControlFlow<[Sequence<[Or<[&TOKEN][&PARTICLE]>]>]>]:constructRecursively *([->[Sequence<[Or<[&TOKEN][&PARTICLE]>]>]] constructRestOfTokenOrUnprocessedParticleSequence) {
			[Sequence<[Or<[&TOKEN][&PARTICLE]>]>] tokensAndRemainingUntokenisedParticles = \[ControlFlow<[Sequence<[Or<[&TOKEN][&PARTICLE]>]>]>]:selectWithSelectorOrDefault *([[Sequence<[Or<[&TOKEN][&PARTICLE]>]>]->] selectTokensAndRemainingUntokenisedParticles) {
				[Maybe<[Or<[&TOKEN][&PARTICLE]>]>] maybeNextTokenOrUnprocessedParticle = \processorForGivenParticleSequence:processextTokenOrReturnNextUnprocessedParticle;
				\maybeNextTokenOrUnprocessedParticle:ifJust *([Or<[&TOKEN][&PARTICLE]>] nextTokenOrUnprocessedParticle) {
					\selectTokensAndRemainingUntokenisedParticles (\[Sequence<[Or<[&TOKEN][&PARTICLE]>]>]:sequenceWithFirstAndRestOfSequenceProvider (\nextTokenOrUnprocessedParticle) constructRestOfTokenOrUnprocessedParticleSequence);
				}
			} (*->\[Sequence<[Or<[&TOKEN][&PARTICLE]>]>]:emptySequence)
		}
	} -> tokensAndRemainingUntokenisedParticles
}

[ParticleSequenceProcessor<PARTICLE [Object], TOKEN [Object]> : [Object]] (
		Object,
		Sequence,
		TokenisingRule,
		ParticleStream,
		MonitoredParticleStream
	) -> (
			Tokeniser
		)
	[MonitoredParticleStream<[&PARTICLE]>] monitoredStreamOfUnprocessedParticles
	[Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>] tokenisingRulesInDecendingOrderOfGreedyness
{
	~ newProcessorOfParticleSequenceWithTokenisingRulesInDecendingOrderOfGreedyness *([Sequence<[&PARTICLE]>] particleSequence, [Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>] tokenisingRulesInDecendingOrderOfGreedyness) {
		\::newObject;
		.monitoredStreamOfUnprocessedParticles = \[MonitoredParticleStream<[&PARTICLE]>]:newMonitoredParticleStreamWithParticleSequence particleSequence;
		.tokenisingRulesInDecendingOrderOfGreedyness = tokenisingRulesInDecendingOrderOfGreedyness;
	}

	++ maybeProcessNextTokenOrReturnNextUnprocessedParticle *()-> [Maybe<[Or<[&TOKEN][&PARTICLE]>]>] {
		[Maybe<[Or<[&TOKEN][&PARTICLE]>]>] nextTokenOrUnprocessedParticle = \[Sequences<[&PARTICLE]>]:foldSequenceWithInitialResultAndOperationToFoldResultIntoSequenceElement (.tokenisingRulesInDecendingOrderOfGreedyness)

		[Maybe<[Or<[&TOKEN][&PARTICLE]>]>] maybeNextTokenOrUnprocessedParticle \[ControlFlow<[Maybe<[Or<[&TOKEN][&PARTICLE]>]>][Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>]>]:transformRecursively (.tokenisingRulesInDecendingOrderOfGreedyness) recursiveTransformationByApplyingTokenisingRulesToMaybeProduceNextTokenOrUnprocessedParticle;
	}	!{
			[[Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>][[Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>]->[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]]->]
			recursiveTransformationByApplyingTokenisingRulesToMaybeProduceNextTokenOrUnprocessedParticle = *([Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>] tokenisingRules, [[Sequence<[TokenisingRule<[&PARTICLE][&TOKEN]>]>]->[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]] recursivelyTransformTokeniserRulesToMaybeProduceNextTokenOrUnprocessedParticle) -> [Maybe<[Or<[&TOKEN][&PARTICLE]>]>] {
				[Maybe<[Or<[&TOKEN][&PARTICLE]>]>] maybeNextTokenOrUnprocessedParticle = ([ControlFlow<[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]>]:selectWithSelectorOrDefault maybeSelectNextTokenOrUnprocessedParticle provideNothing)
					!{
						[->[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]] provideNothing = *->\[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]:asNothing;
						[[[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]->]->] maybeSelectNextTokenOrUnprocessedParticle = *([[Maybe<[Or<[&TOKEN][&PARTICLE]>]>]->] selectNextTokenOrUnprocessedParticle) {
							\tokenisingRules:ifFirstAndRestOfSequence *(nextTokenisingRule)
						}
					}
			}
		}
}

[MonitoredParticleStream<PARTICLE [Object]> : [ParticleStream<[&PARTICLE]>]] (
		Boolean,
		ParticleStream,
		Sequence
	) -> (
		ParticleSequenceProcessor
	)
{
	~ newMonitoredParticleStreamWithParticleSequence *([Sequence<[&PARTICLE]>] particleSequence) {
		streamWithParticleProvider
	}

	++ resetMonitor *{}

	++ particleStreamWasAccessedSinceLastMonitorReset *()->[Boolean]
}






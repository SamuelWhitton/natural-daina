



[DainaClass :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,

			Debug
		)
	[Variable<[Boolean]>] isEntryPointClass
	[DainaDependancyStructure] dependancyStructure
	[DainaExpression] entryPointMethod
	[DainaClassIdentifier] className
	[DainaGenericDeclarationList] genericDeclarationList
	[List<[DainaType]>] inheritedParentTypes
	[List<[DainaObjectDeclaration]>] instanceObjects
	[List<[DainaClassMethod<[DainaExpression]>]>] classMethods
	[List<[DainaCompilerInjection]>] compilerInjections
{
	:: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
		[List<[DainaClass]>] classes = \[List<[DainaClass]>]:empty;
		\[Loops]:until *([->] stop) {
			\[O]:ifElse (\[DainaClass]:isFirstToken (\parser:token)) *{
				[DainaClass] class = \[DainaClass]:base;
				\class:parse parser;
				\classes:append class;
				@\[O]:ifElse (\parser:hasErrors) stop *{};
			} *{	
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:EOF) *{} *{
					\parser:addError (\[Error]:expectingClassAtTopLevel (\parser:position));
				};
				\stop;
			};
		};

		@@\[Loops]:while (*->[Boolean]{[Token] token = \parser:token;}->\[Boolean]:not (\[Token]:equals token (\[Token]:EOF))) *{
			[Token] token = \parser:token;
			\[Debug]:log (\token:asDebugString);
			\[Debug]:log (\[String]:as "\n");
			\parser:gotoNextToken;
		}@@
	} -> classes

	++ isEntryPointOrRegularClass *([[DainaDependancyStructure][DainaExpression]->] getEntryPoint, [[DainaClassIdentifier][List<[DainaType]>][List<[DainaObjectDeclaration]>][List<[DainaClassMethod<[DainaExpression]>]>][List<[DainaCompilerInjection]>]->] getRegularClass) {
		\[O]:ifElse (\.isEntryPointClass:get) *{
			\getEntryPoint .dependancyStructure .entryPointMethod;
		} *{
			\getRegularClass .className .inheritedParentTypes .instanceObjects .classMethods .compilerInjections;
		};
	}

	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		.isEntryPointClass = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.dependancyStructure = \[DainaDependancyStructure]:base;
		.entryPointMethod = \[DainaExpression]:base;
		.className = \[DainaClassIdentifier]:base;
		.genericDeclarationList = \[DainaGenericDeclarationList]:base;
		.inheritedParentTypes = \[List<[DainaType]>]:empty;
		.instanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
		.classMethods = \[List<[DainaClassMethod<[DainaExpression]>]>]:empty;
		.compilerInjections = \[List<[DainaCompilerInjection]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\parser:gotoNextToken;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
			\.isEntryPointClass:set (\[Boolean]:true);
			\parser:gotoNextToken;
			\.dependancyStructure:parse parser;
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\.entryPointMethod:parse parser;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
						\parser:gotoNextToken;
					} *{	
						\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingEntryPointMethod (\parser:position));	
				};
			} *{
				\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));	
			};
		} *{	
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				\.className:parse parser;
				\.genericDeclarationList:parse parser;
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
						\parser:gotoNextToken;
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] parentType = \[DainaType]:base;
							\parentType:parse parser;
							\.inheritedParentTypes:append parentType;
						} *{	
							\parser:addError (\[Error]:expectingParentType (\parser:position));
							\stop;
						};
					} stop;
				};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
					\parser:gotoNextToken;
					\.dependancyStructure:parse parser;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
							[DainaObjectDeclaration] instanceObject = \[DainaObjectDeclaration]:base;
							\instanceObject:parse parser;
							\.instanceObjects:append instanceObject;
						} stop;
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
						\parser:gotoNextToken;
						\[Loops]:until *([->] stop) {
							\[O]:ifElse (\[DainaClassMethod<[DainaExpression]>]:isFirstToken (\parser:token)) *{
								[DainaClassMethod<[DainaExpression]>] classMethod = \[DainaClassMethod<[DainaExpression]>]:base ([DainaExpression]:base) (*([Parser] parser, [DainaExpression] e){\e:parse parser}) ([DainaExpression]:isFirstToken);
								\classMethod:parse parser;
								\classMethod:isInstanceTypeOrConstructor *{} *{} *{
									[DainaType] classType = \[DainaType]:base;
									\classType:setAsClassName .className;
									[DainaExpression] methodExpression = \classMethod:methodExpression;
									\methodExpression:setOutputType classType;
								};
								\.classMethods:append classMethod;
							} *{
								\[O]:ifElse (\[DainaCompilerInjection]:isFirstToken (\parser:token)) *{
									[DainaCompilerInjection] compilerInjection = \[DainaCompilerInjection]:base;
									\compilerInjection:parse parser;
									\.compilerInjections:append compilerInjection;
								} stop;
							};
						};
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
							\parser:gotoNextToken;
						} *{	
							\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
						};
					} *{
						\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));
					};
				} *{	
					\parser:addError (\[Error]:expectingClosingSquareBracketAfterClassHeader (\parser:position));
				};
			} *{
				\parser:addError (\[Error]:expectingClassName (\parser:position));	
			};	
		};
	}
}

[DainaGenericDeclarationList :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] generics
{
	~ base *{
		.generics = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
			\parser:gotoNextToken;
			\[Loops]:until *([->] stop) {
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					[DainaGeneralIdentifier] generic = \[DainaGeneralIdentifier]:base;
					\generic:parse parser;
					\.generics:append generic;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
						\parser:gotoNextToken;
					} stop;
				} *{
					\parser:addError (\[Error]:expectingGenericIdentifier (\parser:position));
					\stop;
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForGenericDeclarationList (\parser:position));
			};
		} *{};
	}
}


[DainaDependancyStructure :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,
			SourcePosition,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] dependancies
	[List<[DainaGeneralIdentifier]>] dependanciesWithDerivatives
	[List<[DainaGeneralIdentifier]>] reverseDependancies
{
	~ base *{
		.dependancies = \[List<[DainaGeneralIdentifier]>]:empty;
		.reverseDependancies = \[List<[DainaGeneralIdentifier]>]:empty;
		.dependanciesWithDerivatives = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
			\parseIDList .dependancies ([Error]:expectingDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:as .dependanciesWithDerivatives);
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
					\parseIDList .reverseDependancies ([Error]:expectingReverseDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:nothing);
				} *{
					\parser:addError (\[Error]:expectingReverseDependancyList (\parser:position));
				};
			} *{};
		} *{};
	} 	!{
			[[List<[DainaGeneralIdentifier]>][[SourcePosition]->[Error]][Maybe<[List<[DainaGeneralIdentifier]>]>]->] parseIDList = *([List<[DainaGeneralIdentifier]>] list, [[SourcePosition]->[Error]] missingIDError, [Maybe<[List<[DainaGeneralIdentifier]>]>] maybeDerivativeList) {
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
							[DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
							\id:parse parser;
							\list:append id;
							\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
								\parser:gotoNextToken;
							} stop;
						} *{
							\maybeDerivativeList:ifNothing missingId;
							\maybeDerivativeList:ifIs *([List<[DainaGeneralIdentifier]>] derivativeList) {
								\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
									\parser:gotoNextToken;
									\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
										[DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
										\id:parse parser;
										\list:append id;
										\derivativeList:append id;
										\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketClose) *{
											\parser:gotoNextToken;
											\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
												\parser:gotoNextToken;
											} stop;
										} *{
											\parser:addError (\[Error]:expectingClosingBracketForDependancyWithDerivatives (\parser:position));
											\stop;
										};
									} missingId;
								} missingId;
							};
						} 	!{ 
								[->] missingId = *{
									\parser:addError (\missingIDError (\parser:position));
									\stop;
								}
							};
					};
				} *{};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketClose) *{
					\parser:gotoNextToken;
				} *{
					\parser:addError (\[Error]:expectingClosingBracketForDependancyList (\parser:position));
				};
			};
	   	}
}


[DainaGeneralIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
		[String] content

{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
	.content = \[String]:as "";
		\::new;
	}

	++ content *->.content

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
		.content = s;
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}

[DainaClassIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
	[String] content
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		.content = \[String]:as "";
		\::new;
	}

	++ content *->.content

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
		.content = s;
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}


[DainaType :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Integer,
			Maybe,
			String,
			Error, M, O,
			Variable,
			DainaClassIdentifier,
			DainaGeneralIdentifier,

			Debug
		)
	[[[DainaClassIdentifier][List<[DainaType]>]->]->] ifClassNameAndGenericInstantiation

	[[[List<[DainaType]>][Maybe<[DainaType]>]->]->] ifMethodInputsAndOutput
	[[[List<[DainaType]>]->]->] ifDisjoint
	[[[DainaGeneralIdentifier]->]->] ifClassGeneric
	[[[Integer][DainaGeneralIdentifier]->]->] ifMethodGenericLevelAndIdentifier
	[[[DainaGeneralIdentifier]->]->] ifDataSegment
	[[->]->] ifInferredMethod
	[[->]->] ifInferredSelf
	[[->]->] ifInferred
	[[[Integer]->]->] ifInferredParent
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	++ ifClassNameAndGenericInstantiation *([[DainaClassIdentifier][List<[DainaType]>]->] get) {
		\.ifClassNameAndGenericInstantiation get;
	}

	++ ifMethodInputsAndOutput *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {
		\.ifMethodInputsAndOutput get;
	}

	~ base *{
		.ifClassNameAndGenericInstantiation = *([]a){};

		.ifMethodInputsAndOutput = *([]a){};
		.ifDisjoint = *([]a){};
		.ifClassGeneric = *([]a){};
		.ifMethodGenericLevelAndIdentifier = *([]a){};
		.ifDataSegment = *([]a){};
		.ifInferredMethod = *([]a){};
		.ifInferredSelf = *([]a){};
		.ifInferredParent = *([]a){};
		.ifInferred = *([->]a){\a};
		\::new;
	}

	++ setAsMethodWithOutputType *([DainaType] outputType) {
		.ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->]get){\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:as outputType)};
	}

	++ setAsClassName *([DainaClassIdentifier] className) {
		.ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->]get){\get className (\[List<[DainaType]>]:empty)};
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				[DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
				\className:parse parser;
				[List<[DainaType]>] genericInstantiations = \[List<[DainaType]>]:empty;
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
					\parser:gotoNextToken;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] genericInstantiation = \[DainaType]:base;
							\genericInstantiation:parse parser;
							\genericInstantiations:append genericInstantiation;
							\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{} stop;
						} *{
							\parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
							\stop;
						};
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
						\parser:gotoNextToken;
					} *{
						\parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
					};
				} *{};
				.ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->] get) {\get className genericInstantiations};
			} *{
				@ bla my way through
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
						[DainaType] subtype = \[DainaType]:base;
						\subtype:parse parser;
						\.ifMethodInputsAndOutput *([List<[DainaType]>] a, [Maybe<[DainaType]>]b) {
							.ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:as subtype)};
						};
					} *{
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow) *{
							\parser:gotoNextToken;
							.ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:nothing)};
						} *{
							\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) stop *{
								\parser:gotoNextToken;
							};
						};
					};
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
			};
		} *{
			\parser:addError (\[Error]:expectingType (\parser:position));
		};
	}
}


[DainaObjectDeclaration :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaType,
			DainaGeneralIdentifier,

			Debug
		)
	[DainaType] type
	[DainaGeneralIdentifier] identifier
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Boolean]:or (\[DainaType]:isFirstToken token) (\[DainaGeneralIdentifier]:isFirstToken token))

	++ type*->.type
	++ identifier*->.identifier

	~ base *{
		.type = \[DainaType]:base;
		.identifier = \[DainaGeneralIdentifier]:base;
		\::new;
	}

	~ as *([DainaType] type, [DainaGeneralIdentifier] identifier){
		.type = type;
		.identifier = identifier;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
		} *{
			\.type:parse parser;
			\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
				\.identifier:parse parser;
			} *{
				\parser:addError (\[Error]:expectingIdentifierForObjectDeclaration (\parser:position));
			};
		};
	}
}


@class-method-classification identifier ( type | expression )

@    class-method-classification: ( ( | | || )? method-visibility-indicator ) | ( ( ~ | :: ) ( | )? ( method-visibility-indicator )? )


[DainaClassMethod<DainaExpression[Object]> :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,
			Variable,
			DainaType,

			Debug
		)
	[Variable<[Boolean]>] unimplementedMethod
	[DainaGeneralIdentifier] identifier
	[&DainaExpression] methodExpression
	[[->][->][->]->] isInstanceTypeOrConstructor
	[[Parser][&DainaExpression]->] parseExpression
	[[Token]->[Boolean]] isExpressionFirstToken
	[DainaType] unimplementedType
{
	++ isInstanceTypeOrConstructor *([->] isInstance,[->] isType,[->] isConstructor) {
		\.isInstanceTypeOrConstructor isInstance isType isConstructor;
	}

	++ isUnimplementedMethod *->(\.unimplementedMethod:get)

	++ unimplementedType *->(.unimplementedType)

	++ methodExpression *->.methodExpression

	++ identifier*-> .identifier

	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Boolean]:or (\[Boolean]:or (\[Token]:isVisibilityIndicator token) (\[Token]:equals token (\[Token]:pipe))) (\[Boolean]:or (\[Token]:equals token (\[Token]:doubleColon)) (\[Token]:equals token (\[Token]:tilde))))

	~ base *([->[&DainaExpression]] getBase, [[Parser][&DainaExpression]->] parseExpression, [[Token]->[Boolean]] isExpressionFirstToken){
		.isInstanceTypeOrConstructor = *([->]a,[]b,[]c){};
		.methodExpression = \getBase;
		.identifier = \[DainaGeneralIdentifier]:base;
		.unimplementedMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.parseExpression = parseExpression;
		.isExpressionFirstToken = isExpressionFirstToken;
		.unimplementedType = \[DainaType]:base;
		\::new;
	}

	++ parse *([Parser] parser) {
		.isInstanceTypeOrConstructor = *([->]a,[]b,[]c){\a};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:tilde)) *{
			\parser:gotoNextToken;
			.isInstanceTypeOrConstructor = *([]a,[]b,[->]c){\c};
		} *{
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:doubleColon)) *{
				\parser:gotoNextToken;
				.isInstanceTypeOrConstructor = *([]a,[->]b,[]c){\b};
			} *{};
		};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:pipe)) *{
			\parser:gotoNextToken;
		} *{};
		\.isInstanceTypeOrConstructor *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingVisibilityIndicatorForInstanceMethod (\parser:position));
			};
		} *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{};
		} *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{};
		};
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
			\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
				\.unimplementedMethod:set (\[Boolean]:true); 
				[DainaType] typeForUnimplemented = \[DainaType]:base;
				\.unimplementedType:parse parser;
			} *{
				\[O]:ifElse (\.isExpressionFirstToken (\parser:token)) *{
					\.parseExpression parser (.methodExpression);
				} *{
					\parser:addError (\[Error]:expectingClassMethodExpression (\parser:position));
				};
			};
		} *{
			\parser:addError (\[Error]:expectingIdentifierForClassMethod (\parser:position));
		};
	}
}


[DainaExpression :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaObjectDeclaration,
			DainaType,
			Variable,
			DainaClassMethod,
			DainaGeneralIdentifier,
			Integer,
			DainaCompilerInjection,

			Debug
		)
	[DainaType] outputType
	[[[List<[DainaExpression]>]->]->] ifStatementGroup
	[[[String]->]->] ifDataSegment
	[[[DainaExpression][DainaExpression]->]->] ifWithPrologueStatement
	[[[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->]->] ifMethodExpression
	[[[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->]->] ifAnonymousClassObject
	[[[DainaExpression][DainaGeneralIdentifier]->]->] ifInstanceMethod
	[[[DainaObjectDeclaration][DainaExpression]->]->] ifLocalObjectAssignment
	[[[DainaType][DainaGeneralIdentifier]->]->] ifTypeMethod

	[[[DainaExpression][List<[DainaExpression]>]->]->] ifInvocation
	[[[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->]->] ifConstructorInvocation @ parentnum, identifier, ispointerconsturcotr, params
	[[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceMethodAssignment
	[[[DainaGeneralIdentifier][DainaExpression]->]->] ifInstanceObjectAssignment
	[[[DainaExpression]->]->] ifProxyObject
	[[[DainaCompilerInjection]->]->] ifCompilerInjection
	[[[DainaGeneralIdentifier]->]->] ifLocalObject
	[[[Integer][DainaGeneralIdentifier]->]->] ifInternalInstanceMethod @ prentnum, id
	[[[DainaGeneralIdentifier]->]->] ifInternalInstanceObject
	[[->]->] ifSelfReference
	[[->]->] ifMethodSelfReference
	
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} ->  

(\[Boolean]:or (\[Token]:equals token (\[Token]:backslash))
(\[Boolean]:or (\[Token]:equals token (\[Token]:fullStop))
(\[Boolean]:or (\[Token]:equals token (\[Token]:colon))
(\[Boolean]:or (\[Token]:equals token (\[Token]:asteriskCaret))
(\[Boolean]:or (\[Token]:equals token (\[Token]:asteriskArrow))
(\[Boolean]:or (\[Token]:equals token (\[Token]:caret))
(\[Boolean]:or (\[Token]:equals token (\[Token]:doubleLessThan))
(\[Boolean]:or (\[Token]:equals token (\[Token]:roundBracketOpen))
(\[Boolean]:or (\[Token]:isIdentifier token)
(\[Boolean]:or (\[Token]:isParentIdentifier token)

	(\[Boolean]:or (\[Token]:equals token (\[Token]:squareBracketOpen)) (\[Boolean]:or (\[Token]:equals token (\[Token]:curlyBracketOpen)) (\[Boolean]:or (\[Token]:isDataSegment token) (\[Token]:equals token (\[Token]:asterisk))))) ))))))))))


	~ base *{
		.ifStatementGroup = *([[List<[DainaExpression]>]->]get){};
		.ifDataSegment = *([]a){};
		.ifWithPrologueStatement = *([]a){};
		.ifMethodExpression = *([]a){};
		.ifAnonymousClassObject = *([]a){};
		.ifInstanceMethod = *([]a){};
		.ifLocalObjectAssignment = *([]a){};
		.ifTypeMethod = *([]a){};
		.outputType = \[DainaType]:base;

		.ifInvocation = *([]a){};
		.ifConstructorInvocation = *([]a){};
		.ifInstanceMethodAssignment = *([]a){};
		.ifInstanceObjectAssignment = *([]a){};
		.ifProxyObject = *([]a){};
		.ifCompilerInjection = *([]a){};
		.ifLocalObject = *([]a){};
		.ifInternalInstanceMethod = *([]a){};
		.ifInternalInstanceObject = *([]a){};
		.ifSelfReference = *([]a){};
		.ifMethodSelfReference = *([]a){};
		
		\::new;
	}

	++ outputType *->[DainaType]{}->.outputType
	++ setOutputType *([DainaType] outputType) {.outputType = outputType}

	++ ifInvocation *([[DainaExpression][List<[DainaExpression]>]->] get) {\.ifInvocation get}
	++ ifConstructorInvocation *([[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->] get) {\.ifConstructorInvocation get}
	++ ifInstanceMethodAssignment *([[DainaGeneralIdentifier][DainaExpression]->] get) {\.ifInstanceMethodAssignment get}
	++ ifInstanceObjectAssignment *([[DainaGeneralIdentifier][DainaExpression]->] get) {\.ifInstanceObjectAssignment get}
	++ ifProxyObject *([[DainaExpression]->] get) {\.ifProxyObject get}
	++ ifCompilerInjection *([[DainaCompilerInjection]->] get) {\.ifCompilerInjection get}
	++ ifLocalObject *([[DainaGeneralIdentifier]->] get) {\.ifLocalObject get}
	++ ifInternalInstanceMethod *([[Integer][DainaGeneralIdentifier]->] get) {\.ifInternalInstanceMethod get}
	++ ifInternalInstanceObject *([[DainaGeneralIdentifier]->] get) {\.ifInternalInstanceObject get}
	++ ifSelfReference *([->] get) {\.ifSelfReference get}
	++ ifMethodSelfReference *([->] get) {\.ifMethodSelfReference get}

	++ ifStatementGroup *([[List<[DainaExpression]>]->] get) {\.ifStatementGroup get}
	++ ifDataSegment *([[String]->] get) {\.ifDataSegment get}
	++ ifWithPrologueStatement *([[DainaExpression][DainaExpression]->] get) {\.ifWithPrologueStatement get}
	++ ifMethodExpression *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {\.ifMethodExpression get}
	++ ifAnonymousClassObject *([[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->] get) {\.ifAnonymousClassObject get}
	++ ifInstanceMethod *([[DainaExpression][DainaGeneralIdentifier]->] get) {\.ifInstanceMethod get}
	++ ifLocalObjectAssignment *([[DainaObjectDeclaration][DainaExpression]->] get) {\.ifLocalObjectAssignment get}
	++ ifTypeMethod *([[DainaType][DainaGeneralIdentifier]->] get) {\.ifTypeMethod get}

	++ @@-+-@@ copy *([DainaExpression] other) {
		.ifStatementGroup = other:ifStatementGroup;
		.ifDataSegment = other:ifDataSegment;
		.ifWithPrologueStatement = other:ifWithPrologueStatement;
		.ifMethodExpression = other:ifMethodExpression;
		.ifAnonymousClassObject = other:ifAnonymousClassObject;
		.ifInstanceMethod = other:ifInstanceMethod;
		.ifLocalObjectAssignment = other:ifLocalObjectAssignment;
		.ifTypeMethod = other:ifTypeMethod;
		.outputType = \other:outputType;

		.ifInvocation = other:ifInvocation;
		.ifConstructorInvocation = other:ifConstructorInvocation;
		.ifInstanceMethodAssignment = other:ifInstanceMethodAssignment;
		.ifInstanceObjectAssignment = other:ifInstanceObjectAssignment;
		.ifProxyObject = other:ifProxyObject;
		.ifCompilerInjection = other:ifCompilerInjection;
		.ifLocalObject = other:ifLocalObject;
		.ifInternalInstanceMethod = other:ifInternalInstanceMethod;
		.ifInternalInstanceObject = other:ifInternalInstanceObject;
		.ifSelfReference = other:ifSelfReference;
		.ifMethodSelfReference = other:ifMethodSelfReference;
	}

	++ makeEmptyStatement *{.ifStatementGroup = *([[List<[DainaExpression]>]->] get){\get (\[List<[DainaExpression]>]:empty)}}

	++ parse *([Parser] parser) {
		[DainaExpression] left = \[DainaExpression]:base;
		\left:parseStrongBinding parser;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:exclamationMark) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
				[DainaExpression] right = \[DainaExpression]:base;
				\right:parse parser;
				.ifWithPrologueStatement = *([[DainaExpression][DainaExpression]->] get) {\get left right};
			} *{
				\parser:addError (\[Error]:expectingPrologueStatement (\parser:position));
			};
		} *{
			\:copy left;
		};
	}

	

	++ @@-+-@@ parseStrongBinding *([Parser] parser) {
		[DainaExpression] left = \[DainaExpression]:base;
		\left:parseStrongestBinding parser;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:colon) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
				[DainaGeneralIdentifier] right = \[DainaGeneralIdentifier]:base;
				\right:parse parser;
				.ifInstanceMethod = *([[DainaExpression][DainaGeneralIdentifier]->] get) {\get left right};
			} *{
				\parser:addError (\[Error]:expectingInstanceMethodIdentifier (\parser:position));
			};
		} *{
			\:copy left;
		};
	}

	++ @@-+-@@ parseStrongestBinding *([Parser] parser) {
		[Token] token1 = (\parser:token);
		[Token] token2 = (\parser:peekAtNextToken);
		\[O]:ifElse (\[Token]:isDataSegment token1) *{
			.ifDataSegment = *([[String]->] get) {\get (\token1:content)};
			\parser:gotoNextToken;
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:asterisk)) *{
			\parser:gotoNextToken;
			[List<[DainaObjectDeclaration]>] parameters = \[List<[DainaObjectDeclaration]>]:empty;
			[DainaExpression] body = (\[DainaExpression]:base);
			[Variable<[Maybe<[DainaExpression]>]>] output = \[Variable<[Maybe<[DainaExpression]>]>]:as (\[Maybe<[DainaExpression]>]:nothing);
			.ifMethodExpression = *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {
				\get parameters body (\output:get);
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
				\parser:gotoNextToken;
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
						[DainaObjectDeclaration] parameter = \[DainaObjectDeclaration]:base;
						\parameter:parse parser;
						\parameters:append parameter;
					} *{
						\parser:addError (\[Error]:expectingMethodInput (\parser:position));
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:comma)) (parser:gotoNextToken) stop;
				};
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
					\parser:gotoNextToken;
				} *{
					\parser:addError (\[Error]:expectingClosingBracketForMethodInputs (\parser:position));
				};
			} *{};
			\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
				\body:parseStrongBinding parser;
			} *{
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
					\parser:gotoNextToken;
					\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
						[DainaType] outputType = \[DainaType]:base;
						\outputType:parse parser;
						.outputType = outputType;
						\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
							\body:parseStrongBinding parser;
						} *{
							\parser:addError (\[Error]:expectingMethodBody (\parser:position));
						};
						\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
							\parser:gotoNextToken;
						} *{
							\parser:addError (\[Error]:expectingMethodOutput (\parser:position));
						};
					} *{
						\body:makeEmptyStatement;
					};
					\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
						[DainaExpression] outputExpression = \[DainaExpression]:base;
						\outputExpression:parseStrongBinding parser;
						\output:set (\[Maybe<[DainaExpression]>]:as outputExpression);
					} *{
						\parser:addError (\[Error]:expectingMethodOutput (\parser:position));
					};
				} *{
					\body:makeEmptyStatement;
				};
			};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:curlyBracketOpen)) *{
			\parser:gotoNextToken;
			[List<[DainaExpression]>] statements = \[List<[DainaExpression]>]:empty;
			.ifStatementGroup = *([[List<[DainaExpression]>]->] get) {\get statements};
			\[Loops]:until *([->] stop) {
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					[DainaExpression] statement = \[DainaExpression]:base;
					\statement:parse parser;
					\statements:append statement;
				} *{};
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:semicolon)) (parser:gotoNextToken) stop;
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketClose)) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForStatementGroup (\parser:position));
			};
		} *{};
		\[O]:ifElse (\[Boolean]:and (\[Token]:equals token1 (\[Token]:squareBracketOpen)) (\[Token]:equals token2 (\[Token]:colon))) *{
			@anonymous-class-object
			\parser:gotoNextToken;
			\parser:gotoNextToken;
			[List<[DainaType]>] parents = \[List<[DainaType]>]:empty;
			[List<[DainaExpression]>] constructor = \[List<[DainaExpression]>]:empty;
			[List<[DainaClassMethod<[DainaExpression]>]>] classMethods = \[List<[DainaClassMethod<[DainaExpression]>]>]:empty;
			.ifAnonymousClassObject = *([[List<[DainaType]>][List<[DainaExpression]>][List<[DainaClassMethod<[DainaExpression]>]>]->] get)  {
				\get parents constructor classMethods;
			};
			\[Loops]:until *([->] stop) {
				\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
					[DainaType] parent = \[DainaType]:base;
					\parent:parse parser;
					\parents:append parent;
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) (parser:gotoNextToken) stop;
				} *{
					\parser:addError (\[Error]:expectingParentTypeForAnonymousClassObject (\parser:position));
					\stop;
				}
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:squareBracketClose)) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketOpen)) *{
					\parser:gotoNextToken;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
							[DainaExpression] constructorStatement = \[DainaExpression]:base;
							\constructorStatement:parse parser;
							\constructor:append constructorStatement;
						} *{};
						\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:semicolon)) (parser:gotoNextToken) stop;
					};
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaClassMethod<[DainaExpression]>]:isFirstToken (\parser:token)) *{
							[DainaClassMethod<[DainaExpression]>] classMethod = \[DainaClassMethod<[DainaExpression]>]:base ([DainaExpression]:base) (*([Parser] parser, [DainaExpression] e){\e:parse parser}) ([DainaExpression]:isFirstToken);
							\classMethod:parse parser;
							\classMethods:append classMethod;
						} stop;
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:curlyBracketClose)) *{
						\parser:gotoNextToken;
					} *{
						\parser:addError (\[Error]:expectingClosingBracketForAnonymousClassBody (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingAnonymousClassBody (\parser:position));
				};
			} *{
				\parser:addError (\[Error]:expectingClosingSquareBracketAfterAnonymousClassHeader (\parser:position));
			};
		} *{};
		\[O]:ifElse (\[Boolean]:and (\[DainaType]:isFirstToken token1) (\[Boolean]:not (\[Token]:equals token2 (\[Token]:colon)))) *{
			[DainaType] type = \[DainaType]:base;
			\type:parse parser;
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					[DainaExpression] expr = \[DainaExpression]:base;
					\expr:parse parser;
					\:copy expr;
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
						\parser:gotoNextToken;
					} *{
						\parser:addError (\[Error]:expectingClosingBracketForCastExpression (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingExpressionToBeCast (\parser:position));
				};
			} *{
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
					\parser:gotoNextToken;
					\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
						[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
						\identifier:parse parser;
						.ifTypeMethod = *([[DainaType][DainaGeneralIdentifier]->] get) {\get type identifier};
					} *{
						\parser:addError (\[Error]:expectingIdentifierForTypeMethod (\parser:position));
					};
				} *{
					\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
						[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
						\identifier:parse parser;
						[DainaObjectDeclaration] localDeclaration = \[DainaObjectDeclaration]:as type identifier;
						\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
							\parser:gotoNextToken;
							\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
								[DainaExpression] expr = \[DainaExpression]:base;
								\expr:parse parser;
								.ifLocalObjectAssignment = *([[DainaObjectDeclaration][DainaExpression]->] get) {\get localDeclaration expr};
							} *{
								\parser:addError (\[Error]:expectingExpressionToAssignLocalDeclaration (\parser:position));	
							};
						} *{
							\parser:addError (\[Error]:expectingEqualsToAssignLocalDeclaration (\parser:position));	
						};
					} *{
						\parser:addError (\[Error]:unexpectedTokenAfterType (\parser:position));
					};
				};
			};
		} *{};

		\[O]:ifElse (\[Token]:equals token1 (\[Token]:colon)) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
				[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
				\identifier:parse parser;
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
					\parser:gotoNextToken;
					\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
						[DainaExpression] expr = \[DainaExpression]:base;
						\expr:parse parser;
						.ifInstanceMethodAssignment = *([[DainaGeneralIdentifier][DainaExpression]->] get) {\get identifier expr};
					} *{
						\parser:addError (\[Error]:expectingExpressionToAssignInstanceMethod (\parser:position));	
					};
				} *{
					.ifInternalInstanceMethod = *([[Integer][DainaGeneralIdentifier]->] get) {\get (\[Integer]:zero) identifier};
				};
			} *{
				\parser:addError (\[Error]:expectingInstanceMethodIdentifier (\parser:position));
			};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:fullStop)) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
				[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
				\identifier:parse parser;
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:equalsSign)) *{
					\parser:gotoNextToken;
					\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
						[DainaExpression] expr = \[DainaExpression]:base;
						\expr:parse parser;
						.ifInstanceObjectAssignment = *([[DainaGeneralIdentifier][DainaExpression]->] get) {\get identifier expr};
					} *{
						\parser:addError (\[Error]:expectingExpressionToAssignInstanceObject (\parser:position));	
					};
				} *{
					.ifInternalInstanceObject = *([[DainaGeneralIdentifier]->] get) {\get identifier};
				};
			} *{
				\parser:addError (\[Error]:expectingInstanceObjectIdentifier (\parser:position));
			};
		} *{};
		\[O]:ifElse (\[Token]:isParentIdentifier token1) *{
			[Integer] parentNum = \token1:secondId;
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
				[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
				\identifier:parse parser;
				.ifInternalInstanceMethod = *([[Integer][DainaGeneralIdentifier]->] get) {\get parentNum identifier};
			} *{
				\parser:addError (\[Error]:expectingInstanceObjectIdentifier (\parser:position));
			};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:backslash)) *{
			[->[List<[DainaExpression]>]] parseParameterList = *->[List<[DainaExpression]>] {
				[List<[DainaExpression]>] paramList = \[List<[DainaExpression]>]:empty;
				\[Loops]:while (*->(\[DainaExpression]:isFirstToken (\parser:token))) *{
					[DainaExpression] expr = \[DainaExpression]:base;
					\expr:parse parser;
					\paramList:append expr;
				};
			} -> paramList;
			\parser:gotoNextToken;
			\[O]:ifElse (\[Token]:equals (\parser:peekAtNextToken) (\[Token]:tilde)) *{
				[Token] idToken = (\parser:token);
				[Variable<[Maybe<[Integer]>]>] parentNum = \[Variable<[Maybe<[Integer]>]>]:as (\[Maybe<[Integer]>]:nothing);
				\[O]:ifElse (\[Token]:isParentIdentifier idToken) *{
					\parentNum:set (\[Maybe<[Integer]>]:as (\idToken:secondId));
				} *{
					\[O]:ifElse (\[Token]:equals idToken (\[Token]:colon)) *{
						\parentNum:set (\[Maybe<[Integer]>]:as (\[Integer]:zero));
					} *{
						\parser:addError (\[Error]:unexpectedTokenBeforeTilde (\parser:position));
					};
				};
				[Maybe<[Integer]>] m = \parentNum:get;
				\m:ifIs *([Integer] parentNumber) {
					\parser:gotoNextToken;
					\parser:gotoNextToken;
					[Boolean] isPointerConstructor = (\[Token]:equals (\parser:token) (\[Token]:arrowBracketClose));
					[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
					\[O]:ifElse isPointerConstructor (parser:gotoNextToken) *{
						\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
							\identifier:parse parser;
						} *{
							\parser:addError (\[Error]:expectingConstructorIdentifier (\parser:position));	
						};
					};
					[List<[DainaExpression]>] paramList = \parseParameterList;
					.ifConstructorInvocation = *([[Integer][DainaGeneralIdentifier][Boolean][List<[DainaExpression]>]->] get) {\get parentNumber identifier isPointerConstructor paramList};
				};
			} *{
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					[DainaExpression] methodExpr = \[DainaExpression]:base;
					\methodExpr:parse parser;
					[List<[DainaExpression]>] paramList = \parseParameterList;
					.ifInvocation = *([[DainaExpression][List<[DainaExpression]>]->] get) {\get methodExpr paramList};
				} *{
					\parser:addError (\[Error]:expectingMethodToInvoke (\parser:position));	
				};
			};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:asteriskArrow)) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
				[DainaExpression] expr = \[DainaExpression]:base;
				\expr:parse parser;
				.ifProxyObject = *([[DainaExpression]->] get) {\get expr};
			} *{
				\parser:addError (\[Error]:expectingProxyObject (\parser:position));	
			};
		} *{};
		\[O]:ifElse (\[DainaCompilerInjection]:isFirstToken token1) *{
			[DainaCompilerInjection] inj = \[DainaCompilerInjection]:base;
			\inj:parse parser;
			.ifCompilerInjection = *([[DainaCompilerInjection]->] get) {\get inj};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:roundBracketOpen)) *{
			\parser:gotoNextToken;
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					[DainaExpression] expr = \[DainaExpression]:base;
					\expr:parse parser;
					\:copy expr;
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
						\parser:gotoNextToken;
					} *{
						\parser:addError (\[Error]:expectingClosingBracketForExpression (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingExpression (\parser:position));
				};
		} *{};
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken token1) *{
			[DainaGeneralIdentifier] identifier = \[DainaGeneralIdentifier]:base;
			\identifier:parse parser;
			.ifLocalObject = *([[DainaGeneralIdentifier]->] get) {\get identifier};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:caret)) *{
			\parser:gotoNextToken;
			.ifSelfReference = *([->] get) {\get};
		} *{};
		\[O]:ifElse (\[Token]:equals token1 (\[Token]:asteriskCaret)) *{
			\parser:gotoNextToken;
			.ifMethodSelfReference = *([->] get) {\get};
		} *{};

	}
}

@@

expression: ( data-segment | compiler-injection | assignment-statement | statement-group | object-method | proxy-object | method-expression | grouped-expression | method-invocation | type-method | object-identifier | internal-instance-method | internal-instance-object | self-reference | method-self-reference | anonymous-class-object ) ( prologue-statement )?

    object-method: expression : identifier
    proxy-object syntax description: *- expression
    grouped-expression: ( type-cast )? ( expression )
        type-cast: type
    type-method: type : identifier
    object-identifier: identifier
    self-reference: ^
    method-self-reference: *^



All the different expressions can be combined in a compound way. Various constructs have different binding strength. The following list shows constructs in order of binding strength from weakest to strongest.

   1 ! binding to the preceeding expression and the following statement (as in a prologue statement for an expression)
   2 = binding to the left hand side and the next expression, \ binding to the following one or more expressions (as in invoking a method and the corresponding inputs), -> binding to the next expression (as in the output of a method), *- binding to the next expression (as in the object of which to form an object proxy) and * binding to the lone statement or statement group of a method which may be preceeded by a method input list (see flexible method expression)
   3 : binding to the following identifier and sometimes the preceeding type or expression (as in a type method or an instance method) cast
   4 A type (such as [Foo]) binding to an object name in an assignment or to an expression as in type casting.
   5 All other symbols; such as ., $, $$, :~ and $$~

   


A construct will bind stronger then a preceeding construct at the same binding level indicated by the above list. In other words, an ! will bind stronger then all other ! which preceeded it, and a -> will bind stronger then all other \ which preceeded it.





[TokenSelect<E>] {
	:: default *([&E] defaultValue) {
	} -> [:[TokenSelect<[&E]>]] {
		|++ openCurlyBracket *->defaultValue
		|++ closeCurlyBracket *->defaultValue
		|++ identifier *->defaultValue
	};
	++ openCurlyBracket [->[&E]]
	++ closeCurlyBracket [->[&E]]
	++ identifier [[String]->[&E]]
}

[[TokenSelect<['E]>]->['E]] firstToken = *([TokenSelect<[?]>] t) -> \t:identifier \[String]:as ##identifierTest##;
[[TokenSelect<['E]>]->['E]] secondToken = *([TokenSelect<[?]>] t) -> \t:closeCurlyBracket;

[Boolean] isBracket = \firstToken [:[TokenSelect<[Boolean]>]] {
	\$~>\[TokenSelect<[?]>]:default \[Boolean]:false
	|++ openCurlyBracket *->\[Boolean]:true
	|++ closeCurlyBracket *->\[Boolean]:true
};




@@

[DainaCompilerInjection :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,

			Debug
		)
	[DainaGeneralIdentifier] identifier
	[String] dataSegment
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:doubleLessThan)

	~ base *{
		.identifier = \[DainaGeneralIdentifier]:base;
		.dataSegment = \[String]:as "";
		\::new;
	}

	++ identifierString *->\.identifier:content

	++ dataSegment *->.dataSegment

	++ parse *([Parser] parser) {
		\parser:gotoNextToken;
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
			\[O]:ifElse (\[Token]:isDataSegment (\parser:token)) *{
				[Token] token = (\parser:token);
				.dataSegment = \token:content;
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingDataSegmentForCompilerInjection (\parser:position));
			};
		} *{
			\parser:addError (\[Error]:expectingIdentifierForCompilerInjection (\parser:position));
		};
	}
}








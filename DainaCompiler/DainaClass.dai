



[DainaClass :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,

			Debug
		)
	[Variable<[Boolean]>] isEntryPointClass
	[DainaDependancyStructure] dependancyStructure
	[DainaExpression] entryPointMethod
	[DainaClassIdentifier] className
	[DainaGenericDeclarationList] genericDeclarationList
	[List<[DainaType]>] inheritedParentTypes
	[List<[DainaObjectDeclaration]>] instanceObjects
	[List<[DainaClassMethod]>] classMethods
	[List<[DainaCompilerInjection]>] compilerInjections
{
	:: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
		[List<[DainaClass]>] classes = \[List<[DainaClass]>]:empty;
		\[Loops]:until *([->] stop) {
			\[O]:ifElse (\[DainaClass]:isFirstToken (\parser:token)) *{
				[DainaClass] class = \[DainaClass]:base;
				\class:parse parser;
				\classes:append class;
				@\[O]:ifElse (\parser:hasErrors) stop *{};
			} *{	
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:EOF) *{} *{
					\parser:addError (\[Error]:expectingClassAtTopLevel (\parser:position));
				};
				\stop;
			};
		};

		@@\[Loops]:while (*->[Boolean]{[Maybe<[Token]>] token = \parser:token;}->\token:is (*([]a)->\[Boolean]:true)) *{
			[Maybe<[Token]>] maybeToken = \parser:token;
			\maybeToken:ifIs *([Token] token) {
				@\[Debug]:log (\token:asDebugString);
				@\[Debug]:log (\[String]:as "\n");
			};
			\parser:gotoNextToken;
		}@@
	} -> classes

	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		.isEntryPointClass = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.dependancyStructure = \[DainaDependancyStructure]:base;
		.entryPointMethod = \[DainaExpression]:base;
		.className = \[DainaClassIdentifier]:base;
		.genericDeclarationList = \[DainaGenericDeclarationList]:base;
		.inheritedParentTypes = \[List<[DainaType]>]:empty;
		.instanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
		.classMethods = \[List<[DainaClassMethod]>]:empty;
		.compilerInjections = \[List<[DainaCompilerInjection]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\parser:gotoNextToken;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
			\.isEntryPointClass:set (\[Boolean]:true);
			\parser:gotoNextToken;
			\.dependancyStructure:parse parser;
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\.entryPointMethod:parse parser;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
						\parser:gotoNextToken;
					} *{	
						\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingEntryPointMethod (\parser:position));	
				};
			} *{
				\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));	
			};
		} *{	
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				\.className:parse parser;
				\.genericDeclarationList:parse parser;
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
						\parser:gotoNextToken;
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] parentType = \[DainaType]:base;
							\parentType:parse parser;
							\.inheritedParentTypes:append parentType;
						} *{	
							\parser:addError (\[Error]:expectingParentType (\parser:position));
							\stop;
						};
					} stop;
				};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
					\parser:gotoNextToken;
					\.dependancyStructure:parse parser;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
							[DainaObjectDeclaration] instanceObject = \[DainaObjectDeclaration]:base;
							\instanceObject:parse parser;
							\.instanceObjects:append instanceObject;
						} stop;
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
						\parser:gotoNextToken;
						\[Loops]:until *([->] stop) {
							\[O]:ifElse (\[DainaClassMethod]:isFirstToken (\parser:token)) *{
								[DainaClassMethod] classMethod = \[DainaClassMethod]:base;
								\classMethod:parse parser;
								\.classMethods:append classMethod;
							} *{
								\[O]:ifElse (\[DainaCompilerInjection]:isFirstToken (\parser:token)) *{
									[DainaCompilerInjection] compilerInjection = \[DainaCompilerInjection]:base;
									\compilerInjection:parse parser;
									\.compilerInjections:append compilerInjection;
								} stop;
							};
						};
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
							\parser:gotoNextToken;
						} *{	
							\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
						};
					} *{
						\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));
					};
				} *{	
					\parser:addError (\[Error]:expectingClosingSquareBracketAfterClassHeader (\parser:position));
				};
			} *{
				\parser:addError (\[Error]:expectingClassName (\parser:position));	
			};	
		};
	}
}

[DainaGenericDeclarationList :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] generics
{
	~ base *{
		.generics = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
			\parser:gotoNextToken;
			\[Loops]:until *([->] stop) {
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					[DainaGeneralIdentifier] generic = \[DainaGeneralIdentifier]:base;
					\generic:parse parser;
					\.generics:append generic;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
						\parser:gotoNextToken;
					} stop;
				} *{
					\parser:addError (\[Error]:expectingGenericIdentifier (\parser:position));
					\stop;
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForGenericDeclarationList (\parser:position));
			};
		} *{};
	}
}


[DainaDependancyStructure :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,
			SourcePosition,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] dependancies
	[List<[DainaGeneralIdentifier]>] dependanciesWithDerivatives
	[List<[DainaGeneralIdentifier]>] reverseDependancies
{
	~ base *{
		.dependancies = \[List<[DainaGeneralIdentifier]>]:empty;
		.reverseDependancies = \[List<[DainaGeneralIdentifier]>]:empty;
		.dependanciesWithDerivatives = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
			\parseIDList .dependancies ([Error]:expectingDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:as .dependanciesWithDerivatives);
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
					\parseIDList .reverseDependancies ([Error]:expectingReverseDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:nothing);
				} *{
					\parser:addError (\[Error]:expectingReverseDependancyList (\parser:position));
				};
			} *{};
		} *{};
	} 	!{
			[[List<[DainaGeneralIdentifier]>][[SourcePosition]->[Error]][Maybe<[List<[DainaGeneralIdentifier]>]>]->] parseIDList = *([List<[DainaGeneralIdentifier]>] list, [[SourcePosition]->[Error]] missingIDError, [Maybe<[List<[DainaGeneralIdentifier]>]>] maybeDerivativeList) {
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
							[DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
							\id:parse parser;
							\list:append id;
							\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
								\parser:gotoNextToken;
							} stop;
						} *{
							\maybeDerivativeList:ifNothing missingId;
							\maybeDerivativeList:ifIs *([List<[DainaGeneralIdentifier]>] derivativeList) {
								\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
									\parser:gotoNextToken;
									\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
										[DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
										\id:parse parser;
										\list:append id;
										\derivativeList:append id;
										\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketClose) *{
											\parser:gotoNextToken;
											\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
												\parser:gotoNextToken;
											} stop;
										} *{
											\parser:addError (\[Error]:expectingClosingBracketForDependancyWithDerivatives (\parser:position));
											\stop;
										};
									} missingId;
								} missingId;
							};
						} 	!{ 
								[->] missingId = *{
									\parser:addError (\missingIDError (\parser:position));
									\stop;
								}
							};
					};
				} *{};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketClose) *{
					\parser:gotoNextToken;
				} *{
					\parser:addError (\[Error]:expectingClosingBracketForDependancyList (\parser:position));
				};
			};
	   	}
}


[DainaGeneralIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}

[DainaClassIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}


[DainaType :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Integer,
			Maybe,
			String,
			Error, M, O,
			Variable,
			DainaClassIdentifier,
			DainaGeneralIdentifier,

			Debug
		)
	[[[DainaClassIdentifier][List<[DainaType]>]->]->] ifClassNameAndGenericInstantiation

	[[[List<[DainaType]>][Maybe<[DainaType]>]->]->] ifMethodInputsAndOutput
	[[[List<[DainaType]>]->]->] ifDisjoint
	[[[DainaGeneralIdentifier]->]->] ifClassGeneric
	[[[Integer][DainaGeneralIdentifier]->]->] ifMethodGenericLevelAndIdentifier
	[[[DainaGeneralIdentifier]->]->] ifDataSegment
	[[->]->] ifInferredMethod
	[[->]->] ifInferredSelf
	[[->]->] ifInferred
	[[[Integer]->]->] ifInferredParent
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		.ifClassNameAndGenericInstantiation = *([]a){};

		.ifMethodInputsAndOutput = *([]a){};
		.ifDisjoint = *([]a){};
		.ifClassGeneric = *([]a){};
		.ifMethodGenericLevelAndIdentifier = *([]a){};
		.ifDataSegment = *([]a){};
		.ifInferredMethod = *([]a){};
		.ifInferredSelf = *([]a){};
		.ifInferredParent = *([]a){};
		.ifInferred = *([->]a){\a};
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				[DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
				\className:parse parser;
				[List<[DainaType]>] genericInstantiations = \[List<[DainaType]>]:empty;
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
					\parser:gotoNextToken;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] genericInstantiation = \[DainaType]:base;
							\genericInstantiation:parse parser;
							\genericInstantiations:append genericInstantiation;
							\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{} stop;
						} *{
							\parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
							\stop;
						};
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
						\parser:gotoNextToken;
					} *{
						\parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
					};
				} *{};
				.ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->] get) {\get className genericInstantiations};
			} *{
				@ bla my way through
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
						[DainaType] subtype = \[DainaType]:base;
						\subtype:parse parser;
					} *{
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow) *{
							\parser:gotoNextToken;
							.ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:nothing)};
						} *{
							\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) stop *{
								\parser:gotoNextToken;
							};
						};
					};
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
			};
		} *{
			\parser:addError (\[Error]:expectingType (\parser:position));
		};
	}
}


[DainaObjectDeclaration :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaType,
			DainaGeneralIdentifier,

			Debug
		)
	[DainaType] type
	[DainaGeneralIdentifier] identifier
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Boolean]:or (\[DainaType]:isFirstToken token) (\[DainaGeneralIdentifier]:isFirstToken token))

	~ base *{
		.type = \[DainaType]:base;
		.identifier = \[DainaGeneralIdentifier]:base;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
		} *{
			\.type:parse parser;
			\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
				\.identifier:parse parser;
			} *{
				\parser:addError (\[Error]:expectingIdentifierForObjectDeclaration (\parser:position));
			};
		};
	}
}


@class-method-classification identifier ( type | expression )

@    class-method-classification: ( ( | | || )? method-visibility-indicator ) | ( ( ~ | :: ) ( | )? ( method-visibility-indicator )? )


[DainaClassMethod :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,
			Variable,
			DainaExpression,
			DainaType,

			Debug
		)
	[Variable<[Boolean]>] unimplementedMethod
	[DainaGeneralIdentifier] identifier
	[DainaExpression] methodExpression
	[[->][->][->]->] isInstanceTypeOrConstructor
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Boolean]:or (\[Boolean]:or (\[Token]:isVisibilityIndicator token) (\[Token]:equals token (\[Token]:pipe))) (\[Boolean]:or (\[Token]:equals token (\[Token]:doubleColon)) (\[Token]:equals token (\[Token]:tilde))))

	~ base *{
		.isInstanceTypeOrConstructor = *([->]a,[]b,[]c){};
		.methodExpression = \[DainaExpression]:base;
		.identifier = \[DainaGeneralIdentifier]:base;
		.unimplementedMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		\::new;
	}

	++ parse *([Parser] parser) {
		.isInstanceTypeOrConstructor = *([->]a,[]b,[]c){\a};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:tilde)) *{
			\parser:gotoNextToken;
			.isInstanceTypeOrConstructor = *([]a,[]b,[->]c){\c};
		} *{
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:doubleColon)) *{
				\parser:gotoNextToken;
				.isInstanceTypeOrConstructor = *([]a,[->]b,[]c){\b};
			} *{};
		};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:pipe)) *{
			\parser:gotoNextToken;
		} *{};
		\.isInstanceTypeOrConstructor *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingVisibilityIndicatorForInstanceMethod (\parser:position));
			};
		} *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{};
		} *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{};
		};
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
			\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
				\.unimplementedMethod:set (\[Boolean]:true); 
				[DainaType] typeForUnimplemented = \[DainaType]:base;
				\typeForUnimplemented:parse parser;
			} *{
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\.methodExpression:parse parser;
				} *{
					\parser:addError (\[Error]:expectingClassMethodExpression (\parser:position));
				};
			};
		} *{
			\parser:addError (\[Error]:expectingIdentifierForClassMethod (\parser:position));
		};
	}
}


[DainaExpression :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaObjectDeclaration,
			DainaType,
			Variable,

			Debug
		)
	[[[List<[DainaExpression]>]->]->] ifStatementBody
	[[[String]->]->] ifDataSegment
	[[[DainaExpression][DainaExpression]->]->] ifWithPrologueStatement
	[[[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->]->] ifMethodExpression
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Boolean]:or (\[Token]:isDataSegment token) (\[Token]:equals token (\[Token]:asterisk)))

	~ base *{
		.ifStatementBody = *([[List<[DainaExpression]>]->]get){\get (\[List<[DainaExpression]>]:empty)};
		.ifDataSegment = *([]a){};
		.ifWithPrologueStatement = *([]a){};
		.ifMethodExpression = *([]a){};

		\::new;
	}

	++ ifStatementBody *([[List<[DainaExpression]>]->] get) {\.ifStatementBody get}
	++ ifDataSegment *([[String]->] get) {\.ifDataSegment get}
	++ ifWithPrologueStatement *([[DainaExpression][DainaExpression]->] get) {\.ifWithPrologueStatement get}
	++ ifMethodExpression *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {\.ifMethodExpression get}

	- copy *([DainaExpression] other) {
		.ifStatementBody = other:ifStatementBody;
		.ifDataSegment = other:ifDataSegment;
		.ifWithPrologueStatement = other:ifWithPrologueStatement;
		.ifMethodExpression = other:ifMethodExpression;
	}

	++ parse *([Parser] parser) {
		[DainaExpression] left = \[DainaExpression]:base;
		\left:parseStrongBinding parser;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:exclamationMark) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
				[DainaExpression] right = \[DainaExpression]:base;
				\right:parse parser;
				.ifWithPrologueStatement = *([[DainaExpression][DainaExpression]->] get) {\get left right};
			} *{
				\parser:addError (\[Error]:expectingPrologueStatement (\parser:position));
			};
		} *{
			\:copy left;
		};
	}

	++ @@-+-@@ parseStrongBinding *([Parser] parser) {
		\[O]:ifElse (\[Token]:isDataSegment (\parser:token)) *{
			[Token] token1 = (\parser:token);
			.ifDataSegment = *([[String]->] get) {\get (\token1:content)};
			\parser:gotoNextToken;
		} *{};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:asterisk)) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketOpen)) *{
				\parser:gotoNextToken;
				[List<[DainaObjectDeclaration]>] parameters = \[List<[DainaObjectDeclaration]>]:empty;
				[DainaExpression] body = \[DainaExpression]:base;
				[Variable<[Maybe<[DainaExpression]>]>] output = \[Variable<[Maybe<[DainaExpression]>]>]:as (\[Maybe<[DainaExpression]>]:nothing);
				.ifMethodExpression = *([[List<[DainaObjectDeclaration]>][DainaExpression][Maybe<[DainaExpression]>]->] get) {
					\get parameters body (\output:get);
				};
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
						[DainaObjectDeclaration] parameter = \[DainaObjectDeclaration]:base;
						\parameter:parse parser;
						\parameters:append parameter;
					} *{
						\parser:addError (\[Error]:expectingMethodInput (\parser:position));
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:comma)) (parser:gotoNextToken) stop;
				};
				\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:roundBracketClose)) *{
					\parser:gotoNextToken;
				} *{
					\parser:addError (\[Error]:expectingClosingBracketForMethodInputs (\parser:position));
				};
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\body:parse parser;
				} *{
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
						\parser:gotoNextToken;
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] outputType = \[DainaType]:base;
							\outputType:parse parser;
							\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
								\body:parse parser;
							} *{
								\parser:addError (\[Error]:expectingMethodBody (\parser:position));
							};
							\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
								\parser:gotoNextToken;
							} *{
								\parser:addError (\[Error]:expectingMethodOutput (\parser:position));
							};
						} *{};
						\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
							[DainaExpression] outputExpression = \[DainaExpression]:base;
							\outputExpression:parse parser;
							\output:set (\[Maybe<[DainaExpression]>]:as outputExpression);
						} *{
							\parser:addError (\[Error]:expectingMethodOutput (\parser:position));
						};
					} *{};
				};
			} *{};
		} *{};
	}
}

@@

@ method-invocation    
		@ assignment-statement
		@ proxy-object
expression: ( compiler-injection | statement-group | object-method | grouped-expression | type-method | object-identifier | internal-instance-method | internal-instance-object | self-reference | method-self-reference | anonymous-class-object ) (  )?

   .
   id
   $
   :
   <<
   [type]
   {}
   ()
   ^
   \
   *^
   *-
   [:[...]]



expression: ( data-segment | compiler-injection | assignment-statement | statement-group | object-method | proxy-object | method-expression | grouped-expression | method-invocation | type-method | object-identifier | internal-instance-method | internal-instance-object | self-reference | method-self-reference | anonymous-class-object ) ( prologue-statement )?

    object-method: expression : identifier
    proxy-object syntax description: *- expression
    grouped-expression: ( type-cast )? ( expression )
        type-cast: type
    type-method: type : identifier
    object-identifier: identifier
    self-reference: ^
    method-self-reference: *^



All the different expressions can be combined in a compound way. Various constructs have different binding strength. The following list shows constructs in order of binding strength from weakest to strongest.

   1 ! binding to the preceeding expression and the following statement (as in a prologue statement for an expression)
   2 = binding to the left hand side and the next expression, \ binding to the following one or more expressions (as in invoking a method and the corresponding inputs), -> binding to the next expression (as in the output of a method), *- binding to the next expression (as in the object of which to form an object proxy) and * binding to the lone statement or statement group of a method which may be preceeded by a method input list (see flexible method expression)
   3 : binding to the following identifier and sometimes the preceeding type or expression (as in a type method or an instance method) cast
   4 A type (such as [Foo]) binding to an object name in an assignment or to an expression as in type casting.
   5 All other symbols; such as ., $, $$, :~ and $$~

   


A construct will bind stronger then a preceeding construct at the same binding level indicated by the above list. In other words, an ! will bind stronger then all other ! which preceeded it, and a -> will bind stronger then all other \ which preceeded it.

@@

[DainaCompilerInjection :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,

			Debug
		)
	[DainaGeneralIdentifier] identifier
	[String] dataSegment
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:doubleLessThan)

	~ base *{
		.identifier = \[DainaGeneralIdentifier]:base;
		.dataSegment = \[String]:as "";
		\::new;
	}

	++ parse *([Parser] parser) {
		\parser:gotoNextToken;
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
			\[O]:ifElse (\[Token]:isDataSegment (\parser:token)) *{
				[Token] token = (\parser:token);
				.dataSegment = \token:content;
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingDataSegmentForCompilerInjection (\parser:position));
			};
		} *{
			\parser:addError (\[Error]:expectingIdentifierForCompilerInjection (\parser:position));
		};
	}
}






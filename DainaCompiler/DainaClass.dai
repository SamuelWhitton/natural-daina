



[DainaClass :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,

			Debug
		)
	[Variable<[Boolean]>] isEntryPointClass
	[DainaDependancyStructure] dependancyStructure
	[DainaExpression] entryPointMethod
	[DainaClassIdentifier] className
	[DainaGenericDeclarationList] genericDeclarationList
	[List<[DainaType]>] inheritedParentTypes
	[List<[DainaObjectDeclaration]>] instanceObjects
	[List<[DainaClassMethod]>] classMethods
	[List<[DainaCompilerInjection]>] compilerInjections
{
	:: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
		[List<[DainaClass]>] classes = \[List<[DainaClass]>]:empty;
		\[Loops]:until *([->] stop) {
			\[O]:ifElse (\[DainaClass]:isFirstToken (\parser:token)) *{
				[DainaClass] class = \[DainaClass]:base;
				\class:parse parser;
				\classes:append class;
				@\[O]:ifElse (\parser:hasErrors) stop *{};
			} *{	
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:EOF) *{} *{
					\parser:addError (\[Error]:expectingClassAtTopLevel (\parser:position));
				};
				\stop;
			};
		};

		@@\[Loops]:while (*->[Boolean]{[Maybe<[Token]>] token = \parser:token;}->\token:is (*([]a)->\[Boolean]:true)) *{
			[Maybe<[Token]>] maybeToken = \parser:token;
			\maybeToken:ifIs *([Token] token) {
				@\[Debug]:log (\token:asDebugString);
				@\[Debug]:log (\[String]:as "\n");
			};
			\parser:gotoNextToken;
		}@@
	} -> classes

	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		.isEntryPointClass = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.dependancyStructure = \[DainaDependancyStructure]:base;
		.entryPointMethod = \[DainaExpression]:base;
		.className = \[DainaClassIdentifier]:base;
		.genericDeclarationList = \[DainaGenericDeclarationList]:base;
		.inheritedParentTypes = \[List<[DainaType]>]:empty;
		.instanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
		.classMethods = \[List<[DainaClassMethod]>]:empty;
		.compilerInjections = \[List<[DainaCompilerInjection]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\parser:gotoNextToken;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
			\.isEntryPointClass:set (\[Boolean]:true);
			\parser:gotoNextToken;
			\.dependancyStructure:parse parser;
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\.entryPointMethod:parse parser;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
						\parser:gotoNextToken;
					} *{	
						\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingEntryPointMethod (\parser:position));	
				};
			} *{
				\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));	
			};
		} *{	
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				\.className:parse parser;
				\.genericDeclarationList:parse parser;
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
						\parser:gotoNextToken;
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] parentType = \[DainaType]:base;
							\parentType:parse parser;
							\.inheritedParentTypes:append parentType;
						} *{	
							\parser:addError (\[Error]:expectingParentType (\parser:position));
							\stop;
						};
					} stop;
				};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
					\parser:gotoNextToken;
					\.dependancyStructure:parse parser;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
							[DainaObjectDeclaration] instanceObject = \[DainaObjectDeclaration]:base;
							\instanceObject:parse parser;
							\.instanceObjects:append instanceObject;
						} stop;
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
						\parser:gotoNextToken;
						\[Loops]:until *([->] stop) {
							\[O]:ifElse (\[DainaClassMethod]:isFirstToken (\parser:token)) *{
								[DainaClassMethod] classMethod = \[DainaClassMethod]:base;
								\classMethod:parse parser;
								\.classMethods:append classMethod;
							} *{
								\[O]:ifElse (\[DainaCompilerInjection]:isFirstToken (\parser:token)) *{
									[DainaCompilerInjection] compilerInjection = \[DainaCompilerInjection]:base;
									\compilerInjection:parse parser;
									\.compilerInjections:append compilerInjection;
								} stop;
							};
						};
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
							\parser:gotoNextToken;
						} *{	
							\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
						};
					} *{
						\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));
					};
				} *{	
					\parser:addError (\[Error]:expectingClosingSquareBracketAfterClassHeader (\parser:position));
				};
			} *{
				\parser:addError (\[Error]:expectingClassName (\parser:position));	
			};	
		};
	}
}

[DainaGenericDeclarationList :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] generics
{
	~ base *{
		.generics = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
			\parser:gotoNextToken;
			\[Loops]:until *([->] stop) {
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					[DainaGeneralIdentifier] generic = \[DainaGeneralIdentifier]:base;
					\generic:parse parser;
					\.generics:append generic;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
						\parser:gotoNextToken;
					} stop;
				} *{
					\parser:addError (\[Error]:expectingGenericIdentifier (\parser:position));
					\stop;
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForGenericDeclarationList (\parser:position));
			};
		} *{};
	}
}


[DainaDependancyStructure :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,
			SourcePosition,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] dependancies
	[List<[DainaGeneralIdentifier]>] dependanciesWithDerivatives
	[List<[DainaGeneralIdentifier]>] reverseDependancies
{
	~ base *{
		.dependancies = \[List<[DainaGeneralIdentifier]>]:empty;
		.reverseDependancies = \[List<[DainaGeneralIdentifier]>]:empty;
		.dependanciesWithDerivatives = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
			\parseIDList .dependancies ([Error]:expectingDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:as .dependanciesWithDerivatives);
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:arrow)) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
					\parseIDList .reverseDependancies ([Error]:expectingReverseDependancy) (\[Maybe<[List<[DainaGeneralIdentifier]>]>]:nothing);
				} *{
					\parser:addError (\[Error]:expectingReverseDependancyList (\parser:position));
				};
			} *{};
		} *{};
	} 	!{
			[[List<[DainaGeneralIdentifier]>][[SourcePosition]->[Error]][Maybe<[List<[DainaGeneralIdentifier]>]>]->] parseIDList = *([List<[DainaGeneralIdentifier]>] list, [[SourcePosition]->[Error]] missingIDError, [Maybe<[List<[DainaGeneralIdentifier]>]>] maybeDerivativeList) {
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
							[DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
							\id:parse parser;
							\list:append id;
							\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
								\parser:gotoNextToken;
							} stop;
						} *{
							\maybeDerivativeList:ifNothing missingId;
							\maybeDerivativeList:ifIs *([List<[DainaGeneralIdentifier]>] derivativeList) {
								\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketOpen) *{
									\parser:gotoNextToken;
									\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
										[DainaGeneralIdentifier] id = \[DainaGeneralIdentifier]:base;
										\id:parse parser;
										\list:append id;
										\derivativeList:append id;
										\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketClose) *{
											\parser:gotoNextToken;
											\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
												\parser:gotoNextToken;
											} stop;
										} *{
											\parser:addError (\[Error]:expectingClosingBracketForDependancyWithDerivatives (\parser:position));
											\stop;
										};
									} missingId;
								} missingId;
							};
						} 	!{ 
								[->] missingId = *{
									\parser:addError (\missingIDError (\parser:position));
									\stop;
								}
							};
					};
				} *{};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:roundBracketClose) *{
					\parser:gotoNextToken;
				} *{
					\parser:addError (\[Error]:expectingClosingBracketForDependancyList (\parser:position));
				};
			};
	   	}
}


[DainaGeneralIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}

[DainaClassIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}


[DainaType :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Integer,
			Maybe,
			String,
			Error, M, O,
			Variable,
			DainaClassIdentifier,
			DainaGeneralIdentifier,

			Debug
		)
	[[[DainaClassIdentifier][List<[DainaType]>]->]->] ifClassNameAndGenericInstantiation

	[[[List<[DainaType]>][Maybe<[DainaType]>]->]->] ifMethodInputsAndOutput
	[[[List<[DainaType]>]->]->] ifDisjoint
	[[[DainaGeneralIdentifier]->]->] ifClassGeneric
	[[[Integer][DainaGeneralIdentifier]->]->] ifMethodGenericLevelAndIdentifier
	[[[DainaGeneralIdentifier]->]->] ifDataSegment
	[[->]->] ifInferredMethod
	[[->]->] ifInferredSelf
	[[[Integer]->]->] ifInferredParent
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		.ifClassNameAndGenericInstantiation = *([]a){};

		.ifMethodInputsAndOutput = *([]a){};
		.ifDisjoint = *([]a){};
		.ifClassGeneric = *([]a){};
		.ifMethodGenericLevelAndIdentifier = *([]a){};
		.ifDataSegment = *([]a){};
		.ifInferredMethod = *([]a){};
		.ifInferredSelf = *([]a){};
		.ifInferredParent = *([]a){};
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
			\parser:gotoNextToken;
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				[DainaClassIdentifier] className = \[DainaClassIdentifier]:base;
				\className:parse parser;
				[List<[DainaType]>] genericInstantiations = \[List<[DainaType]>]:empty;
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
					\parser:gotoNextToken;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] genericInstantiation = \[DainaType]:base;
							\genericInstantiation:parse parser;
							\genericInstantiations:append genericInstantiation;
							\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{} stop;
						} *{
							\parser:addError (\[Error]:expectingOneOrMoreTypesForClassGenericInstantiation (\parser:position));
							\stop;
						};
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
						\parser:gotoNextToken;
					} *{
						\parser:addError (\[Error]:expectingClosingBracketForClassGenericInstantiations (\parser:position));
					};
				} *{};
				.ifClassNameAndGenericInstantiation = *([[DainaClassIdentifier][List<[DainaType]>]->] get) {\get className genericInstantiations};
			} *{
				@ bla my way through
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketOpen) *{
						[DainaType] subtype = \[DainaType]:base;
						\subtype:parse parser;
					} *{
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrow) *{
							\parser:gotoNextToken;
							.ifMethodInputsAndOutput = *([[List<[DainaType]>][Maybe<[DainaType]>]->] get) {\get (\[List<[DainaType]>]:empty) (\[Maybe<[DainaType]>]:nothing)};
						} *{
							\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) stop *{
								\parser:gotoNextToken;
							};
						};
					};
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForType (\parser:position));
			};
		} *{
			\parser:addError (\[Error]:expectingType (\parser:position));
		};
	}
}


[DainaObjectDeclaration :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaType,
			DainaGeneralIdentifier,

			Debug
		)
	[DainaType] type
	[DainaGeneralIdentifier] identifier
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[DainaType]:isFirstToken token)

	~ base *{
		.type = \[DainaType]:base;
		.identifier = \[DainaGeneralIdentifier]:base;
		\::new;
	}

	++ parse *([Parser] parser) {
		\.type:parse parser;
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
		} *{
			\parser:addError (\[Error]:expectingIdentifierForObjectDeclaration (\parser:position));
		};
	}
}


@class-method-classification identifier ( type | expression )

@    class-method-classification: ( ( | | || )? method-visibility-indicator ) | ( ( ~ | :: ) ( | )? ( method-visibility-indicator )? )


[DainaClassMethod :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,
			Variable,
			DainaExpression,
			DainaType,

			Debug
		)
	[Variable<[Boolean]>] unimplementedMethod
	[DainaGeneralIdentifier] identifier
	[DainaExpression] methodExpression
	[[->][->][->]->] isInstanceTypeOrConstructor
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Boolean]:or (\[Boolean]:or (\[Token]:isVisibilityIndicator token) (\[Token]:equals token (\[Token]:pipe))) (\[Boolean]:or (\[Token]:equals token (\[Token]:doubleColon)) (\[Token]:equals token (\[Token]:tilde))))

	~ base *{
		.isInstanceTypeOrConstructor = *([->]a,[]b,[]c){};
		.methodExpression = \[DainaExpression]:base;
		.identifier = \[DainaGeneralIdentifier]:base;
		.unimplementedMethod = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		\::new;
	}

	++ parse *([Parser] parser) {
		.isInstanceTypeOrConstructor = *([->]a,[]b,[]c){\a};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:tilde)) *{
			\parser:gotoNextToken;
			.isInstanceTypeOrConstructor = *([]a,[]b,[->]c){\c};
		} *{
			\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:doubleColon)) *{
				\parser:gotoNextToken;
				.isInstanceTypeOrConstructor = *([]a,[->]b,[]c){\b};
			} *{};
		};
		\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:pipe)) *{
			\parser:gotoNextToken;
		} *{};
		\.isInstanceTypeOrConstructor *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingVisibilityIndicatorForInstanceMethod (\parser:position));
			};
		} *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{};
		} *{
			\[O]:ifElse (\[Token]:isVisibilityIndicator (\parser:token)) *{
				\parser:gotoNextToken;
			} *{};
		};
		\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
			\.identifier:parse parser;
			\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
				\.unimplementedMethod:set (\[Boolean]:true); 
				[DainaType] typeForUnimplemented = \[DainaType]:base;
				\typeForUnimplemented:parse parser;
			} *{
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\.methodExpression:parse parser;
				} *{
					\parser:addError (\[Error]:expectingClassMethodExpression (\parser:position));
				};
			};
		} *{
			\parser:addError (\[Error]:expectingIdentifierForClassMethod (\parser:position));
		};
	}
}


[DainaExpression :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}






[DainaCompilerInjection :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}






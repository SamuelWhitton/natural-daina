



[DainaClass :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaDependancyStructure,
			DainaExpression,
			Variable,
			DainaClassIdentifier,
			DainaGenericDeclarationList,
			DainaType,
			DainaObjectDeclaration,
			DainaClassMethod,
			DainaCompilerInjection,

			Debug
		)
	[Variable<[Boolean]>] isEntryPointClass
	[DainaDependancyStructure] dependancyStructure
	[DainaExpression] entryPointMethod
	[DainaClassIdentifier] className
	[DainaGenericDeclarationList] genericDeclarationList
	[List<[DainaType]>] inheritedParentTypes
	[List<[DainaObjectDeclaration]>] instanceObjects
	[List<[DainaClassMethod]>] classMethods
	[List<[DainaCompilerInjection]>] compilerInjections
{
	:: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
		[List<[DainaClass]>] classes = \[List<[DainaClass]>]:empty;
		\[Loops]:until *([->] stop) {
			\[O]:ifElse (\[DainaClass]:isFirstToken (\parser:token)) *{
				[DainaClass] class = \[DainaClass]:base;
				\class:parse parser;
				\classes:append class;
				@\[O]:ifElse (\parser:hasErrors) stop *{};
			} *{	
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:EOF) *{} *{
					\parser:addError (\[Error]:expectingClassAtTopLevel (\parser:position));
				};
				\stop;
			};
		};

		@@\[Loops]:while (*->[Boolean]{[Maybe<[Token]>] token = \parser:token;}->\token:is (*([]a)->\[Boolean]:true)) *{
			[Maybe<[Token]>] maybeToken = \parser:token;
			\maybeToken:ifIs *([Token] token) {
				@\[Debug]:log (\token:asDebugString);
				@\[Debug]:log (\[String]:as "\n");
			};
			\parser:gotoNextToken;
		}@@
	} -> classes

	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> (\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		.isEntryPointClass = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.dependancyStructure = \[DainaDependancyStructure]:base;
		.entryPointMethod = \[DainaExpression]:base;
		.className = \[DainaClassIdentifier]:base;
		.genericDeclarationList = \[DainaGenericDeclarationList]:base;
		.inheritedParentTypes = \[List<[DainaType]>]:empty;
		.instanceObjects = \[List<[DainaObjectDeclaration]>]:empty;
		.classMethods = \[List<[DainaClassMethod]>]:empty;
		.compilerInjections = \[List<[DainaCompilerInjection]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\parser:gotoNextToken;
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
			\.isEntryPointClass:set (\[Boolean]:true);
			\parser:gotoNextToken;
			\.dependancyStructure:parse parser;
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
				\parser:gotoNextToken;
				\[O]:ifElse (\[DainaExpression]:isFirstToken (\parser:token)) *{
					\.entryPointMethod:parse parser;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
						\parser:gotoNextToken;
					} *{	
						\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
					};
				} *{
					\parser:addError (\[Error]:expectingEntryPointMethod (\parser:position));	
				};
			} *{
				\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));	
			};
		} *{	
			\[O]:ifElse (\[DainaClassIdentifier]:isFirstToken (\parser:token)) *{
				\.className:parse parser;
				\.genericDeclarationList:parse parser;
				\[Loops]:until *([->] stop) {
					\[O]:ifElse (\[Token]:equals (\parser:token) (\[Token]:colon)) *{
						\parser:gotoNextToken;
						\[O]:ifElse (\[DainaType]:isFirstToken (\parser:token)) *{
							[DainaType] parentType = \[DainaType]:base;
							\parentType:parse parser;
							\.inheritedParentTypes:append parentType;
						} *{	
							\parser:addError (\[Error]:expectingParentType (\parser:position));
							\stop;
						};
					} stop;
				};
				\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:squareBracketClose) *{
					\parser:gotoNextToken;
					\.dependancyStructure:parse parser;
					\[Loops]:until *([->] stop) {
						\[O]:ifElse (\[DainaObjectDeclaration]:isFirstToken (\parser:token)) *{
							[DainaObjectDeclaration] instanceObject = \[DainaObjectDeclaration]:base;
							\instanceObject:parse parser;
							\.instanceObjects:append instanceObject;
						} stop;
					};
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketOpen) *{
						\parser:gotoNextToken;
						\[Loops]:until *([->] stop) {
							\[O]:ifElse (\[DainaClassMethod]:isFirstToken (\parser:token)) *{
								[DainaClassMethod] classMethod = \[DainaClassMethod]:base;
								\classMethod:parse parser;
								\.classMethods:append classMethod;
							} *{
								\[O]:ifElse (\[DainaCompilerInjection]:isFirstToken (\parser:token)) *{
									[DainaCompilerInjection] compilerInjection = \[DainaCompilerInjection]:base;
									\compilerInjection:parse parser;
									\.compilerInjections:append compilerInjection;
								} stop;
							};
						};
						\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:curlyBracketClose) *{
							\parser:gotoNextToken;
						} *{	
							\parser:addError (\[Error]:expectingClosingBracketForClassBody (\parser:position));
						};
					} *{
						\parser:addError (\[Error]:expectingBodyOfClass (\parser:position));
					};
				} *{	
					\parser:addError (\[Error]:expectingClosingSquareBracketAfterClassHeader (\parser:position));
				};
			} *{
				\parser:addError (\[Error]:expectingClassName (\parser:position));	
			};	
		};
	}
}

[DainaGenericDeclarationList :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,
			DainaGeneralIdentifier,

			Debug
		)
	[List<[DainaGeneralIdentifier]>] generics
{
	~ base *{
		.generics = \[List<[DainaGeneralIdentifier]>]:empty;
		\::new;
	}

	++ parse *([Parser] parser) {
		\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketOpen) *{
			\parser:gotoNextToken;
			\[Loops]:until *([->] stop) {
				\[O]:ifElse (\[DainaGeneralIdentifier]:isFirstToken (\parser:token)) *{
					[DainaGeneralIdentifier] generic = \[DainaGeneralIdentifier]:base;
					\generic:parse parser;
					\.generics:append generic;
					\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:comma) *{
						\parser:gotoNextToken;
					} stop;
				} *{
					\parser:addError (\[Error]:expectingGenericIdentifier (\parser:position));
				};
			};
			\[O]:ifElse (\[Token]:equals (\parser:token) \[Token]:arrowBracketClose) *{
				\parser:gotoNextToken;
			} *{
				\parser:addError (\[Error]:expectingClosingBracketForGenericDeclarationList (\parser:position));
			};
		} *{};
	}
}


[DainaDependancyStructure :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}



[DainaExpression :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}


[DainaGeneralIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}

[DainaClassIdentifier :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String, Variable,
			Error, M, O,

			Debug
		)
	@[Variable<[Maybe<[String]>]>]
{
	:: isFirstToken *([Token] token) -> [Boolean] {
		[Variable<[Boolean]>] isIdentifier = \[Variable<[Boolean]>]:as \[Boolean]:false;
		\token:ifIdentifier *([String] s) {
			\isIdentifier:set \[Boolean]:true;
		};
	} -> (\isIdentifier:get)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		[Token] identifierToken = \parser:token;
		\identifierToken:ifIdentifier *([String] s) {
			@\isIdentifier:set \[Boolean]:true;
		};
		\parser:gotoNextToken;
	}
}


[DainaType :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}

[DainaObjectDeclaration :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}

[DainaClassMethod :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}

[DainaCompilerInjection :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,
			Error, M, O,

			Debug
		)
{
	:: isFirstToken *([Token] token) -> [Boolean] {
	} -> \[Boolean]:false@(\[Token]:equals token \[Token]:squareBracketOpen)

	~ base *{
		\::new;
	}

	++ parse *([Parser] parser) {
		

		
	}
}






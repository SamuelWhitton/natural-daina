
[Daina :[CommandReader]] (
			Configuration, 
			OutputStream, 
			InputStream, 
			Loops, 
			Variable, 
			Boolean, 
			CommandReader, 
			String,
			Commands,
			Parser,
			Error,
			DainaClass,
			List,
			Maybe,

			Debug
		) 
	[Configuration] configuration
	[Variable<[Boolean]>] exitReached
	[List<[DainaClass]>] parsedClasses
{

	:: run *([Configuration] configuration) {
		[Daina] daina = \[Daina]:init configuration;
		[Commands] commands = \[Commands]:from (\configuration:commandInput);
		\[Loops]:while (*->(\[Boolean]:not \daina:exitReached)) *{
			\commands:readNext daina;
		};
	}
	
	~ @@-+-@@ init *([Configuration] configuration) {
		\::interface;
		.exitReached = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.configuration = configuration;
		.parsedClasses = \[List<[DainaClass]>]:empty;
	}

	++@@-+-@@ exitReached *->[Boolean]{}-> \.exitReached:get

	|++ exit *{
		\.exitReached:set (\[Boolean]:true);
		\[Debug]:log (\[String]:as "Exit\n");
	}

	|++ parseSourceFile *([String] path) {
		\[Debug]:log (\[String]:as "parse from ");
		\[Debug]:log path;
		\[Debug]:log (\[String]:as "\n");

		[Maybe<[InputStream]>] maybeSourceInput = \.configuration:sourceFileInput path;
		[Boolean] sourceFileSuccess = \maybeSourceInput:is *([InputStream] sourceInput) -> [Boolean] {
			[Parser] parser = \[Parser]:withSourceNameAndInput path sourceInput;
			[List<[DainaClass]>] parsedClasses = \[DainaClass]:parseClasses parser;
			[List<[Error]>] errors = \parser:errors;
			[Boolean] parseSuccess = \errors:isEmpty;
			\parseSuccess:ifElse *{
				\parsedClasses:iterate *([DainaClass] parsedClass) {
					\.parsedClasses:append parsedClass;
				};
			} *{
				\errors:iterate *([Error] error) {
					\.configuration:outputError error;
				};
			};
		} -> \[Boolean]:true;
		\sourceFileSuccess:ifElse *{} *{
			\.configuration:outputError (\[Error]:sourceFileNotAccessible path);
		};
	}

	|++ compileToFile *([String] path) {
		\[Debug]:log (\[String]:as "compile to ");
		\[Debug]:log path;
		\[Debug]:log (\[String]:as "\n");

		
	}

	|++ invalidCommand *{
		\[Debug]:log (\[String]:as "Invalid command\n");
	}

}


[Parser] (
			InputStream,
			String,
			Maybe,
			List,
			Error,
			Character,
			Byte,
			Token,
			SourcePosition,
			Boolean,
			Variable,
			Loops,
			Data,
			Integer,

			Debug
		)
	[InputStream] sourceInput
	[List<[Error]>] errors
	[Variable<[Maybe<[Token]>]>] currentToken
	[Variable<[SourcePosition]>] currentTokenPosition
	[Maybe<[Character]>] currentCharacter
	[SourcePosition] currentCharacterPosition
	[List<[Character]>] buffer
{
	~ withSourceNameAndInput *([String] sourceName, [InputStream] sourceInput) {
		.sourceInput = sourceInput;
		.errors = \[List<[Error]>]:empty;
		.currentToken = \[Variable<[Maybe<[Token]>]>]:as (\[Maybe<[Token]>]:asNothing);
		.buffer = \[List<[Character]>]:empty;
		.currentCharacter = \[Maybe<[Character]>]:asNothing;
		[SourcePosition] initialPosition = \[SourcePosition]:initialPositionIn sourceName (\:getCopyOfNextLine);
		.currentCharacterPosition = initialPosition;
		.currentTokenPosition = \[Variable<[SourcePosition]>]:as initialPosition;
		\:gotoNextCharacter;
		\:gotoNextToken;
	}

	- getCopyOfNextLine *->[String] {
		[String] line = \:stringFromCharacters *([[Character]->] useCharacter) {
			\[Loops]:until *([->] stop) {
				[Maybe<[Character]>] nextChar = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
				\nextChar:ifIs *([Character] c) {
					\.buffer:append c;
					[Boolean] notEndOfLine = \[Boolean]:not (\c:isNewline);
					\notEndOfLine:ifElse *{
						\useCharacter c;
					} stop;
				};
				\nextChar:ifNothing stop;
			};
		};
	} -> line

	- stringFromCharacters *([[[Character]->]->] getCharacters) -> [String] {
				[Data] asciiStringData = \[Data]:dataFromBytesWithByteProvider (*([[Byte]->] useByte) {
					\getCharacters *([Character] character) {
						\useByte (\character:asASCIIByte);
					};
				});
			} -> \[String]:stringWithASCIIDataRepresentationOfString asciiStringData

	- gotoNextCharacter *{
		[Boolean] isNewline = \.currentCharacter:is *([Character] c) -> [Boolean] {} -> \c:isNewline;
		\isNewline:ifElse *{
			.currentCharacterPosition = \.currentCharacterPosition:startOfNextLine (\:getCopyOfNextLine);
		} *{
			.currentCharacterPosition = \.currentCharacterPosition:nextColumn;
		};
		[Maybe<[Character]>] bufferedChar = \.buffer:popFirst;
		.currentCharacter = bufferedChar;
		\bufferedChar:ifNothing *{
			.currentCharacter = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
		};
	}

	- eatWhitespaceCharacters *{
		\[Loops]:while (*->[Boolean]{
			[Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
			\.currentCharacter:ifIs *([Character] character) {
				\isWhitespace:set (\character:isWhitespace);
			};
		} -> \isWhitespace:get) (:gotoNextCharacter);
	}

	++ hasErrors *-> [Boolean] {} -> (\[Boolean]:not (\.errors:isEmpty))

    ++ errors *-> [List<[Error]>] {} -> .errors

    ++ addError *([Error] error) {
    	\.errors:append error;
    }

	++ token *->[Token] {
		[Variable<[Token]>] token = \[Variable<[Token]>]:as (\[Token]:EOF);
		[Maybe<[Token]>] m = \.currentToken:get;
		\m:ifIs *([Token] t) {\token:set t};
	} -> \token:get

	++ position *->[SourcePosition] {} -> \.currentTokenPosition:get

	++ gotoNextToken *{
		\.currentToken:set (\[Maybe<[Token]>]:asNothing);
		\:eatWhitespaceCharacters;

		\ifStrudelOrElse *{
			\[Loops]:while (*->\.currentCharacter:is (*([Character] c)->\c:isStrudel)) *{
				\:gotoNextCharacter;
				\ifStrudelOrElse *{
               		\:gotoNextCharacter;
                	[Variable<[Boolean]>] lastCharacterWasStrudel = \[Variable<[Boolean]>]:as (\[Boolean]:false);
               		\scanToken *([Character] thisCharacter, [->] continueScanning) {
               			\ifElse (thisCharacter:isStrudel) *{
               				\ifElse (lastCharacterWasStrudel:get) *{
               					\lastCharacterWasStrudel:set (\[Boolean]:false);
               					\:gotoNextCharacter;
               					\:eatWhitespaceCharacters;
               				} *{
               					\lastCharacterWasStrudel:set (\[Boolean]:true);
               					\continueScanning;
               				};
               			} *{
               				\lastCharacterWasStrudel:set (\[Boolean]:false);
               				\continueScanning;
               			};
					};
               	} *{
               		\scanToken *([Character] thisCharacter, [->] continueScanning) {
               			\ifElse (thisCharacter:isNewline) *{
               				\:eatWhitespaceCharacters;
               			} *{
               				\continueScanning;
               			};
					};
               	};
            };
        } *{};

		\.currentCharacter:ifIs *([Character] character1) {
			[SourcePosition] position1 = .currentCharacterPosition;
			\:gotoNextCharacter;
			
			[Boolean] isIdentifier = \[Boolean]:or (\character1:isAlphanumeric) (\character1:isUnderscore);
			\isIdentifier:ifElse *{
				[String] identifierString = \stringFromCharacters *([[Character]->] useCharacter) {
					\useCharacter character1;
					\scanToken *([Character] thisCharacter, [->] continueScanning) {
						[Boolean] thisCharacterIsForIdentifier = \[Boolean]:or (\thisCharacter:isAlphanumeric) (\thisCharacter:isUnderscore);
						\thisCharacterIsForIdentifier:ifElse *{\useCharacter thisCharacter;\continueScanning;} *{};
					};
				};
				\setToken position1 (\[Token]:identifier identifierString);
			} *{};

			\if (character1:isDollarSign) *{
               	[Variable<[Integer]>] repetitionCount = \[Variable<[Integer]>]:as (\[Integer]:one);
               	\scanToken *([Character] thisCharacter, [->] continueScanning) {
               		\ifElse (thisCharacter:isDollarSign) *{
               			\repetitionCount:set (\x:integerByAdding (\[Integer]:one)) !{[Integer] x = \repetitionCount:get};
               			\continueScanning;
               		} *{};
               	};
               	\setToken position1 (\[Token]:parentIdentifier (\repetitionCount:get));
            };

            \if (*->\[Boolean]:or (\character1:isDash) (\character1:isPlus)) *{
               	\ifPlusOrDashOrElse (\[Maybe<[Character]>]:as character1) *{
               		\ifPlusOrDashOrElse .currentCharacter *{
               			\:gotoNextCharacter;
               			\ifPlusOrDashOrElse .currentCharacter *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
               			} *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:false));
               			} *{
               				\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:true) (\[Boolean]:true));
               			};
               		} *{
               			\:gotoNextCharacter;
               			\ifPlusOrDashOrElse .currentCharacter *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:true));
               			} *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:true) (\[Boolean]:false) (\[Boolean]:false));
               			} *{
               				\:addError (\[Error]:invalidVisibilityIndicator position1);
               			};
               		} *{
               			\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
               		};
               	} *{
               		\ifPlusOrDashOrElse .currentCharacter *{
               			\:gotoNextCharacter;
               			\ifPlusOrDashOrElse .currentCharacter *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:true));
               			} *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:true) (\[Boolean]:false));
               			} *{
               				\:addError (\[Error]:invalidVisibilityIndicator position1);
               			};
               		} *{
               			\:gotoNextCharacter;
               			\ifPlusOrDashOrElse .currentCharacter *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:true));
               			} *{
               				\:gotoNextCharacter;\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
               			} *{
               				\:addError (\[Error]:invalidVisibilityIndicator position1);
               			};
               		} *{
               			\setToken position1 (\[Token]:visibilityIndicator (\[Boolean]:false) (\[Boolean]:false) (\[Boolean]:false));
               		};
               	} *{};
            };

			\.currentCharacter:ifIs *([Character] character2) {
				[SourcePosition] position2 = .currentCharacterPosition;
                \if (character1:isDash) *{
                		\if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:arrow)};
                	};
                \if (character1:isAsterisk) *{
                		\if (character2:isCaret) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskCaret)};
                		\if (character2:isDash) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskDash)};
                	};
               	 \if (character1:isColon) *{
                		\if (character2:isColon) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleColon)};
                	};
                \if (character1:isPipe) *{
                	\if (character2:isPipe) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doublePipe)};
                	};
                \if (character1:isArrowBracketOpen) *{
                		\if (character2:isArrowBracketOpen) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleLessThan)};
               		};
			};	

			\ifNoToken *{
				\if (character1:isAmpersand) *{\setToken position1 (\[Token]:ampersand)};
				\if (character1:isSingleApostrophe) *{\setToken position1 (\[Token]:singleApostrophe)};
				\if (character1:isArrowBracketOpen) *{\setToken position1 (\[Token]:arrowBracketOpen)};
				\if (character1:isArrowBracketClose) *{\setToken position1 (\[Token]:arrowBracketClose)};
				\if (character1:isAsterisk) *{\setToken position1 (\[Token]:asterisk)};
				\if (character1:isBackslash) *{\setToken position1 (\[Token]:backslash)};
				\if (character1:isCaret) *{\setToken position1 (\[Token]:caret)};
				\if (character1:isColon) *{\setToken position1 (\[Token]:colon)};
				\if (character1:isComma) *{\setToken position1 (\[Token]:comma)};
				\if (character1:isCurlyBracketOpen) *{\setToken position1 (\[Token]:curlyBracketOpen)};
				\if (character1:isCurlyBracketClose) *{\setToken position1 (\[Token]:curlyBracketClose)};
				\if (character1:isDoubleApostrophe) *{\setToken position1 (\[Token]:doubleApostrophe)};
				\if (character1:isEqualsSign) *{\setToken position1 (\[Token]:equalsSign)};
				\if (character1:isExclamationMark) *{\setToken position1 (\[Token]:exclamationMark)};
				\if (character1:isForwardslash) *{\setToken position1 (\[Token]:forwardSlash)};
				\if (character1:isFullstop) *{\setToken position1 (\[Token]:fullStop)};
				\if (character1:isPercentSign) *{\setToken position1 (\[Token]:percentSign)};
				\if (character1:isPipe) *{\setToken position1 (\[Token]:pipe)};
				\if (character1:isQuestionMark) *{\setToken position1 (\[Token]:questionMark)};
				\if (character1:isRoundBracketOpen) *{\setToken position1 (\[Token]:roundBracketOpen)};
				\if (character1:isRoundBracketClose) *{\setToken position1 (\[Token]:roundBracketClose)};
				\if (character1:isSemicolon) *{\setToken position1 (\[Token]:semicolon)};
				\if (character1:isSquareBracketOpen) *{\setToken position1 (\[Token]:squareBracketOpen)};
				\if (character1:isSquareBracketClose) *{\setToken position1 (\[Token]:squareBracketClose)};
				\if (character1:isTilde) *{\setToken position1 (\[Token]:tilde)};
			};
			
			\ifNoToken *{
				\:addError (\[Error]:unrecognisedToken (\character1:asString) position1);
			};
		};		
	} 	!{
			[[SourcePosition][Token]->] setToken = *([SourcePosition] position, [Token] token) {
				\.currentToken:set (\[Maybe<[Token]>]:as token);
				\.currentTokenPosition:set position;
			};
			[[->]->] ifNoToken = *([->] noToken) {
				(\currentToken:ifNothing noToken) !{[Maybe<[Token]>] currentToken = \.currentToken:get};
			};
			[[->[Boolean]][->]->] if = *([->[Boolean]] condition, [->] action) {
				[Boolean] result = \condition;
				\result:ifElse action *{};
			};
			[[->[Boolean]][->][->]->] ifElse = *([->[Boolean]] condition, [->] action, [->] else) {
				[Boolean] result = \condition;
				\result:ifElse action else;
			};
			[[[Character][->]->]->] scanToken = *([[Character][->]->] provideCharacterAndContinueScannning) {
				[Variable<[Boolean]>] continuing = \[Variable<[Boolean]>]:as (\[Boolean]:true);
				\[Loops]:while (continuing:get) *{
					\continuing:set (\[Boolean]:false);
					\.currentCharacter:ifIs *([Character] character) {
						\provideCharacterAndContinueScannning character *{
							\continuing:set (\[Boolean]:true);
							\:gotoNextCharacter;
						};
					};
				};
			};
			[[[[Character]->]->]->[String]] stringFromCharacters = *([[[Character]->]->] getCharacters) -> [String] {
				[Data] asciiStringData = \[Data]:dataFromBytesWithByteProvider (*([[Byte]->] useByte) {
					\getCharacters *([Character] character) {
						\useByte (\character:asASCIIByte);
					};
				});
			} -> \[String]:stringWithASCIIDataRepresentationOfString asciiStringData;
			[[->][->]->] ifStrudelOrElse = *([->] action, [->] else) {
				[Maybe<[Character]>] maybeCurrentCharacter = .currentCharacter;
				\maybeCurrentCharacter:ifIs *([Character] currentCharacter) {
					\ifElse (currentCharacter:isStrudel) action else;
				};
				\maybeCurrentCharacter:ifNothing else;
			};
			[[Maybe<[Character]>][->][->][->]->] ifPlusOrDashOrElse = *([Maybe<[Character]>] maybeChar, [->] plus, [->] dash, [->] else) {
				\maybeChar:ifNothing else;
				\maybeChar:ifIs *([Character] char) {
					\ifElse (char:isPlus) plus *{
						\ifElse (char:isDash) dash else;
					};
				};
			};
		}
}


[SourcePosition :[Object]] (
			Integer,
			String,
			Variable,
			Object,
			Loops
		)
	[String] sourceName
	[Integer] line
	[Integer] column
	[String] lineContent
{
	~ initialPositionIn *([String] sourceName, [String] lineContent) {
		\::lineAndColumnIn (\[Integer]:one) (\[Integer]:zero) sourceName lineContent;
	}

	~ @@-+-@@ lineAndColumnIn *([Integer] line, [Integer] column, [String] sourceName, [String] lineContent) {
		\::new;
		.sourceName = sourceName;
		.column = column;
		.line = line;
		.lineContent = lineContent;
	}

	++ asString *-> [String] {
		[String] colon = \[String]:as ":";
		[String] pos = \[String]:as " pos ";
		[String] line = \[String]:stringRepresentationOfInteger .line;
		[String] column = \[String]:stringRepresentationOfInteger .column;
		[String] tabulation = \[String]:as "\n    ";
		[Variable<[String]>] linePositionArrow = \[Variable<[String]>]:as (\[String]:as "");
		\[Loops]:repeatNTimes (\.column:integerBySubtracting (\[Integer]:one)) *{
			[String] curr = \linePositionArrow:get;
			\linePositionArrow:set (\curr:appending (\[String]:as " "));
		};
		[String] curr = \linePositionArrow:get;
		\linePositionArrow:set (\curr:appending (\[String]:as "^"));
	} -> (\.sourceName:appending (\colon:appending (\line:appending (\pos:appending (\column:appending (\tabulation:appending (\.lineContent:appending (\tabulation:appending (\linePositionArrow:get)))))))))

	++ nextColumn *-> [SourcePosition] {
	} -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Integer]:one)) (.sourceName) (.lineContent)

	++ startOfNextLine *([String] lineContent)-> [SourcePosition] {
	} -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Integer]:one)) (\[Integer]:one) (.sourceName) lineContent
}


[Error :[Object]] (Object, String, SourcePosition, List, Variable)
	[String] errorString
{
	++ asString *-> [String] {
		[String] errorPrefix = \[String]:as "ERROR; ";
	} -> (\errorPrefix:appending .errorString)

	~ @@-+-@@ as *([String] errorString) {
		\::new;
		.errorString = errorString;
	}

	~ @@-+-@@ errorWithContext *([String] errorString, [List<[SourcePosition]>] context) {
		\::new;
		[Variable<[String]>] errorWithContext = \[Variable<[String]>]:as errorString;
		\context:iterate *([SourcePosition] sourcePosition) {
			[String] addedContext = (\prefix:appending (\sourcePosition:asString)) !{
					[String] prefix = \[String]:as " - ";
				};
			\errorWithContext:set (\prefix:appending addedContext) !{
					[String] prefix = \errorWithContext:get;
				};
		};
		.errorString = \errorWithContext:get;
	}

	:: sourceFileNotAccessible *([String] fileName) -> [Error] {
		[String] prefix = \[String]:as "Source file not accessible: ";
	} -> (\[Error]:as (\prefix:appending fileName))

	:: unrecognisedToken *([String] token, [SourcePosition] position) -> [Error] {
		[String] prefix = \[String]:as "Unrecognised token: ";
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
		\context:append position;
	} -> (\[Error]:errorWithContext (\prefix:appending token) context)

	:: invalidVisibilityIndicator *([SourcePosition] position) -> [Error] {
		[String] error = \[String]:as "Invalid visibility indicator";
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
		\context:append position;
	} -> (\[Error]:errorWithContext error context)

	:: expectingClassAtTopLevel *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting class at top level") context)

	:: expectingBodyOfClass *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting body of class") context)

	:: expectingEntryPointMethod *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting entry point method") context)

	:: expectingClosingBracketForClassBody *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting closing bracket for class body") context)

	:: expectingClassName *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting class name") context)

	:: expectingParentType *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting parent type") context)

	:: expectingClosingSquareBracketAfterClassHeader *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting closing square bracket after class header") context)

	:: expectingGenericIdentifier *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting generic identifier") context)

	:: expectingClosingBracketForGenericDeclarationList *([SourcePosition] position) -> [Error] {
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty; \context:append position;
	} -> (\[Error]:errorWithContext (\[String]:as "Expecting closing bracket for generic declaration list") context)

	

}


[Token :[Object]] (
			Object,
			Integer,
			String,
			Boolean,
			Variable
		)
	[Integer] id
	[Integer] secondId
	[String] content
{
	~ @@-+-@@ basicToken *([Integer] id) {
		\::new;
		.id = id;
		.content = \[String]:as "";
		.secondId = \[Integer]:zero;
	}

	~ @@-+-@@ secondIdToken *([Integer] id, [Integer] secondId) {
		\::new;
		.id = id;
		.content = \[String]:as "";
		.secondId = secondId;
	}

	~ @@-+-@@ contentToken *([Integer] id, [String] content) {
		\::new;
		.id = id;
		.content = content;
		.secondId = \[Integer]:zero;
	}

	++ @@-+-@@ id *->[Integer] {} -> .id
	++ @@-+-@@ content *->[String] {} -> .content
	++ @@-+-@@ secondId *->[Integer] {} -> .secondId

	++ asDebugString *->[String] {
		[String] idString = \[String]:stringRepresentationOfInteger .id;
		[String] seperator = \[String]:as "~";
		[String] secondIDString = \[String]:stringRepresentationOfInteger .secondId;
	} -> (\idString:appending (\seperator:appending (\secondIDString:appending (\seperator:appending .content))))

	++ ifIdentifier *([[String]->] ifIdentifier) {
		[Token] idToken = \[Token]:identifier (\[String]:as "");
		[Boolean] isIdentifier = \.id:equals (\idToken:id);
		\isIdentifier:ifElse *{
			\ifIdentifier .content;
		} *{};
	}

	@++ equals *([Token] t) -> [Boolean] {
	@} -> (\[Boolean]:and (\[Boolean]:and (\.content:equals (\t:content)) (\.secondId:equals (\t:secondId))) (\.id:equals (\t:id)))

	:: equals *([Token] t, [Token] t2) -> [Boolean] {
		[String] content = \t2:content;
		[Integer] id = \t2:id;
		[Integer] secondId = \t2:secondId;
	} -> (\[Boolean]:and (\[Boolean]:and (\content:equals (\t:content)) (\secondId:equals (\t:secondId))) (\id:equals (\t:id)))

	:: visibilityIndicator *([Boolean] externalVisibility, [Boolean] classVisibility, [Boolean] inheritedVisibility) -> [Token] {
		[Variable<[Integer]>] visibility = \[Variable<[Integer]>]:as (\[Integer]:zero);
		\externalVisibility:ifElse (*{
				\visibility:set (\one:adding (\visibility:get));
			} !{[Integer] one = \[Integer]:one;}) *{};
		\classVisibility:ifElse (*{
				\visibility:set (\ten:adding (\visibility:get));
			} !{[Integer] ten = \[Integer]:newPositive 10;}) *{};
		\inheritedVisibility:ifElse (*{
				\visibility:set (\hundred:adding (\visibility:get));
			} !{[Integer] hundred = \[Integer]:newPositive 100;}) *{};
	} -> (\[Token]:secondIdToken (\[Integer]:newPositive 1) (\visibility:get))

	:: parentIdentifier *([Integer] repetitionCount) -> (\[Token]:secondIdToken (\[Integer]:newPositive 2) repetitionCount)
	:: identifier *([String] identifierString) -> (\[Token]:contentToken (\[Integer]:newPositive 3) identifierString)
	@:: dataSegment *([String] content) -> (\[Token]:contentToken (\[Integer]:newPositive 4) content)
	
	:: ampersand *-> (\[Token]:basicToken \[Integer]:newPositive 5)
	:: singleApostrophe *-> (\[Token]:basicToken \[Integer]:newPositive 6)
	:: arrow *-> (\[Token]:basicToken \[Integer]:newPositive 7)
	:: arrowBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 8)
	:: arrowBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 9)
	:: asterisk *-> (\[Token]:basicToken \[Integer]:newPositive 10)
	:: asteriskCaret *-> (\[Token]:basicToken \[Integer]:newPositive 11)
	:: asteriskDash *-> (\[Token]:basicToken \[Integer]:newPositive 12)
	:: backslash *-> (\[Token]:basicToken \[Integer]:newPositive 13)
	:: caret *-> (\[Token]:basicToken \[Integer]:newPositive 14)
	:: colon *-> (\[Token]:basicToken \[Integer]:newPositive 15)
	:: comma *-> (\[Token]:basicToken \[Integer]:newPositive 16)
	:: curlyBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 17)
	:: curlyBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 18)
	:: doubleApostrophe *-> (\[Token]:basicToken \[Integer]:newPositive 19)
	:: doubleColon *-> (\[Token]:basicToken \[Integer]:newPositive 20)
	:: doublePipe *-> (\[Token]:basicToken \[Integer]:newPositive 21)
	:: equalsSign *-> (\[Token]:basicToken \[Integer]:newPositive 23)
	:: exclamationMark *-> (\[Token]:basicToken \[Integer]:newPositive 24)
	:: forwardSlash *-> (\[Token]:basicToken \[Integer]:newPositive 25)
	:: fullStop *-> (\[Token]:basicToken \[Integer]:newPositive 26)
	:: percentSign *-> (\[Token]:basicToken \[Integer]:newPositive 27)
	:: pipe *-> (\[Token]:basicToken \[Integer]:newPositive 28)
	:: questionMark *-> (\[Token]:basicToken \[Integer]:newPositive 29)
	:: roundBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 30)
	:: roundBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 31)
	:: semicolon *-> (\[Token]:basicToken \[Integer]:newPositive 32)
	:: squareBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 33)
	:: squareBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 34)
	:: tilde *-> (\[Token]:basicToken \[Integer]:newPositive 36)
	:: doubleLessThan *-> (\[Token]:basicToken \[Integer]:newPositive 37)
	:: EOF *-> (\[Token]:basicToken \[Integer]:newPositive 38)
}











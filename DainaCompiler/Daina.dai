
[Daina :[CommandReader]] (
			Configuration, 
			OutputStream, 
			InputStream, 
			Loops, 
			Variable, 
			Boolean, 
			CommandReader, 
			String,
			Commands,
			Parser,
			Error,
			DainaClass,
			List,
			Maybe,

			Debug
		) 
	[Configuration] configuration
	[Variable<[Boolean]>] exitReached
	[List<[DainaClass]>] parsedClasses
{

	:: run *([Configuration] configuration) {
		[Daina] daina = \[Daina]:init configuration;
		[Commands] commands = \[Commands]:from (\configuration:commandInput);
		\[Loops]:while (*->(\[Boolean]:not \daina:exitReached)) *{
			\commands:readNext daina;
		};
	}
	
	~ @@-+-@@ init *([Configuration] configuration) {
		\::interface;
		.exitReached = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.configuration = configuration;
		.parsedClasses = \[List<[DainaClass]>]:empty;
	}

	++@@-+-@@ exitReached *->[Boolean]{}-> \.exitReached:get

	|++ exit *{
		\.exitReached:set (\[Boolean]:true);
		\[Debug]:log (\[String]:as "Exit\n");
	}

	|++ parseSourceFile *([String] path) {
		\[Debug]:log (\[String]:as "parse from ");
		\[Debug]:log path;
		\[Debug]:log (\[String]:as "\n");

		[Maybe<[InputStream]>] maybeSourceInput = \.configuration:sourceFileInput path;
		[Boolean] sourceFileSuccess = \maybeSourceInput:is *([InputStream] sourceInput) -> [Boolean] {
			[Parser] parser = \[Parser]:withSourceNameAndInput path sourceInput;
			[List<[DainaClass]>] parsedClasses = \[DainaClass]:parseClasses parser;
			[List<[Error]>] errors = \parser:errors;
			[Boolean] parseSuccess = \errors:isEmpty;
			\parseSuccess:ifElse *{
				\parsedClasses:iterate *([DainaClass] parsedClass) {
					\.parsedClasses:append parsedClass;
				};
			} *{
				\errors:iterate *([Error] error) {
					\.configuration:outputError error;
				};
			};
		} -> \[Boolean]:true;
		\sourceFileSuccess:ifElse *{} *{
			\.configuration:outputError (\[Error]:sourceFileNotAccessible path);
		};
	}

	|++ compileToFile *([String] path) {
		\[Debug]:log (\[String]:as "compile to ");
		\[Debug]:log path;
		\[Debug]:log (\[String]:as "\n");

		
	}

	|++ invalidCommand *{
		\[Debug]:log (\[String]:as "Invalid command\n");
	}

}


[Parser] (
			InputStream,
			String,
			Maybe,
			List,
			Error,
			Character,
			Byte,
			Token,
			SourcePosition,
			Boolean
		)
	[InputStream] sourceInput
	[List<[Error]>] errors
	[Maybe<[Token]>] currentToken
	[SourcePosition] currentTokenPosition
	[Maybe<[Character]>] currentCharacter
	[SourcePosition] currentCharacterPosition
{
	~ withSourceNameAndInput *([String] sourceName, [InputStream] sourceInput) {
		.sourceInput = sourceInput;
		.errors = \[List<[Error]>]:empty;
		.currentToken = \[Maybe<[Token]>]:asNothing;
		.currentCharacter = \[Maybe<[Character]>]:asNothing;
		[SourcePosition] initialPosition = \[SourcePosition]:initialPositionIn sourceName;
		.currentCharacterPosition = initialPosition;
		.currentTokenPosition = initialPosition;
		\:gotoNextCharacter;
		\:gotoNextToken;
	}

	- gotoNextCharacter *{
		[Boolean] isNewline = \.currentCharacter:is *([Character] c) -> [Boolean] {} -> \c:isNewline;
		\isNewline:ifElse *{
			.currentCharacterPosition = \.currentCharacterPosition:startOfNextLine;
		} *{
			.currentCharacterPosition = \.currentCharacterPosition:nextColumn;
		};
		.currentCharacter = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
	}

	++ gotoNextToken *{

	}

    ++ errors *-> [List<[Error]>] {} -> .errors

    ++ addError *([Error] error) {
    	\.errors:append error;
    }

	++ token *->[Maybe<[Token]>] {} -> .currentToken

	++ position *->[SourcePosition] {} -> .currentTokenPosition
}

[SourcePosition :[Object]] (
			Integer,
			String,
			Variable,
			Object
		)
	[String] sourceName
	[Integer] line
	[Integer] column
{
	~ initialPositionIn *([String] sourceName) {
		\::lineAndColumnIn (\[Integer]:one) (\[Integer]:zero) sourceName;
	}

	~ @@-+-@@ lineAndColumnIn *([Integer] line, [Integer] column, [String] sourceName) {
		\::new;
		.sourceName = sourceName;
		.column = column;
		.line = line;
	}

	++ nextColumn *-> [SourcePosition] {
	} -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Integer]:one)) (.sourceName)

	++ startOfNextLine *-> [SourcePosition] {
	} -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Integer]:one)) (\[Integer]:one) (.sourceName)
}


[Error :[Object]] (Object, String)
	[String] errorString 
{
	++ asString *-> [String] {} -> .errorString

	~ @@-+-@@ as *([String] errorString) {
		\::new;
		.errorString = errorString;
	}

	:: sourceFileNotAccessible *([String] fileName) -> [Error] {
		[String] prefix = \[String]:as "Source file not accessible: ";
	} -> \[Error]:as (\prefix:appending fileName)
}


[Token :[Object]] (
			Object,
			Integer,
			String,
			Boolean,
			Variable
		)
	[Integer] id
	[Integer] secondId
	[String] content
{
	~ @@-+-@@ basicToken *([Integer] id) {
		\::new;
		.id = id;
		.content = \[String]:as "";
		.secondId = \[Integer]:zero;
	}

	~ @@-+-@@ secondIdToken *([Integer] id, [Integer] secondId) {
		\::new;
		.id = id;
		.content = \[String]:as "";
		.secondId = secondId;
	}

	~ @@-+-@@ contentToken *([Integer] id, [String] content) {
		\::new;
		.id = id;
		.content = content;
		.secondId = \[Integer]:zero;
	}

	++ @@-+-@@ id *->[Integer] {} -> .id
	++ @@-+-@@ content *->[String] {} -> .content
	++ @@-+-@@ secondId *->[Integer] {} -> .secondId

	++ asDebugString *->[String] {
		[String] idString = \[String]:stringRepresentationOfInteger .id;
		[String] seperator = \[String]:as "~";
		[String] secondIDString = \[String]:stringRepresentationOfInteger .secondId;
	} -> \idString:appending (\seperator:appending (\secondIDString:appending (\seperator:appending .content)))

	++ equals *([Token] t) -> [Boolean] {
	} -> (\[Boolean]:and (\[Boolean]:and (\.content:equals (\t:content)) (\.secondId:equals (\t:secondId))) (\.id:equals (\t:id)))

	:: visibilityIndicator *([Boolean] externalVisibility, [Boolean] classVisibility, [Boolean] inheritedVisibility) -> [Token] {
		[Variable<[Integer]>] visibility = \[Variable<[Integer]>]:as (\[Integer]:zero);
		\externalVisibility:ifElse (*{
				\visibility:set (\one:adding (\visibility:get));
			} !{[Integer] one = \[Integer]:one;}) *{};
		\classVisibility:ifElse (*{
				\visibility:set (\ten:adding (\visibility:get));
			} !{[Integer] ten = \[Integer]:newPositive 10;}) *{};
		\inheritedVisibility:ifElse (*{
				\visibility:set (\hundred:adding (\visibility:get));
			} !{[Integer] hundred = \[Integer]:newPositive 100;}) *{};
	} -> (\[Token]:secondIdToken (\[Integer]:newPositive 1) (\visibility:get))

	:: parentIdentifier *([Integer] repetition) -> (\[Token]:secondIdToken (\[Integer]:newPositive 2) repetition)
	:: identifier *([String] content) -> (\[Token]:contentToken (\[Integer]:newPositive 3) content)
	@:: dataSegment *([String] content) -> (\[Token]:contentToken (\[Integer]:newPositive 4) content)
	
	:: ampersand *-> (\[Token]:basicToken \[Integer]:newPositive 5)
	:: singleApostrophe *-> (\[Token]:basicToken \[Integer]:newPositive 6)
	:: arrow *-> (\[Token]:basicToken \[Integer]:newPositive 7)
	:: arrowBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 8)
	:: arrowBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 9)
	:: asterisk *-> (\[Token]:basicToken \[Integer]:newPositive 10)
	:: asteriskCaret *-> (\[Token]:basicToken \[Integer]:newPositive 11)
	:: asteriskDash *-> (\[Token]:basicToken \[Integer]:newPositive 12)
	:: backslash *-> (\[Token]:basicToken \[Integer]:newPositive 13)
	:: caret *-> (\[Token]:basicToken \[Integer]:newPositive 14)
	:: colon *-> (\[Token]:basicToken \[Integer]:newPositive 15)
	:: comma *-> (\[Token]:basicToken \[Integer]:newPositive 16)
	:: curlyBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 17)
	:: curlyBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 18)
	:: doubleApostrophe *-> (\[Token]:basicToken \[Integer]:newPositive 19)
	:: doubleColon *-> (\[Token]:basicToken \[Integer]:newPositive 20)
	:: doublePipe *-> (\[Token]:basicToken \[Integer]:newPositive 21)
	:: doubleStrudel *-> (\[Token]:basicToken \[Integer]:newPositive 22)
	:: equalsSign *-> (\[Token]:basicToken \[Integer]:newPositive 23)
	:: exclamationMark *-> (\[Token]:basicToken \[Integer]:newPositive 24)
	:: forwardSlash *-> (\[Token]:basicToken \[Integer]:newPositive 25)
	:: fullStop *-> (\[Token]:basicToken \[Integer]:newPositive 26)
	:: percentSign *-> (\[Token]:basicToken \[Integer]:newPositive 27)
	:: pipe *-> (\[Token]:basicToken \[Integer]:newPositive 28)
	:: questionMark *-> (\[Token]:basicToken \[Integer]:newPositive 29)
	:: roundBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 30)
	:: roundBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 31)
	:: semicolon *-> (\[Token]:basicToken \[Integer]:newPositive 32)
	:: squareBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 33)
	:: squareBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 34)
	:: strudel *-> (\[Token]:basicToken \[Integer]:newPositive 35)
	:: tilde *-> (\[Token]:basicToken \[Integer]:newPositive 36)
	:: tripleLessThan *-> (\[Token]:basicToken \[Integer]:newPositive 37)
}


[DainaClass :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,

			Debug
		)
{
	:: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
		\[Loops]:while (*->[Boolean]{[Maybe<[Token]>] token = \parser:token;}->\token:is (*([]a)->\[Boolean]:true)) *{
			[Maybe<[Token]>] maybeToken = \parser:token;
			\maybeToken:ifIs *([Token] token) {
				\[Debug]:log (\token:asDebugString);
				\[Debug]:log (\[String]:as "\n");
			};
			\parser:gotoNextToken;
		}
	} -> \[List<[DainaClass]>]:empty
}










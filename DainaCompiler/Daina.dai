
[Daina :[CommandReader]] (
			Configuration, 
			OutputStream, 
			InputStream, 
			Loops, 
			Variable, 
			Boolean, 
			CommandReader, 
			String,
			Commands,
			Parser,
			Error,
			DainaClass,
			List,
			Maybe,

			Debug
		) 
	[Configuration] configuration
	[Variable<[Boolean]>] exitReached
	[List<[DainaClass]>] parsedClasses
{

	:: run *([Configuration] configuration) {
		[Daina] daina = \[Daina]:init configuration;
		[Commands] commands = \[Commands]:from (\configuration:commandInput);
		\[Loops]:while (*->(\[Boolean]:not \daina:exitReached)) *{
			\commands:readNext daina;
		};
	}
	
	~ @@-+-@@ init *([Configuration] configuration) {
		\::interface;
		.exitReached = \[Variable<[Boolean]>]:as (\[Boolean]:false);
		.configuration = configuration;
		.parsedClasses = \[List<[DainaClass]>]:empty;
	}

	++@@-+-@@ exitReached *->[Boolean]{}-> \.exitReached:get

	|++ exit *{
		\.exitReached:set (\[Boolean]:true);
		\[Debug]:log (\[String]:as "Exit\n");
	}

	|++ parseSourceFile *([String] path) {
		\[Debug]:log (\[String]:as "parse from ");
		\[Debug]:log path;
		\[Debug]:log (\[String]:as "\n");

		[Maybe<[InputStream]>] maybeSourceInput = \.configuration:sourceFileInput path;
		[Boolean] sourceFileSuccess = \maybeSourceInput:is *([InputStream] sourceInput) -> [Boolean] {
			[Parser] parser = \[Parser]:withSourceNameAndInput path sourceInput;
			[List<[DainaClass]>] parsedClasses = \[DainaClass]:parseClasses parser;
			[List<[Error]>] errors = \parser:errors;
			[Boolean] parseSuccess = \errors:isEmpty;
			\parseSuccess:ifElse *{
				\parsedClasses:iterate *([DainaClass] parsedClass) {
					\.parsedClasses:append parsedClass;
				};
			} *{
				\errors:iterate *([Error] error) {
					\.configuration:outputError error;
				};
			};
		} -> \[Boolean]:true;
		\sourceFileSuccess:ifElse *{} *{
			\.configuration:outputError (\[Error]:sourceFileNotAccessible path);
		};
	}

	|++ compileToFile *([String] path) {
		\[Debug]:log (\[String]:as "compile to ");
		\[Debug]:log path;
		\[Debug]:log (\[String]:as "\n");

		
	}

	|++ invalidCommand *{
		\[Debug]:log (\[String]:as "Invalid command\n");
	}

}


[Parser] (
			InputStream,
			String,
			Maybe,
			List,
			Error,
			Character,
			Byte,
			Token,
			SourcePosition,
			Boolean,
			Variable,
			Loops,
			Data,
			Integer,

			Debug
		)
	[InputStream] sourceInput
	[List<[Error]>] errors
	[Variable<[Maybe<[Token]>]>] currentToken
	[Variable<[SourcePosition]>] currentTokenPosition
	[Maybe<[Character]>] currentCharacter
	[SourcePosition] currentCharacterPosition
{
	~ withSourceNameAndInput *([String] sourceName, [InputStream] sourceInput) {
		.sourceInput = sourceInput;
		.errors = \[List<[Error]>]:empty;
		.currentToken = \[Variable<[Maybe<[Token]>]>]:as (\[Maybe<[Token]>]:asNothing);
		.currentCharacter = \[Maybe<[Character]>]:asNothing;
		[SourcePosition] initialPosition = \[SourcePosition]:initialPositionIn sourceName;
		.currentCharacterPosition = initialPosition;
		.currentTokenPosition = \[Variable<[SourcePosition]>]:as initialPosition;
		\:gotoNextCharacter;
		\:gotoNextToken;
	}

	- gotoNextCharacter *{
		[Boolean] isNewline = \.currentCharacter:is *([Character] c) -> [Boolean] {} -> \c:isNewline;
		\isNewline:ifElse *{
			.currentCharacterPosition = \.currentCharacterPosition:startOfNextLine;
		} *{
			.currentCharacterPosition = \.currentCharacterPosition:nextColumn;
		};
		.currentCharacter = \[Maybe<[Byte][Character]>]:map ([Character]:asASCII) (\.sourceInput:readNextByte);
	}

	- eatWhitespaceCharacters *{
		\[Loops]:while (*->[Boolean]{
			[Variable<[Boolean]>] isWhitespace = \[Variable<[Boolean]>]:as (\[Boolean]:false);
			\.currentCharacter:ifIs *([Character] character) {
				\isWhitespace:set (\character:isWhitespace);
			};
		} -> \isWhitespace:get) (:gotoNextCharacter);
	}

    ++ errors *-> [List<[Error]>] {} -> .errors

    ++ addError *([Error] error) {
    	\.errors:append error;
    }

	++ token *->[Maybe<[Token]>] {} -> \.currentToken:get

	++ position *->[SourcePosition] {} -> \.currentTokenPosition:get

	++ gotoNextToken *{
		\.currentToken:set (\[Maybe<[Token]>]:asNothing);
		\:eatWhitespaceCharacters;

		\ifStrudelOrElse *{
			\[Loops]:while (*->\.currentCharacter:is (*([Character] c)->\c:isStrudel)) *{
				\:gotoNextCharacter;
				\ifStrudelOrElse *{
               		\:gotoNextCharacter;
                	[Variable<[Boolean]>] lastCharacterWasStrudel = \[Variable<[Boolean]>]:as (\[Boolean]:false);
               		\scanToken *([Character] thisCharacter, [->] continueScanning) {
               			\ifElse (thisCharacter:isStrudel) *{
               				\ifElse (lastCharacterWasStrudel:get) *{
               					\lastCharacterWasStrudel:set (\[Boolean]:false);
               					\:gotoNextCharacter;
               					\:eatWhitespaceCharacters;
               				} *{
               					\lastCharacterWasStrudel:set (\[Boolean]:true);
               					\continueScanning;
               				};
               			} *{
               				\lastCharacterWasStrudel:set (\[Boolean]:false);
               				\continueScanning;
               			};
					};
               	} *{
               		\scanToken *([Character] thisCharacter, [->] continueScanning) {
               			\ifElse (thisCharacter:isNewline) *{
               				\:eatWhitespaceCharacters;
               			} *{
               				\continueScanning;
               			};
					};
               	};
            };
        } *{};

		\.currentCharacter:ifIs *([Character] character1) {
			[SourcePosition] position1 = .currentCharacterPosition;
			\:gotoNextCharacter;
			
			[Boolean] isIdentifier = \[Boolean]:or (\character1:isAlphanumeric) (\character1:isUnderscore);
			\isIdentifier:ifElse *{
				[String] identifierString = \stringFromCharacters *([[Character]->] useCharacter) {
					\useCharacter character1;
					\scanToken *([Character] thisCharacter, [->] continueScanning) {
						[Boolean] thisCharacterIsForIdentifier = \[Boolean]:or (\thisCharacter:isAlphanumeric) (\thisCharacter:isUnderscore);
						\thisCharacterIsForIdentifier:ifElse *{\useCharacter thisCharacter;\continueScanning;} *{};
					};
				};
				\setToken position1 (\[Token]:identifier identifierString);
			} *{};

			\if (character1:isDollarSign) *{
               	[Variable<[Integer]>] repetitionCount = \[Variable<[Integer]>]:as (\[Integer]:one);
               	\scanToken *([Character] thisCharacter, [->] continueScanning) {
               		\ifElse (thisCharacter:isDollarSign) *{
               			\repetitionCount:set (\x:integerByAdding (\[Integer]:one)) !{[Integer] x = \repetitionCount:get};
               			\continueScanning;
               		} *{};
               	};
               	\setToken position1 (\[Token]:parentIdentifier (\repetitionCount:get));
            };

            \if (*->\[Boolean]:or (\character1:isDash) (\character1:isPlus)) *{
               	\:gotoNextCharacter;
               	\.currentCharacter:ifIs *([Character] character2) {
               		\ifElse (*->\[Boolean]:or (\character2:isDash) (\character2:isPlus)) *{
						\:gotoNextCharacter;
               			\.currentCharacter:ifIs *([Character] character3) {
               				\ifElse (*->\[Boolean]:or (\character3:isDash) (\character3:isPlus)) *{
               					@ 3 +-+,...
               					\:gotoNextCharacter;
							} *{
								@ ++
							};
               			};
					} *{
						\ifElse (\character1:isDash) *{
							\setToken position1 (\[Token]:asteriskCaret)
						} *{

						};
						@ -, +
					};

					@\ifNoToken *{

					@};
               	};
               	\.currentCharacter:ifNothing 
            };

			\.currentCharacter:ifIs *([Character] character2) {
				[SourcePosition] position2 = .currentCharacterPosition;
                \if (character1:isDash) *{
                		\if (character2:isArrowBracketClose) *{\:gotoNextCharacter;\setToken position1 (\[Token]:arrow)};
                	};
                \if (character1:isAsterisk) *{
                		\if (character2:isCaret) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskCaret)};
                		\if (character2:isDash) *{\:gotoNextCharacter;\setToken position1 (\[Token]:asteriskDash)};
                	};
               	 \if (character1:isColon) *{
                		\if (character2:isColon) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleColon)};
                	};
                \if (character1:isPipe) *{
                	\if (character2:isPipe) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doublePipe)};
                	};
                \if (character1:isArrowBracketOpen) *{
                		\if (character2:isArrowBracketOpen) *{\:gotoNextCharacter;\setToken position1 (\[Token]:doubleLessThan)};
               		};
			};	

			\ifNoToken *{
				\if (character1:isAmpersand) *{\setToken position1 (\[Token]:ampersand)};
				\if (character1:isSingleApostrophe) *{\setToken position1 (\[Token]:singleApostrophe)};
				\if (character1:isArrowBracketOpen) *{\setToken position1 (\[Token]:arrowBracketOpen)};
				\if (character1:isArrowBracketClose) *{\setToken position1 (\[Token]:arrowBracketClose)};
				\if (character1:isAsterisk) *{\setToken position1 (\[Token]:asterisk)};
				\if (character1:isBackslash) *{\setToken position1 (\[Token]:backslash)};
				\if (character1:isCaret) *{\setToken position1 (\[Token]:caret)};
				\if (character1:isColon) *{\setToken position1 (\[Token]:colon)};
				\if (character1:isComma) *{\setToken position1 (\[Token]:comma)};
				\if (character1:isCurlyBracketOpen) *{\setToken position1 (\[Token]:curlyBracketOpen)};
				\if (character1:isCurlyBracketClose) *{\setToken position1 (\[Token]:curlyBracketClose)};
				\if (character1:isDoubleApostrophe) *{\setToken position1 (\[Token]:doubleApostrophe)};
				\if (character1:isEqualsSign) *{\setToken position1 (\[Token]:equalsSign)};
				\if (character1:isExclamationMark) *{\setToken position1 (\[Token]:exclamationMark)};
				\if (character1:isForwardslash) *{\setToken position1 (\[Token]:forwardSlash)};
				\if (character1:isFullstop) *{\setToken position1 (\[Token]:fullStop)};
				\if (character1:isPercentSign) *{\setToken position1 (\[Token]:percentSign)};
				\if (character1:isPipe) *{\setToken position1 (\[Token]:pipe)};
				\if (character1:isQuestionMark) *{\setToken position1 (\[Token]:questionMark)};
				\if (character1:isRoundBracketOpen) *{\setToken position1 (\[Token]:roundBracketOpen)};
				\if (character1:isRoundBracketClose) *{\setToken position1 (\[Token]:roundBracketClose)};
				\if (character1:isSemicolon) *{\setToken position1 (\[Token]:semicolon)};
				\if (character1:isSquareBracketOpen) *{\setToken position1 (\[Token]:squareBracketOpen)};
				\if (character1:isSquareBracketClose) *{\setToken position1 (\[Token]:squareBracketClose)};
				\if (character1:isTilde) *{\setToken position1 (\[Token]:tilde)};
			};
			
			\ifNoToken *{
				\:addError (\[Error]:invalidToken (\character1:asString) .currentCharacterPosition);
			};
		};		
	} 	!{
			[[SourcePosition][Token]->] setToken = *([SourcePosition] position, [Token] token) {
				\.currentToken:set (\[Maybe<[Token]>]:as token);
				\.currentTokenPosition:set position;
			};
			[[->]->] ifNoToken = *([->] noToken) {
				(\currentToken:ifNothing noToken) !{[Maybe<[Token]>] currentToken = \.currentToken:get};
			};
			[[->[Boolean]][->]->] if = *([->[Boolean]] condition, [->] action) {
				[Boolean] result = \condition;
				\result:ifElse action *{};
			};
			[[->[Boolean]][->][->]->] ifElse = *([->[Boolean]] condition, [->] action, [->] else) {
				[Boolean] result = \condition;
				\result:ifElse action else;
			};
			[[[Character][->]->]->] scanToken = *([[Character][->]->] provideCharacterAndContinueScannning) {
				[Variable<[Boolean]>] continuing = \[Variable<[Boolean]>]:as (\[Boolean]:true);
				\[Loops]:while (continuing:get) *{
					\continuing:set (\[Boolean]:false);
					\.currentCharacter:ifIs *([Character] character) {
						\provideCharacterAndContinueScannning character *{
							\continuing:set (\[Boolean]:true);
							\:gotoNextCharacter;
						};
					};
				};
			};
			[[[[Character]->]->]->[String]] stringFromCharacters = *([[[Character]->]->] getCharacters) -> [String] {
				[Data] asciiStringData = \[Data]:dataFromBytesWithByteProvider (*([[Byte]->] useByte) {
					\getCharacters *([Character] character) {
						\useByte (\character:asASCIIByte);
					};
				});
			} -> \[String]:stringWithASCIIDataRepresentationOfString asciiStringData;
			[[->][->]->] ifStrudelOrElse = *([->] action, [->] else) {
				[Maybe<[Character]>] maybeCurrentCharacter = .currentCharacter;
				\maybeCurrentCharacter:ifIs *([Character] currentCharacter) {
					\ifElse (currentCharacter:isStrudel) action else;
				};
				\maybeCurrentCharacter:ifNothing else;
			};
			[[Maybe<[Character]>][->][->][->]->] ifPlusOrMinusOrElse *([Maybe<[Character]>] maybeChar, [->] plux, [->] minus, [->] else) {
				\maybeChar:ifNothing
			};
		}
}


[SourcePosition :[Object]] (
			Integer,
			String,
			Variable,
			Object
		)
	[String] sourceName
	[Integer] line
	[Integer] column
{
	~ initialPositionIn *([String] sourceName) {
		\::lineAndColumnIn (\[Integer]:one) (\[Integer]:zero) sourceName;
	}

	~ @@-+-@@ lineAndColumnIn *([Integer] line, [Integer] column, [String] sourceName) {
		\::new;
		.sourceName = sourceName;
		.column = column;
		.line = line;
	}

	++ asString *-> [String] {
		[String] prefix = \[String]:as "- ";
		[String] colon = \[String]:as ":";
		[String] pos = \[String]:as " pos ";
		[String] line = \[String]:stringRepresentationOfInteger .line;
		[String] column = \[String]:stringRepresentationOfInteger .column;
	} -> (\prefix:appending (\.sourceName:appending (\colon:appending (\line:appending (\pos:appending column)))))

	++ nextColumn *-> [SourcePosition] {
	} -> \[SourcePosition]:lineAndColumnIn (.line) (\.column:adding (\[Integer]:one)) (.sourceName)

	++ startOfNextLine *-> [SourcePosition] {
	} -> \[SourcePosition]:lineAndColumnIn (\.line:adding (\[Integer]:one)) (\[Integer]:one) (.sourceName)
}


[Error :[Object]] (Object, String, SourcePosition, List, Variable)
	[String] errorString
{
	++ asString *-> [String] {
		[String] errorPrefix = \[String]:as "ERROR; ";
	} -> (\errorPrefix:appending .errorString)

	~ @@-+-@@ as *([String] errorString) {
		\::new;
		.errorString = errorString;
	}

	~ @@-+-@@ errorWithContext *([String] errorString, [List<[SourcePosition]>] context) {
		\::new;
		[Variable<[String]>] errorWithContext = \[Variable<[String]>]:as errorString;
		\context:iterate *([SourcePosition] sourcePosition) {
			[String] addedContext = (\prefix:appending (\sourcePosition:asString)) !{
					[String] prefix = \[String]:as "\n    ";
				};
			\errorWithContext:set (\prefix:appending addedContext) !{
					[String] prefix = \errorWithContext:get;
				};
		};
		.errorString = \errorWithContext:get;
	}

	:: sourceFileNotAccessible *([String] fileName) -> [Error] {
		[String] prefix = \[String]:as "Source file not accessible: ";
	} -> (\[Error]:as (\prefix:appending fileName))

	:: invalidToken *([String] token, [SourcePosition] position) -> [Error] {
		[String] prefix = \[String]:as "Invalid token: ";
		[List<[SourcePosition]>] context = \[List<[SourcePosition]>]:empty;
		\context:append position;
	} -> (\[Error]:errorWithContext (\prefix:appending token) context)
}


[Token :[Object]] (
			Object,
			Integer,
			String,
			Boolean,
			Variable
		)
	[Integer] id
	[Integer] secondId
	[String] content
{
	~ @@-+-@@ basicToken *([Integer] id) {
		\::new;
		.id = id;
		.content = \[String]:as "";
		.secondId = \[Integer]:zero;
	}

	~ @@-+-@@ secondIdToken *([Integer] id, [Integer] secondId) {
		\::new;
		.id = id;
		.content = \[String]:as "";
		.secondId = secondId;
	}

	~ @@-+-@@ contentToken *([Integer] id, [String] content) {
		\::new;
		.id = id;
		.content = content;
		.secondId = \[Integer]:zero;
	}

	++ @@-+-@@ id *->[Integer] {} -> .id
	++ @@-+-@@ content *->[String] {} -> .content
	++ @@-+-@@ secondId *->[Integer] {} -> .secondId

	++ asDebugString *->[String] {
		[String] idString = \[String]:stringRepresentationOfInteger .id;
		[String] seperator = \[String]:as "~";
		[String] secondIDString = \[String]:stringRepresentationOfInteger .secondId;
	} -> \idString:appending (\seperator:appending (\secondIDString:appending (\seperator:appending .content)))

	++ equals *([Token] t) -> [Boolean] {
	} -> (\[Boolean]:and (\[Boolean]:and (\.content:equals (\t:content)) (\.secondId:equals (\t:secondId))) (\.id:equals (\t:id)))

	@@:: visibilityIndicator *([Boolean] externalVisibility, [Boolean] classVisibility, [Boolean] inheritedVisibility) -> [Token] {
		[Variable<[Integer]>] visibility = \[Variable<[Integer]>]:as (\[Integer]:zero);
		\externalVisibility:ifElse (*{
				\visibility:set (\one:adding (\visibility:get));
			} !{[Integer] one = \[Integer]:one;}) *{};
		\classVisibility:ifElse (*{
				\visibility:set (\ten:adding (\visibility:get));
			} !{[Integer] ten = \[Integer]:newPositive 10;}) *{};
		\inheritedVisibility:ifElse (*{
				\visibility:set (\hundred:adding (\visibility:get));
			} !{[Integer] hundred = \[Integer]:newPositive 100;}) *{};
	} -> (\[Token]:secondIdToken (\[Integer]:newPositive 1) (\visibility:get))@@

	:: parentIdentifier *([Integer] repetitionCount) -> (\[Token]:secondIdToken (\[Integer]:newPositive 2) repetitionCount)
	:: identifier *([String] identifierString) -> (\[Token]:contentToken (\[Integer]:newPositive 3) identifierString)
	@:: dataSegment *([String] content) -> (\[Token]:contentToken (\[Integer]:newPositive 4) content)
	
	:: ampersand *-> (\[Token]:basicToken \[Integer]:newPositive 5)
	:: singleApostrophe *-> (\[Token]:basicToken \[Integer]:newPositive 6)
	:: arrow *-> (\[Token]:basicToken \[Integer]:newPositive 7)
	:: arrowBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 8)
	:: arrowBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 9)
	:: asterisk *-> (\[Token]:basicToken \[Integer]:newPositive 10)
	:: asteriskCaret *-> (\[Token]:basicToken \[Integer]:newPositive 11)
	:: asteriskDash *-> (\[Token]:basicToken \[Integer]:newPositive 12)
	:: backslash *-> (\[Token]:basicToken \[Integer]:newPositive 13)
	:: caret *-> (\[Token]:basicToken \[Integer]:newPositive 14)
	:: colon *-> (\[Token]:basicToken \[Integer]:newPositive 15)
	:: comma *-> (\[Token]:basicToken \[Integer]:newPositive 16)
	:: curlyBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 17)
	:: curlyBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 18)
	:: doubleApostrophe *-> (\[Token]:basicToken \[Integer]:newPositive 19)
	:: doubleColon *-> (\[Token]:basicToken \[Integer]:newPositive 20)
	:: doublePipe *-> (\[Token]:basicToken \[Integer]:newPositive 21)
	:: equalsSign *-> (\[Token]:basicToken \[Integer]:newPositive 23)
	:: exclamationMark *-> (\[Token]:basicToken \[Integer]:newPositive 24)
	:: forwardSlash *-> (\[Token]:basicToken \[Integer]:newPositive 25)
	:: fullStop *-> (\[Token]:basicToken \[Integer]:newPositive 26)
	:: percentSign *-> (\[Token]:basicToken \[Integer]:newPositive 27)
	:: pipe *-> (\[Token]:basicToken \[Integer]:newPositive 28)
	:: questionMark *-> (\[Token]:basicToken \[Integer]:newPositive 29)
	:: roundBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 30)
	:: roundBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 31)
	:: semicolon *-> (\[Token]:basicToken \[Integer]:newPositive 32)
	:: squareBracketOpen *-> (\[Token]:basicToken \[Integer]:newPositive 33)
	:: squareBracketClose *-> (\[Token]:basicToken \[Integer]:newPositive 34)
	:: tilde *-> (\[Token]:basicToken \[Integer]:newPositive 36)
	:: doubleLessThan *-> (\[Token]:basicToken \[Integer]:newPositive 37)
}


[DainaClass :[Object]] (
			Object, 
			Parser, 
			List,
			Loops,
			Token,
			Boolean,
			Maybe,
			String,

			Debug
		)
{
	:: parseClasses *([Parser] parser) -> [List<[DainaClass]>] {
		\[Loops]:while (*->[Boolean]{[Maybe<[Token]>] token = \parser:token;}->\token:is (*([]a)->\[Boolean]:true)) *{
			[Maybe<[Token]>] maybeToken = \parser:token;
			\maybeToken:ifIs *([Token] token) {
				\[Debug]:log (\token:asDebugString);
				\[Debug]:log (\[String]:as "\n");
			};
			\parser:gotoNextToken;
		}
	} -> \[List<[DainaClass]>]:empty
}









